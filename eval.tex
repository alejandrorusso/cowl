\section{Evaluation}
\label{sec:eval}

The practicality of new browser features is largely determined
by their performance.
%
To evaluate the performance of \sys{}, we ran experiments to
quantify the performance of our new primitives, as well as their
impact on legacy web sites which did not use our features.
%
This experiments were a series of micro-benchmarks on API functions,
as well as macro-benchmarks on our example applications.
%
All our measurements were conducted on a 4-core i7-2620M machine
running GNU/Linux 3.13, with 16GB of RAM\@; we used the NodeJS web
server for all our applications.

\subsection{Micro benchmarks}
\label{sec:eval:micro}

\newcommand*\rot{\rotatebox{90}}

\begin{table}
\centering
\resizebox{1.0\columnwidth}{!}{
\begin{tabular}{l |c|c|c|c|c|c }
\toprule
                   & \multicolumn{3}{c}{\textbf{Firefox}}
                   & \multicolumn{3}{c}{\textbf{Chromium}} \\
                   & \rot{vanilla}   &
                     \rot{unlabeled} &
                     \rot{labeled}   &
                     \rot{vanilla}   &
                     \rot{unlabeled} &
                     \rot{labeled}   
\\\midrule%--------------------------------------------------------------------
% cost of creating an iframe                                         
New iframe         & 14.4    &  14.5    &  14.4   &   50.6 &   48.7 & 51.8  %% avg of 10 runs
\\
% cost of creating a worker                                          
New worker         & 15.9    &  15.4   &   0.90$\dagger$    &  18.9  &  18.9  & 3.3$\dagger$  %% avg of 10 runs
\\\midrule%--------------------------------------------------------------------
% cost of labeled postMessage                                        
Iframe comm.       &  0.11   &  0.11   &   0.12  &  0.04  &  0.04  & 0.04 %% avg # messages/10seconds
\\
% cost of performing XHR                                             
XHR comm           &  3.5   &   3.6   &  3.7   &  7.0    &  7.4    & 7.2 %1000request in 10 iframes
\\
% cost of worker ping-pong                                           
Worker comm.       &  0.20    &   0.24  &  0.03$\ddagger$   &  0.07  &  0.07  & 0.03$\ddagger$  % 90 messages ping-pong
%%\\\midrule%--------------------------------------------------------------------
%%% cost of setting current label                                      
%%Set label          &  --     &  \multicolumn{2}{c|}{0.0016} &   --   
%%                             &  \multicolumn{2}{c }{0.0018}
%%%10 iframes doing 10,000 ops
%%\\\hline%-------------------------------------------------------------------------------------------------
%%% cost of setting current label                                                                   
%%Get label          &  --     &  \multicolumn{2}{c|}{0.0001} &   --   
%%                             &  \multicolumn{2}{c }{0.0008}
%%\\\hline%-------------------------------------------------------------------------------------------------
%%% cost of comparing labels                                                                        
%%Label check        &  --     &  \multicolumn{2}{c|}{0.0011} &   --   
%%                             &  \multicolumn{2}{c }{0.0004}
%%%10 iframes doing 10,000 subsumes of random labels with 4 principals
\\\bottomrule
\end{tabular}
}
\caption{Micro-benchmarks, in milliseconds (ms).}
\label{microbench} 
\end{table}

Table~\ref{microbench} shows our micro-benchmarks for the stock
browsers (vanilla), our modified browsers with confinement-mode turned
off (unlabeled), and confinement-mode enabled (labeled).
%
For the creation of compartments, \sys{} adds negligible latency (less
than 1ms).
%
Furthermore, the cost of creating lightweight workers is considerably
faster than the ``normal'' workers ($\dagger$).

\paragraph{Communication} The iframe, worker and XHR communication measurements evaluate the
cost of sending and receiving a message (\js|PING| and \js|PONG|,
respectively) across iframes, workers, and the network.
%
For the XHR benchmark, we report the cost of using the labeled XHR
constructor, i.e., XHR with the response type set to
\verb|"labeled-blob"|, averaged over 10,000 requests.
%
Our Chromium implementation utilized a lightweight worker to wrap the XHR
constructor, so the cost using labeled XHR accounts for an additional
cross-compartment call.

Once again, communicating with lightweight workers ($\ddagger$)
is
faster than communicating with Web Workers.
%
This speedup is due to the fact that the light-weight workers share
share an (OS thread and) event-loop with their parent.
%
However, this does mean that at 90 messages, we exhaust the call
stack.

%%As shown in the table, we measured the cost of getting the current
%%label, setting the current label and performing a label comparison
%%(subsumes) over the span of 10,000 operations.
%%%
%%The first two measurements, as in the case of sending labeled
%%messages, use a single label: the public label.  Since the subsumes
%%algorithm varies according to the labels, our measurements use
%%randomly generated labels, with up to 5 origins.
%%%
%%When considering labels with more principals, we expect the
%%performance impact of labels to naturally be higher; we used 5 origins
%%since we expect real apps to only contain a handful of principals.
%%%
%%The cost of all these ``core'' label operations are within
%%1 microsecond.

\paragraph{Labels} While not pictured in Table~\ref{microbench},
we also measured the cost of setting/getting the current label and the
average cost of a label check.
%
For a random label with a handful of origins, these operations are on
the order of 1 microsecond.
%
The primary cost is recomputing
cross-compartment wrappers, which ends up costing up to 13ms (e.g., when
the label is raised from public to a third-party origin).
%
For many real applications, we expect the raising the current label
to be a rare occurrence.
%
Moreover, there is much room for optimization: in some cases,
we could avoid changing the underlying CSP policy and document
origin upon a label range, if a compartment is already completely confined.
 
\paragraph{DOM} We also executed the Dromaeo benchmark suite~\cite{dromaeo} on both
Firefox and Chromium.
%
This benchmark evaluated the performance of core functionality,
such as querying, traversing, and manipulating the DOM when
\sys{} was disabled, assessing \sys{}'s overhead when it is not
turned on.
%
We found that DOM performance to be on par with
the vanilla code---the largest slowdown for both browsers was under
4\%.

\subsection{Macro benchmarks}
\label{sec:eval:macro}

We also measured the end-to-end performance (usually page load time) of
simplified version of our applications.
%
To focus our comparison on \sys{}, as opposed to the overhead of
compartmentalizing an application, we compared our applications
against modified versions running on vanilla browsers which skipped any security
related checks, but still had the same compartmentalization.
%
%We acknowledge that compartmentalization

\paragraph{Password-strength checker}
%% Vanilla: just run script in worker
%% Firefox: With \sys{} it take 59.5ms, Vanilla: 61.4
%% Chome: With \sys{} it take 80.5ms, Vanilla:  71.5
%
We implemented the password-strength checker of
Section~\ref{sec:motivating-examples} using the checker script
from~\cite{checker1}.
%
Our end-to-end evaluation measures the average duration it takes to
create a new LWorker, fetch the 8KB checker script, and check a password
sixteen characters in length.
%
In Firefox, the average (over 10 runs) amount of time it took to
perform the strength checking is 18ms.
%
This figure, is roughly 4ms faster than the strength checker,
which ran in a normal Web Worker on a vanilla, unmodified, browser,
on account of the speed-up attribute to LWorkers.
%
Similarly, the Chromium implementation (which solely uses the
compartment labels) is 5ms faster than the vanilla version (measured
at 54ms).
%
However, using our light-weight worker is 5ms slower than simply
using an inline script.
Indeed solely creating the LWorker compartment to isolate the script
accounts for this.


\paragraph{Encrypted document editor}
%% Vanilla: removed the sandbox stuff.
%% Firefox: With \sys{} it take 114.8, Vanilla: 100.2
%% Chome: With \sys{} it take 248.1, Vanilla; 257.8

We implemented a simple document editor as described in
Section~\ref{sec:apps}.
%
Our benchmark measures the end-to-end time it takes to load the
application, and encrypt a new 4KB document using
the SJCL AES-128 library~\cite{sjcl}.
%
We measured the \sys{} application to take 116ms on the modified
version of Firefox; a simplified, insecure version of the app,
running on vanilla Firefox, took 100ms.
%
This figure accounts for the amount of time it takes to
load the document editor page, which itself loads the encryption layer
as an iframe, which further loads the actual editor.
%
The most expensive operation in the secured application
is raising of the current label, since it requires changing the CSP, the
underlying document origin, and most importantly, recomputing the
cross-compartment wrappers (to ensure that DOM access is restricted
according to confinement).
%
In Chromium, the performance of the \sys{} and insecure applications
were comparable; the measured load time was within 1ms of 244ms.
%
This is because the Chrome implementation does not utilize cross-compartment
wrappers, so no recomputation is necessary.


\paragraph{Third-party mashup}
%% Firefox: With \sys{} it take 10.7ms, Vanilla:  10.7ms
%% Chrome: With \sys{} it take 15ms, Vanilla:  17ms
%% 
%% Vanilla: just remove sandbox stuff + add CORS

We implemented a very simple third-party mashup application which
made an XHR request to two unaffiliated origins, each
of which produces a response containing a (27 byte) JSON Blob
object with a numerical property, and summed the responses
together.
%
The corresponding vanilla application is identical, but uses the normal
XHR object; in this case, CORS was used to permit cross-origin access.
%
In Firefox, we measured the latency of the application to be 41ms when
using labeled XHR and 35ms when using CORS headers; the slowdown is once
again due to the raising of the current label (two times) to incorporate
sensitive data within the context.
%
In Chromium, the latency of the \sys{} was measured to be 55ms, 
which is 2ms slower than the vanilla application; this
slowdown was due to the overhead of creating and communicating with the light-weight worker
that wraps the XHR object.

\paragraph{Untrusted third-party library}
%% Vanilla: incorporate script directly, no sandboxes.
%% As page confine:
%% Firefox: With \sys{} it take 164.8ms, Vanilla:  160.2ms

We measured the load time of a banking app that incorporates jQuery and
a library that traverses the DOM to replace phone numbers with links.
%
Furthermore, the latter library uses XHR in attempt to leak the page content.
%
The bank page is compartmentalized into a public outer component and
a sensitive iframe containing the user's statement;
in both compartments, the bank trusted code (which load the libraries)
is placed in a labeled DOM worker, with access to the page document
and privilege, treating the rest of the code as untrusted.
%
Since our current Chromium implementation does not yet support
light-weight workers with DOM access, we only report numbers for
Firefox.
%
The load time for this application was 164.8ms, 4.6ms longer than an
insecure version of the application running on vanilla Firefox.
%
%
This slowdown is negligible considering that the
application contains mixed-sensitivity content (the main banking page
is public, while the bank statement iframe is labeled with the origin
of the page). \sys{} prevents the statement from being leaked; in the vanilla
case, the untrusted library trivially leaks the bank statement with
XHR\@.

%% Vanilla: incorporate script directly, no sandboxes.
%% 
%% As page confine:
%% Firefox: With \sys{} it take 164.8ms, Vanilla:  160.2ms
%% 
%% As extension
%% Firefox: With \sys{} it take 224.4ms



%%Comparing the 
%%Similarly, the performance impact of labels is under  5\%  in almost
%%every case.

