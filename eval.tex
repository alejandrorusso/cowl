\section{Evaluation}
\label{sec:eval}

When adding new browser features, even security-centric ones, the
question of how performance or functionality is affected can become a
roadblock to adoption.
%
In the case of \sys{}, this question is two-fold.
%
First, are existing websites affected by our modifications?
%
Since our system relies on a page to enable confinement mode by using
our API (or web server to be aware of \sys{}-aware browsers), the
functionality of existing websites is not affected---hence we are
solely concerned with how \sys{} affects the performance of existing
apps.
%
Second, is the performance of an end-to-end application that uses
\sys{} acceptable, for instance, when compared to a comparable, but
insecure app?
%
In this section we answer these questions.
%
Specifically, we first evaluate the end-to-end performance of the
applications described in Section~\ref{sec:apps}, relative to
implementations that simply trade off security for features.
%
Then, we measure the performance impact of \sys{} on existing browser
features with and without confinement-mode enabled.
%
All our measurements were conducted on a 4-core i7-2620M machine
running GNU/Linux 3.13, with 16GB of RAM.
%


\subsection{Macro benchmarks}
\label{sec:eval:macro}

Below we measure the performance (usually page load time) of
simplified version of our applications running on our modified
browsers.
%
To understand whether the performance as noticed by the user is
reasonable, we modified the applications by removing any security
related checks and measured their performance on unmodified, vanilla
browsers.
%
In fairness, we remark that these applications are compartmentalized
to address the different trust relationships; an alternative
(insecure) implementation may produce better results.

\paragraph{Password-strength checker}
%% Vanilla: just run script in worker
%% Firefox: With \sys{} it take 59.5ms, Vanilla: 61.4
%% Chome: With \sys{} it take 80.5ms, Vanilla:  71.5
%
We implemented the password-strength checker of
Section~\ref{sec:motivating-examples}, using the checker script
from~\cite{checker1}.
%
Our end-to-end evaluation measures the average duration it takes to
create a new labeled worker (with a fresh principal), fetch (with XHR)
the 8KB checker script, and perform the actual strength
checking on a password 16-characters in length.
%
%
In Firefox the average (over 10 runs) amount of time it takes to
perform the strength checking is 18ms.
%
This figure, is roughly 4ms faster than the strength checker running
running in a ``normal'' worker on a vanilla, unmodified, browser.
%
We attribute this speedup---although small, it also encompasses
security checks---to the fact that creating and communicating with
light-weight workers is cheaper than ``normal'' workers (see
Section~\ref{sec:eval:micro}.
%
Similarly, the Chromium implementation (which solely uses the
compartment labels) is 5ms faster than the vanilla version (measured
at 54ms).


\paragraph{Encrypted document editor}
%% Vanilla: removed the sandbox stuff.
%% Firefox: With \sys{} it take 114.8, Vanilla: 100.2
%% Chome: With \sys{} it take 248.1, Vanilla; 257.8

We implemented a simple document editor as described in
Section~\ref{sec:apps}.
%
Our benchmark measures the end-to-end time it takes to load the
application, and ``encrypt'' a new 4KB document using
the \Red{SJCL AES-128 library~\cite{sjcl}}.
%
We measured the \sys{} application to take \Red{114.8ms} on the modified
version of Firefox; the simplified, insecure version of the app,
running on vanilla Firefox took \Red{100ms}.
%
We note that our figure accounts for the amount of time it takes to
load the document editor page, which itself loads the encryption layer
as an iframe, which further loads the actual editor.
%
We attribute the (small) 14.8ms slowdown to both the label checks
performed by \sys{} and security layer added on top of the insecurity
application---in the vanilla case, we removed the label operations and
authentication layer (used to ensure that the label of the innermost
iframe is sufficiently high).
%
\Red{Similarly, in Chromium...}


\paragraph{Third-party mashup}
%% Firefox: With \sys{} it take 10.7ms, Vanilla:  10.7ms
%% Chrome: With \sys{} it take 15ms, Vanilla:  17ms
%% 
%% Vanilla: just remove sandbox stuff + add CORS

We implemented a very simple third-party mashup application in which
the integrator makes an XHR request to two unaffiliated origins, each
of which produces a response containing a (\Red{27 byte}) JSON Blob
object with a numerical property.
%
The integrator parses the responses into JSON objects, adds the
numbers, and appends a \js|div| element, containing the sum, to the
document body.
%
The corresponding vanilla application is identical, but uses the
normal XHR object; in this case, the unaffiliated origins set CORS
headers that permit responses to be inspected by any origin.
%
In Firefox, we measured the latency of the application to be
\Red{10.7ms in both cases}.
%
Of course, the \sys{} application has the advantage of treating the
received content as sensitive (and thus required setting proper CSP
and iframe sandbox flags) when compared to the CORS-based approach
that would allow the integrator to arbitrarily leak the sum.

\paragraph{Untrusted third-party libray}
%% Vanilla: incorporate script directly, no sandboxes.
%% As page confine:
%% Firefox: With \sys{} it take 164.8ms, Vanilla:  160.2ms

We measure the load time of a banking app that incorporates jQuery and
a library that traverses the DOM to replace phone numbers with links.
%
The latter library uses XHR in attempt to leak the page content.
%
The bank page is compartmentalized into a public outer component and
a sensitive iframe containing the user's statement;
in both compartments, the bank trusted code (which load the libraries)
is placed in a labeled DOM worker, with access to the page document
and privilege, treating the rest of the code as untrusted.
%
We measured the total load time of the page.
%
In Firefox, the load time was \Red{164.8ms}, \Red{4.6ms} longer than
an insecure version of the application running on vanilla Firefox.
%
We remark that this slowdown is negligible considering that the
application contains mixed-sensitivity content (the main banking page
is public, while the bank statement iframe is labeled with the origin
of the page), which \sys{} prevents from being leaked; in the vanilla
case, the untrusted library trivially leaks the bank statement with
XHR.

%% Vanilla: incorporate script directly, no sandboxes.
%% 
%% As page confine:
%% Firefox: With \sys{} it take 164.8ms, Vanilla:  160.2ms
%% 
%% As extension
%% Firefox: With \sys{} it take 224.4ms

\subsection{Micro benchmarks}
\label{sec:eval:micro}

\newcommand*\rot{\rotatebox{90}}

\begin{table}
\centering
\resizebox{1.0\columnwidth}{!}{
\begin{tabular}{l |c|c|c|c|c|c }
\toprule
                   & \multicolumn{3}{c}{\textbf{Firefox}}
                   & \multicolumn{3}{c}{\textbf{Chromium}} \\
                   & \rot{vanilla}   &
                     \rot{unlabeled} &
                     \rot{labeled}   &
                     \rot{vanilla}   &
                     \rot{unlabeled} &
                     \rot{labeled}   
\\\midrule%--------------------------------------------------------------------
% cost of creating an iframe                                         
New iframe         & 14.4    &  14.5    &  14.4   &   50.63 &   48.73 & 51.77  %% avg of 10 runs
\\\hline%----------------------------------------------------------------------
% cost of creating a worker                                          
New worker         & 15.9    &  15.4   &   0.9   &  18.94  &  18.87  & 3.27  %% avg of 10 runs
\\\midrule%--------------------------------------------------------------------
% cost of labeled postMessage                                        
Iframe comm.       &  0.11   &  0.11   &   0.12  &  0.042  &  0.042  & 0.042 %% avg # messages/10seconds
\\\hline%----------------------------------------------------------------------
% cost of performing XHR                                             
XHR comm           &  3.59   &   3.62   &  3.72   &  7.0    &  7.4    & 7.2 %1000request in 10 iframes
\\\hline%----------------------------------------------------------------------
% cost of worker ping-pong                                           
Worker comm.       &  0.2    &   0.24  &  0.033  &  0.071  &  0.070  & 0.030 % 90 messages ping-pong
%%\\\midrule%--------------------------------------------------------------------
%%% cost of setting current label                                      
%%Set label          &  --     &  \multicolumn{2}{c|}{0.0016} &   --   
%%                             &  \multicolumn{2}{c }{0.0018}
%%%10 iframes doing 10,000 ops
%%\\\hline%-------------------------------------------------------------------------------------------------
%%% cost of setting current label                                                                   
%%Get label          &  --     &  \multicolumn{2}{c|}{0.0001} &   --   
%%                             &  \multicolumn{2}{c }{0.0008}
%%\\\hline%-------------------------------------------------------------------------------------------------
%%% cost of comparing labels                                                                        
%%Label check        &  --     &  \multicolumn{2}{c|}{0.0011} &   --   
%%                             &  \multicolumn{2}{c }{0.0004}
%%%10 iframes doing 10,000 subsumes of random labels with 4 principals
\\\bottomrule
\end{tabular}
}
\caption{Micro-benchmarks, in milliseconds (ms).}
\label{microbench} 
\end{table}

Table~\ref{microbench} shows our micro-benchmarks for the stock
browsers (vanilla), our modified browsers with confinement-mode turned
off (unlabeled), and confinement-mode enabled (labeled).
%
We measure the cost of creating various compartments (workers and
iframes) and sending messages between various end-points
(compartments and servers).

%
The average (of 10 runs creating 10) performance impact of creating an
iframe or worker is within 3.5\% and 2.5\% of the vanilla
implementations on Firefox and Chromium, respectively.
%
In absolute terms, \sys{} adds, on average, less than 1ms latency.
%
(We remark that our measurements for Chromium are on a slightly older
version and thus the performance numbers are generally worse than
those of Firefox.)
%
In the labeled case we report the cost of creating light-weight labeld
workers; as expected, creating these compartments is considerably
faster than the ``normal'' workers, roughly 17 and 6 times on Firefox
and Chromium, respectively.

%
The iframe, worker and XHR communication measurements evaluate the
cost of sending and receiving a message (\js|PING| and \js|PONG|,
respectively) across iframes, workers, and the network.
%
In all cases, the performance impact of \sys{} is negligible when
compared to an unmodified, vanilla browser.
%
For the XHR benchmark, we report the cost of using the labeled XHR
constructor, i.e., XHR with the response type set to
\verb|"labeled-blob"|; the average (of 10,000 requests) performance
impact of labels (local-network test) is less than 3.6\% for both
browsers, which amounts to a less than 0.5ms delay.
%
(Our Chromium implementation does not yet have support for XHR with
labeled blobs; instead labeled workers are used to wrap the XHR
constructor, so the cost using labeled XHR accounts for an additional
cross-compartment call.)
%
We highlight that, in contrast to the worker communication cost,
communicating with light-weight workers is is roughly 6 and 2 times
faster on Firefox and Chromium.
%
This speedup is due to the fact that the light-weight workers share
share an (OS thread and) event-loop with their parent.
%
This, however, has the limitation of exhausting the call stack at 90
messages in our measurements.

%%As shown in the table, we measured the cost of getting the current
%%label, setting the current label and performing a label comparison
%%(subsumes) over the span of 10,000 operations.
%%%
%%The first two measurements, as in the case of sending labeled
%%messages, use a single label: the public label.  Since the subsumes
%%algorithm varies according to the labels, our measurements use
%%randomly generated labels, with up to 5 origins.
%%%
%%When considering labels with more principals, we expect the
%%performance impact of labels to naturally be higher; we used 5 origins
%%since we expect real apps to only contain a handful of principals.
%%%
%%The cost of all these ``core'' label operations are within
%%1 microsecond.

We measured the cost of setting/getting the current label and the
average cost of a label check.
%
For a random label with a handful of origins these operations are on
the order of 1 microsecond; in most cases it is the re computation of
cross-compartment wrappers that ends up costing \Red{XXXms}.
 
More interestingly,  we executed the Dromaeo benchmark
suite~\cite{dromaeo} on both Firefox and Chromium.
%
This benchmark evaluates the performance of core functionality,
such as querying, traversing, and manipulating the DOM.
%
Since the cost of our DOM interposition code amounts to a branch
condition that checks if the current page has enabled
confinement-mode, we expected the slowdown to be minimal. Indeed, we
found that DOM performance for both labeled browsers to be on par with
the vanilla code---the largest slowdown for both browsers was under
4\%.



%%Comparing the 
%%Similarly, the performance impact of labels is under  5\%  in almost
%%every case.

