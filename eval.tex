\section{Evaluation}
\label{sec:eval}

Performance largely determines acceptance of new browser features
in practice.
%
To evaluate the performance of \sys{}, we ran experiments to quantify
the cost of our new primitives, as well as their impact on legacy web
sites that do not use \sys{}'s features.
%
Our experiments consist of micro-benchmarks on API functions and
end-to-end benchmarks of our example applications.
%
We conducted our measurements on a 4-core i7-2620M machine with 16GB
of RAM\@ running GNU/Linux 3.13; we used the Node.js web server for
all our applications.

\subsection{Micro-Benchmarks}
\label{sec:eval:micro}

\newcommand*\rot{\rotatebox{90}}

\begin{table}
\centering
\resizebox{1.0\columnwidth}{!}{
\begin{tabular}{l |c|c|c|c|c|c }
\toprule
                   & \multicolumn{3}{c}{\textbf{Firefox}}
                   & \multicolumn{3}{c}{\textbf{Chromium}} \\
                   & \rot{vanilla}   &
                     \rot{unlabeled} &
                     \rot{labeled}   &
                     \rot{vanilla}   &
                     \rot{unlabeled} &
                     \rot{labeled}   
\\\midrule%--------------------------------------------------------------------
% cost of creating an iframe                                         
New iframe         & 14.4    &  14.5    &  14.4   &   50.6 &   48.7 & 51.8  %% avg of 10 runs
\\
% cost of creating a worker                                          
New worker         & 15.9    &  15.4   &   0.90$\dagger$    &  18.9  &  18.9  & 3.3$\dagger$  %% avg of 10 runs
\\\midrule%--------------------------------------------------------------------
% cost of labeled postMessage                                        
Iframe comm.       &  0.11   &  0.11   &   0.12  &  0.04  &  0.04  & 0.04 %% avg # messages/10seconds
\\
% cost of performing XHR                                             
XHR comm           &  3.5   &   3.6   &  3.7   &  7.0    &  7.4    & 7.2 %1000request in 10 iframes
\\
% cost of worker ping-pong                                           
Worker comm.       &  0.20    &   0.24  &  0.03$\ddagger$   &  0.07  &  0.07  & 0.03$\ddagger$  % 90 messages ping-pong
%%\\\midrule%--------------------------------------------------------------------
%%% cost of setting current label                                      
%%Set label          &  --     &  \multicolumn{2}{c|}{0.0016} &   --   
%%                             &  \multicolumn{2}{c }{0.0018}
%%%10 iframes doing 10,000 ops
%%\\\hline%-------------------------------------------------------------------------------------------------
%%% cost of setting current label                                                                   
%%Get label          &  --     &  \multicolumn{2}{c|}{0.0001} &   --   
%%                             &  \multicolumn{2}{c }{0.0008}
%%\\\hline%-------------------------------------------------------------------------------------------------
%%% cost of comparing labels                                                                        
%%Label check        &  --     &  \multicolumn{2}{c|}{0.0011} &   --   
%%                             &  \multicolumn{2}{c }{0.0004}
%%%10 iframes doing 10,000 subsumes of random labels with 4 principals
\\\bottomrule
\end{tabular}
}
\caption{Micro-benchmarks, in milliseconds (ms).}
\label{microbench} 
\end{table}

Table~\ref{microbench} shows micro-benchmarks for the stock
browsers (vanilla), the \sys{} browsers with confinement mode turned
off (unlabeled), and with confinement mode enabled (labeled).
%
\sys{} adds negligible latency (less than 1ms) to compartment
creation.
%
Furthermore, the cost of creating lightweight workers is considerably
less than that for ``normal'' workers ($\dagger$).

\paragraph{Communication} The iframe, worker, and XHR communication measurements evaluate the
round-trip latencies across iframes, workers, and the network.
%
For the XHR benchmark, we report the cost of using the labeled XHR
constructor---\emph{i.e.,} XHR with the response type set to
\verb|labeled-blob|---averaged over 10,000 requests.
%
Our Chromium implementation uses a lightweight worker to wrap the XHR
constructor, so the cost of labeled XHR incorporates an additional
cross-context call.

As with creation, communicating with lightweight workers ($\ddagger$)
incurs less latency than with Web Workers.
%
This speedup arises because a lightweight worker shares
 an OS thread and event loop with their parent.
%
However, this sharing means that at 90 messages, we exhaust the call
stack.

%%As shown in the table, we measured the cost of getting the current
%%label, setting the current label and performing a label comparison
%%(subsumes) over the span of 10,000 operations.
%%%
%%The first two measurements, as in the case of sending labeled
%%messages, use a single label: the public label.  Since the subsumes
%%algorithm varies according to the labels, our measurements use
%%randomly generated labels, with up to 5 origins.
%%%
%%When considering labels with more principals, we expect the
%%performance impact of labels to naturally be higher; we used 5 origins
%%since we expect real apps to only contain a handful of principals.
%%%
%%The cost of all these ``core'' label operations are within
%%1 microsecond.

\paragraph{Labels} While not pictured in Table~\ref{microbench},
we also measured the cost of setting/getting the current label and the
average cost of a label check.
%
For a randomly generated label with a handful of origins, these
operations take on the order of one microsecond.
%
The primary cost is recomputing cross-compartment wrappers and
the underlying CSP policy, which ends up costing up to 13ms (\emph{e.g.,} when
the label is raised from public to a third-party origin).
%
For many real applications, we expect raising the current label
to be a rare occurrence.
%
Moreover, there is much room for optimization: {\em e.g.,} in some cases,
we could avoid changing the underlying CSP policy and document
origin upon a label change when a compartment is already completely confined.
%%\todo{}{What about examplifying like ``, \emph{i.e.,} when the CSP policy has been set to default-src `none`''}.
 
\paragraph{DOM} We also executed the Dromaeo benchmark suite~\cite{dromaeo},
which evaluates the performance of core functionality
such as querying, traversing, and manipulating the DOM, on Firefox
and Chromium. We compared the performance of the browsers with
\sys{} disabled {\em vs.}~with \sys{} enabled.
%
The \sys{}-enabled browsers' DOM performance is on par with that of
the vanilla browsers; the greatest slowdown for either browsers was
under 4\%.

\subsection{End-to-End Benchmarks}
\label{sec:eval:macro}

To assess \sys{}'s impact on end-to-end performance, we measured
page load times for simplified versions of the example applications.
%
To focus our comparison on \sys{}'s overhead, as opposed to on the
overhead of compartmentalizing an application, we compared the example
applications against modified versions running on vanilla browsers
that skip security-related checks, but structured as the same set of
compartments.
%
%We acknowledge that compartmentalization

\paragraph{Password-Strength Checker}
%% Vanilla: just run script in worker
%% Firefox: With \sys{} it take 59.5ms, Vanilla: 61.4
%% Chome: With \sys{} it take 80.5ms, Vanilla:  71.5
%
We built the password-strength checker of
Section~\ref{sec:motivating-examples} using the checker script
from~\cite{checker1}.
%
We measure the average duration of creating a new LWorker, fetching
the 8KB checker script, and checking a password sixteen characters in
length.
%
\sys{}-enabled Firefox runs the checker in an average of 18 ms (averaged
over ten runs), whereas the checker takes 4 ms longer to run in a
normal Web Worker in vanilla, unmodified Firefox. The speedup derives
from \sys{}'s LWorkers.
%
%% This figure, is roughly 4ms faster than the strength checker,
%% which ran in a normal Web Worker on a vanilla, unmodified, browser,
%% on account of the speed-up attribute to LWorkers.
%
Similarly, the checker runs 5 ms faster in the \sys{} Chromium
implementation (which solely uses the compartment labels) than in the
vanilla Chromium (measured at 54 ms).
%
We note that \sys{}'s lightweight worker is 5 ms slower than simply
using an inline script, though the latter provides no confinement.

\paragraph{Encrypted Document Editor}
%% Vanilla: removed the sandbox stuff.
%% Firefox: With \sys{} it take 114.8, Vanilla: 100.2
%% Chome: With \sys{} it take 248.1, Vanilla; 257.8

We implemented a simple encrypted document editor after the
design in Section~\ref{sec:apps}.
%
Our benchmark measures the end-to-end time taken to load the
application and encrypt a new 4KB document using
the SJCL AES-128 library~\cite{sjcl}.
%
This workload completes in 116 ms on the \sys{}-enabled
version of Firefox. A simplified, non-confined version of the app
running on vanilla Firefox completes in 100ms.
%
The total run time includes the time taken to load the document editor
page, which in turn loads the encryption layer as an iframe, which
further loads the actual editor.
%
The most expensive operation in the secured application is raising the
current label, since it requires changing the CSP, the underlying
document origin, and most importantly, recomputing the
cross-compartment wrappers and CSP (to ensure that DOM and network
access is restricted according to confinement).
%
In Chromium, the performance of the \sys{} and insecure applications
were comparable; the measured completion time was within 1ms of 244ms.
%
As the Chrome implementation does not use cross-compartment
wrappers, no recomputation is necessary.


\paragraph{Third-Party Mashup}
%% Firefox: With \sys{} it take 10.7ms, Vanilla:  10.7ms
%% Chrome: With \sys{} it take 15ms, Vanilla:  17ms
%% 
%% Vanilla: just remove sandbox stuff + add CORS

We implemented a very simple third-party mashup application that makes
an XHR request to two unaffiliated origins, each of which produces a
response containing a 27-byte JSON Blob object with a numerical
property, and sums the responses together.
%
The corresponding vanilla application is identical, but uses the
normal XHR object; in this case, we use CORS to permit cross-origin
access.
%
In Firefox, the \sys{}-enabled version completed in 41 ms while the
vanilla version completed in 35ms. The slowdown derives from \sys{}'s
raising the current label twice to incorporate sensitive data within
the context.
%
In Chromium, the \sys{}-enabled version completed in 55 ms, 2 ms
slower than the vanilla one. The slowdown derives from \sys{}'s
creating and communicating with the lightweight worker that wraps the
XHR object.

\paragraph{Untrusted Third-Party Library}
%% Vanilla: incorporate script directly, no sandboxes.
%% As page confine:
%% Firefox: With \sys{} it take 164.8ms, Vanilla:  160.2ms

We measured the load time of a banking application that incorporates
jQuery and a library that traverses the DOM to replace phone numbers
with links.
%
Furthermore, the latter library uses XHR in attempt to leak the page's
content.
%
We compartmentalize the bank page into a public outer component and a
sensitive iframe containing the user's statement. In both
compartments, we place the bank's trusted code (which loads the
libraries) in a labeled DOM worker with access to the page document
and privilege. We treat the rest of the code as untrusted.
%
As our current Chromium implementation does not yet support DOM access
for lightweight workers, we only report measurements of Firefox.
%
Firefox loaded the \sys{}-enabled application in 164.8 ms, 4.6 ms
longer than a non-confined version of the application running on
vanilla Firefox.
%
%
This slowdown is negligible considering that the application contains
mixed-sensitivity content---the main banking page is public, while the
bank statement iframe is labeled with the origin of the page. \sys{}
prevents the statement from being leaked; in the vanilla case, the
untrusted library trivially leaks the bank statement with XHR\@.

%% Vanilla: incorporate script directly, no sandboxes.
%% 
%% As page confine:
%% Firefox: With \sys{} it take 164.8ms, Vanilla:  160.2ms
%% 
%% As extension
%% Firefox: With \sys{} it take 224.4ms



%%Comparing the 
%%Similarly, the performance impact of labels is under  5\%  in almost
%%every case.

