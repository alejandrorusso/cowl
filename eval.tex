\section{Evaluation}
\label{sec:eval}

When adding new browser features, even security-centric ones, the
question of how performance or functionality is affected can become a
roadblock to adoption.
%
In the case of \sys{}, this question is two-fold.
%
First, are existing websites affected by our modifications?
%
Since our system relies on a page to enable confinement mode by using
our API, the functionality of existing websites is not
affected---hence we are solely concerned with how \sys{} affects the
performance of existing apps.
%
Second, is the performance of an end-to-end application that uses
\sys{} acceptable, for instance, when compared to a comparable, but
insecure app?
%
In this section we answer these questions.
%
Specifically, we first evaluate the end-to-end performance of the
applications described in Section~\ref{sec:apps}, relative to
implementations that simply trade off security for features.
%
Then, we measure the performance impact of \sys{} on existing browser
features with and without confinement-mode enabled.
%
All our measurements were conducted on a 4-core i7-2620M machine
running GNU/Linux 3.13, with 16GB of RAM.
%


\subsection{Macro benchmarks}
\label{sec:eval:macro}

Below we measure the performance (usually page load time) of some of
the applications on our modified browsers.
%
To underhand whether the performance as noticed by the user is
reasonable, we modified the applications by removing any security
related checks and measured their performance on unmodified, vanilla
browsers.
%
In fairness, we remark that these applications are compartmentalized
to address the different trust relationships; an alternative
(insecure) implementation may produce better results.

\paragraph{Password-strength checker}
%% Vanilla: just run script in worker
%% Firefox: With \sys{} it take 59.5ms, Vanilla: 61.4
%% Chome: With \sys{} it take 80.5ms, Vanilla:  71.5
%
We implemented the password-strength checker of
\Red{Section~\ref{sec:motiv:checker}}, using the checker script
from~\cite{checker1}.
%
Our end-to-end evaluation measures the average duration it takes to
create a new labeled worker (with a fresh principal), fetch (with XHR)
the 8KB checker script, and perform the actual strength
checking on a password 16-characters in length.
%
%
In Firefox the average (over 10 runs) amount of time it takes to
perform the strength checking is \Red{59.5ms}.
%
This figure, though predominantly dominated by network delay, is
roughly \Red{3\%} faster than the strength checker running running in a
``normal'' worker on a vanilla, unmodified, browser (which
also caches the worker script).
%
We attribute our speedup to the fact that creating and communicating
with labeled workers is faster than existing workers (see
micro-benchmarks, below).
%
\Red{In Chrome....}


\paragraph{Encrypted document editor}
%% Vanilla: removed the sandbox stuff.
%% Firefox: With \sys{} it take 114.8, Vanilla: 100.2
%% Chome: With \sys{} it take 248.1, Vanilla; 257.8

We implemented a simple document editor as described in
Section~\ref{sec:apps}.
%
Our benchmark measures the end-to-end time it takes to load the
application, and ``encrypt'' a new 4KB document using
the \Red{SJCL AES-128 library~\cite{sjcl}}.
%
We measured the \sys{} application to take \Red{114.8ms} on the modified
version of Firefox; the simplified, insecure version of the app,
running on vanilla Firefox took \Red{100ms}.
%
We note that our figure accounts for the amount of time it takes to
load the document editor page, which itself loads the encryption layer
as an iframe, which further loads the actual editor.
%
We attribute the (small) 14.8ms slowdown to both the label checks
performed by \sys{} and security layer added on top of the insecurity
application---in the vanilla case, we removed the label operations and
authentication layer (used to ensure that the label of the innermost
iframe is sufficiently high).
%
\Red{Similarly, in Chromium...}


\paragraph{Third-party mashup}
%% Firefox: With \sys{} it take 10.7ms, Vanilla:  10.7ms
%% Chrome: With \sys{} it take 15ms, Vanilla:  17ms
%% 
%% Vanilla: just remove sandbox stuff + add CORS

We implemented a very simple third-party mashup application in which
the integrator makes an XHR request to two unaffiliated origins, each
of which produces a response containing a (\Red{27 byte}) JSON Blob
object with a numerical property.
%
The integrator parses the responses into JSON objects, adds the
numbers, and appends a \js|div| element, containing the sum, to the
document body.
%
The corresponding vanilla application is identical, but uses the
normal XHR object; in this case, the unaffiliated origins set CORS
headers that permit responses to be inspected by any origin.
%
In Firefox, we measured the latency of the application to be
\Red{10.7ms in both cases}.
%
Of course, the \sys{} application has the advantage of treating the
received content as sensitive (and thus required setting proper CSP
and iframe sandbox flags) when compared to the CORS-based approach
that would allow the integrator to arbitrarily leak the sum.

\paragraph{Untrusted third-party libray}
%% Vanilla: incorporate script directly, no sandboxes.
%% As page confine:
%% Firefox: With \sys{} it take 164.8ms, Vanilla:  160.2ms
%% As extension
%% Firefox: With \sys{} it take 224.4ms

We measure the load time of a banking app that incorporates jQuery and
a library that traverses the DOM to replace phone numbers with links.
%
The latter library uses XHR in attempt to leak the page content.
%
The bank page is compartmentalized into a public outer component and
a sensitive iframe containing the user's statement;
in both compartments, the bank trusted code (which load the libraries)
is placed in a labeled DOM worker, with access to the page document
and privilege, treating the rest of the code as untrusted.
%
We measured the total load time of the page.
%
In Firefox, the load time was \Red{164.8ms}, \Red{4.6ms} longer than
an insecure version of the application running on vanilla Firefox.
%
We remark that this slowdown is negligible considering that the
application contains mixed-sensitivity content (the main banking page
is public, while the bank statement iframe is labeled with the origin
of the page), which \sys{} prevents from being leaked; in the vanilla
case, the untrusted library trivially leaks the bank statement with
XHR.

%% Vanilla: incorporate script directly, no sandboxes.
%% 
%% As page confine:
%% Firefox: With \sys{} it take 164.8ms, Vanilla:  160.2ms
%% 
%% As extension
%% Firefox: With \sys{} it take 224.4ms

\subsection{Micro benchmarks}
\label{sec:eval:micro}

\newcommand*\rot{\rotatebox{90}}

\begin{table}
\centering
\resizebox{1.0\columnwidth}{!}{
\begin{tabular}{l |c|c|c|c|c|c }
\toprule
                   & \multicolumn{3}{c}{\textbf{Firefox}}
                   & \multicolumn{3}{c}{\textbf{Chromium}} \\
                   & \rot{vanilla}   &
                     \rot{unlabeled} &
                     \rot{labeled}   &
                     \rot{vanilla}   &
                     \rot{unlabeled} &
                     \rot{labeled}   
\\\midrule%--------------------------------------------------------------------
% cost of creating an iframe                                         
New iframe         & 14.4    &  14.5    &  14.4   &   50.63 &   48.73 & 51.77  %% avg of 10 runs
\\\hline%----------------------------------------------------------------------
% cost of creating a worker                                          
New worker         & 15.9    &  15.4   &   0.9   &  18.94  &  18.87  & 3.27  %% avg of 10 runs
\\\midrule%--------------------------------------------------------------------
% cost of labeled postMessage                                        
Iframe comm.       &  0.11   &  0.11   &   0.12  &  0.042  &  0.042  & 0.042 %% avg # messages/10seconds
\\\hline%----------------------------------------------------------------------
% cost of performing XHR                                             
XHR comm           &  3.59   &   3.62   &  3.72   &  7.0    &  7.4    & 7.2 %1000request in 10 iframes
\\\hline%----------------------------------------------------------------------
% cost of worker ping-pong                                           
Worker comm.       &  0.2    &   0.24  &  0.033  &  0.071  &  0.070  & 0.030 % 90 messages ping-pong
\\\midrule%--------------------------------------------------------------------
% cost of setting current label                                      
Set label          &  --     &  \multicolumn{2}{c|}{0.0016} &   --   
                             &  \multicolumn{2}{c }{0.0018}
%10 iframes doing 10,000 ops
\\\hline%-------------------------------------------------------------------------------------------------
% cost of setting current label                                                                   
Get label          &  --     &  \multicolumn{2}{c|}{0.0001} &   --   
                             &  \multicolumn{2}{c }{0.0008}
\\\hline%-------------------------------------------------------------------------------------------------
% cost of comparing labels                                                                        
Label check        &  --     &  \multicolumn{2}{c|}{0.0011} &   --   
                             &  \multicolumn{2}{c }{0.0004}
%10 iframes doing 10,000 subsumes of random labels with 4 principals
\\\bottomrule
\end{tabular}
}
\caption{Micro-benchmarks, in milliseconds (ms).}
\label{microbench} 
\end{table}

Table~\ref{microbench} shows our micro-benchmarks for the stock
browsers (vanilla), our modified browsers with confinement-mode turned
off (unlabeled), and confinement-mode enabled (labeled).
%
We measure the cost of creating various compartments (workers and
iframes), sending messages between various end-points
(compartments and servers), and common label operations.

The performance impact of creating an iframe or worker is within
\Red{3.5\% and 2.5\%} of the vanilla implementations on Firefox and
Chromium, respectively.
%
In absolute terms, \sys{} adds, on average, less than \Red{1ms} latency.
%
As also shown in the table, the \sys{} light-weight labeled workers
provide programmers with a lighter weight concurrency primitive:
creating a labeled worker is roughly \Red{12 and 6 times} faster than
a corresponding unlabeled ``normal'' worker; creating and
communicating with a regular worker with confinement-mode (labeled
case) does not incur a noticeable difference to the unlabeled case.

%
The iframe, worker and XHR communication measurements evaluate the cost of
sending and receiving a message (\js|PING| and \js|PONG|,
respectively) across iframes, workers, and the network.
%
In all cases, the performance impact of \sys{} is negligible when
compared to an unmodified, vanilla browser.
%
In the case of XHR, the performance impact on the
(local-network test) is less than \Red{5.5\% for both Firefox and Chromium,
a less than 0.5ms delay.}
%
In most of the other cases the sub \Red{0.1ms} differences can be
attributed to noise.
%
For Firefox, we also measured the performance of using a
\verb|"labeled-blob"| response type with just \verb|"blob"| to be
\Red{XX\% slower}; this however, is on par with setting a CORS header
for the vanilla case (\Red{XXX\% slower/faster}).
%
(Our Chromium implementation does not yet have support for XHR with
labeled blobs; instead labeled workers are used to wrap the XHR
constructor, so the cost using labeled XHR requires an additional
cross-compartment call.)
%
The only other interesting case is that of communication with
light-weight labeled workers; as with creating labeled workers,
communication with a labeled workers is roughly \Red{2 times} faster
than a corresponding vanilla worker.

\Red{
 DOM in chrome
 DOM in worker
}

Finally, getting the current label, setting the current label and
performing a label comparison (subsumes) are all on the order of a
microsecond.
%
These measurements, as in the case of sending labeled messages, use
a single label: the public label.
%
Hence, when considering more complex labels, we expect the performance
impact of labels to naturally be higher.
%
For a random label comparison, with at most 5 principals, we
measured a 5\% performance degradation.
%
This measurement serves as a reasonable point for real application,
which are likely to only contain a handful of principals.
%
While label checks are cheap for end-to-end application performance,
there is much room for speeding up label comparisons---our label
implementation has not yet been optimized.

%%Comparing the 
%%Similarly, the performance impact of labels is under  5\%  in almost
%%every case.

