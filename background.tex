\section{Background}
\label{sec:background}

%% In this section, we briefly review the browser architecture and
%% security model.
%
As shown in Figure~\toref{fig:browser-arch}, a web page is composed of
content and JavaScript code.
%
The browser provides an environment, called the \emph{browsing
context}, within which the page's content is presented to the user and
made accessible to JavaScript through the \emph{Document Object Model
(DOM)}~\tocite{html5}.
%
Within this context, the content/code may create and interact with
nested browsing contexts (e.g., iframes), use persistent storage
(e.g., cookies) or perform network requests (either implicitly through
content loading or explicitly, in JavaScript, using the \xhr{} (XHR)
constructor).
%
Since different components may be provided by different authors, it is
important that these complex interactions abide by a security policy.
 
Policies are expressed in terms of \emph{origins}; an origin is a
source of authority encoded by the protocol (e.g., \js|http|), domain
name (e.g., \js|fb.com|), and port (e.g., \js|443|) of a resource
URL.\footnote{
  For brevity, we do not write the port of an origin, when it is the
  default port for a particular protocol (e.g., \js|80| for \js|http|
  and \js|443| for \js|https|).
}
%
(We sometimes use the term \emph{principal} interchangeably.)
%
Below we briefly review the core browser security policies, including
the \emph{same-origin policy (SOP)}~\tocite{}, \emph{content security
policy (CSP)}~\tocite{}, and \emph{cross-origin resource origin
(CORS)} policy~\tocite{}.
%
%
We note that our review is not exhaustive (e.g., we not discuss the
the \js|X-Frame-Options| header, which prevents loading a page in a
nested browsing context, etc.);  the interested reader is referred
to~\tocite{} for a more complete discussion on web security.



\subsection{Same-origin Policy}
\label{sec:background:sop}

The SOP specifies that resources of an origin should only be readable
by content from the same origin~\tocite{rfc6454, VanKesteren2012,
googlehandbook}.
%
Hence, browsers ensure that code executing in a \https{a.com} context
can only inspect the DOM and cookies of another context if they share
the same origin.
%
Similarly, the code can only inspect the response of a network
request---performed with XHR---if the remote host's origin is
\https{a.com}.
%
In general, the SOP isolates code in one page from accessing client-
and server-side data associated with another origin.
 
The SOP does, not however, prevent code from disclosing data to other
origins.
%
For example, code executing in an \https{a.com} context can trivially
disclose data to \https{b.com} by using XHR to perform a network
request to \https{b.com}; the SOP only prevents the code from
inspecting the response of such XHR requests, it does not impose any
sending the request.
%
Similarly, code can exfiltrate data by encoding it in the path of a
URL, whose origin is \https{b.com}, and setting the \js|src| property
of (among other) an \js|img| element to this URL.

This ability to embed content from an arbitrary origin can also be
used to communicate data back into the page and ``bypass'' SOP's goal
of disallowing cross-origin reads.
%
This is possible because most content is not completely opaque. 
%
For example, images can encode data in properties such as width and
height (which are always readable), scripts can encode data in their
execution path (as done by JSON-P~\tocite{jsonp}), etc.
%

The popularization of such ad-hoc cross-origin communication methods,
(notably, those relying on \js|window.name| and
\js|window.location|~\tocite{thidpartyjs}), has lead to the
introduction of the HTML5 \js|postMessage| API~\tocite{webmessaging}.
%
This API allows code from different browsing contexts to exchange
messages, as shown in Figure~\toref{fig:browser-arch}.
%
Given a DOM window object \js|obj| with a foreign-origin, the
\js|postMessage| method can be invoked on it to send the
foreign-origin a message: \js|obj.postMessage(message, destOrigin)|.
%
Since pages can navigate, a second argument \js|destOrigin| is used to
specify the intended origin of the message as to prevent
man-in-the-middle attacks attacks~\tocite{barthspaper}.
%
Unfortunately, once the sender sends the foreign-origin a message, it
has no control over what the origin can do with the data.
%
Hence, sending sensitive data using \js|postMessage| should only be
done if the foreign-origin is trusted;
%
in Section~\ref{sec:system:iframe}, we describe how \sys{} precisely
allows code to impose restrictions on where the foreign-origin can
disseminate data received via \js|postMessage|, removing this need for
complete trust.

\subsection{Content Security Policy} 
\label{sec:background:csp}

Addressing cross-site scripting (XSS) attacks~\tocite{xss},
CSP~\tocite{Sterne2012} provides developers with a means for
white-listing the origins from which their application is allowed to
load resources.
%
Specifically, when first loading a page the
\js|Content-Security-Policy| header is inspected for directives that
instructs the browser to restrict the browsing context from loading
specific resources according to the provided white-list.
%
For instance, if the CSP header of a page from \https{a.com} contains
the following three directives:
%
\texttt{default-src: 'self'; img-src: 'none'; connect-src:
https://b.com},
%
the page content and code is restricted as follows.
%
First, loading resources---for which a more specific directive is not
provided (e.g., scripts, stylesheets, etc.)---is limited to the same
origin.
%
Second, the context is prohibited from loading any images.
%
And, third, JavaScript code is restricted to making XHR requests to
\https{b.com}.

Although the CSP specification simply states that attempts to load
resources from origins outside the white-list should behave as if the
remote server responded with a failure (HTTP 400) response, most
browsers do not actually perform requests in such cases.
%
Hence, in addition to addressing XSS attacks, in practice, CSP can
be used to restrict the origins to whom data can be exfiltrated by
code executing in the browsing context---a drastic improvement over
the SOP!
%
Unfortunately, this only gives developers the choices of trusting code
with communicating with an origin in full or not at all;
%
in Section~\ref{sec:system:worker} we show how \sys{} overcomes this
shortcoming of CSP to allow code to communicate with an origin until
it has read sensitive data (and thus no longer trusted).


\subsection{Cross-origin Resource Sharing} 
\label{sec:background:cors}

While CSP tightens down the SOP by restricting reads and writes, CORS
loosens the restrictions imposed by SOP~\cite{VanKesteren2012}.
%
Specifically, CORS allows web servers to specify, using a header that
white-lists origins, which browsing contexts are allowed to inspect
the content of a resource.
%
Suppose, for instance, that code executing in an \https{a.com} browsing
context makes an XHR request to \https{b.com}.
%
If the response contains the CORS header
\texttt{Access-Control-Allow-Origin: https://a.com}, the browser will
not restrict the JavaScript code from reading the actual response
content.

CORS addresses the limitations of SOP in allowing cross-origin
sharing, and overcomes the need for ad-hoc sharing methods such as
JSON-P.
%
However, CORS, like CSP, requires resource providers to a-prior
declare an all-or-nothing trust relationship.
%
Though this is sufficient for certain scenarios (e.g., making a
resource public, or sharing content between origins owned by a single
entity) in many cases this is overly restricting;
%
in Section~\ref{sec:system:mashup} we show how \sys{} overcomes this
shortcoming by allowing code to read arbitrary cross-origin
data in a safe and controlled manner.


\subsection{Lattice-based security}

%% The idea of principals
\paragraph{Principals and labels}

\sys~ consider principals as the origins\footnote{consisting of triples of the
  form \js|{protocol, host, port}|} responsible for providing web
content. Principals are usually identified by URLs, e.g., 
\js|http://maps.google.com:80/| denotes a well-known map provider.
Conceptually, \sys~ describes security policies by associating labels to every
piece of data. Labels express restrictions on information propagation according
to the interests of multiple principals (i.e. origins). Among different
information-flow label systems~\cite{GenLabels}, we adopt the use of disjunction
category (DC) labels~\cite{stefan:2011:dclabels} due to its simple and clear
semantics.

For a web scenario setting, we conceive DC labels as the conjunctive normal form
of origins. Logical conjunction expresses concomitant of concerns. For instance,
data labeled as \js|Label("https://bank.ch").and("https://amazon.com")|
indicates that it might contain sensitive information from both origins;
therefore it should not be propagated to less sensitive entities, e.g.,
\js|Label("https://amazon.com")|---otherwise, some bank data could be leaked
into \js|amazon.com|. Additionally, DC labels support egalitarian access to data
through disjunctions, e.g., data labeled as 
\js|Label("https://amazon.com").or("https://bank.ch")| can be
observed by any of the mentioned origins. 

More formally, and based on logic implication, DC labels can be ordered by their
degree of sensitivity in order to form a lattice. Considering confidentiality
(integrity proceeds in a dual manner), $l_1$ is less or equally sensitive than
$l_2$, written $l_1 \sqsubseteq l_2$, iff $l_2 \Rightarrow l_1$ when
interpreting origins as boolean variables. To support a notion of 
declassification, DC labels relax the order relationship $\sqsubseteq$ based
on code's privileges.  


\sys~ support privileges in the form of unforgeable objects denoting
origins. These objects are used to assert the authority of principals.  Any
script running with a privilege denoting, for instance, \js|https://amazon.com|
is treated like coming from that origin even if it did not.  Conceptually
speaking, privileges have the same shape as labels, i.e., conjunctive normal
form of origins.  Based on the privileges in scope, scripts are capable to
restrictively declassify sensitive information.  As an example, a piece of code
running with a privilege denoting \js|"https://amazon.com"| can relabel a piece
of data with \js|Label("https://bank.ch").and("https://amazon.com")| to
\js|Label("https://bank.ch")|; and thus effectively downgrading information to
the bank. Formally, exercising privileges is captured by a more permissive
pre-order relationship $\sqsubseteq_p$, where $l_1 \sqsubseteq_p l_2$ holds
provided that $l_2 \land p \Rightarrow l_1$. Observe how the privileges are used
on the hypothesis of the implication. Intuitively, label $l_2$ does not require to
include the origins in $p$ in order to make the implication hold, i.e., 
$l_2$ could be formed by removing some origins appearing in both $p$ and $l_1$.
 
The API for handling labels and privileges are described in
Table~\ref{systemAPI}. Constructor \js|Label| create labels based on strings
given as arguments. The purpose of properties \js|and| and \js|or| 
were exemplified before in this section.  Property \js|subsumes| checks if a
label subsumes the one given as argument. When no second argument is
given, \js|l2.subsumes(l1)| tests if \js|l1| $\sqsubseteq$
\js|l2|. Alternatively, privileges are taken into account and
\js|l2.subsumes(l1,p)| tests if \js|l1| $\sqsubseteq_{\mbox{\js|p|}}$ \js|l2|.
The API for privileges deserves further explanation.

%\Red{Why both? Privilege and FreshPrivilege. Isn't privilege internal only?}
\sys~ allows the safe creation of privileges by the constructor
\js|FreshPrivilege|. Freshly created privileges cannot denote
origins---otherwise, any piece of code could run on behalf of any origin.
Nevertheless, these privileges enable web pages to organize their code using the
\emph{least-privilege discipline}: computations may be compartmentalized into
sub-computations, with the privileges of the computation subdivided so that each
sub-computation runs with least privilege. Property \js|combine| creates
potentially stronger privileges based on existing ones. The code 
\js|p1.combine(p2)| creates a privilege denoting $\mbox{\js|p1|} \land
\mbox{\js|p2|}$.  Dually, property \js|mint| create weaker privileges. Given a
label \js|l|, the code \js|p.mint(l)| creates a privilege denoting \js|l| provided that
$\mbox{\js|l|} \sqsubseteq \mbox{\js|p|}$. Minting privileges is particularly
useful for implementing some notions of delegation~\cite{stefan:2011:dclabels}.  By convention,
\sys~ threats \js|null| as the weakest privilege, i.e., no privileges. Finally,
property \js|asLabel| exposes the label that a privilege denotes. 








% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-default: "Make"
% End:

