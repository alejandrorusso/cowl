\section{Background}
\label{sec:background}

%% In this section, we briefly review the browser architecture and
%% security model.
%
As shown in Figure~\toref{fig:browser-arch}, a web page is composed of
content and JavaScript code.
%
The browser provides an environment, called the \emph{browsing
context}, within which the page's content is presented to the user and
made accessible to JavaScript through the \emph{Document Object Model
(DOM)}~\tocite{html5}.
%
Within this context, the content/code may create and interact with
nested browsing contexts (e.g., iframes), use persistent storage
(e.g., cookies) or perform network requests (either implicitly through
content loading or explicitly, in JavaScript, using the \xhr{} (XHR)
constructor).
%
Since different components may be provided by different authors, it is
important that these complex interactions abide by a security policy.
 
Policies are expressed in terms of \emph{origins}; an origin is a
source of authority encoded by the protocol (e.g., \js|http|), domain
name (e.g., \js|fb.com|), and port (e.g., \js|443|) of a resource
URL.\footnote{
  For brevity, we do not write the port of an origin, when it is the
  default port for a particular protocol (e.g., \js|80| for \js|http|
  and \js|443| for \js|https|).
}
%
(We sometimes use the term \emph{principal} interchangeably.)
%
Below we briefly review the core browser security policies, including
the \emph{same-origin policy (SOP)}~\tocite{}, \emph{content security
policy (CSP)}~\tocite{}, and \emph{cross-origin resource origin
(CORS)} policy~\tocite{}.
%
%
We note that our review is not exhaustive (e.g., we not discuss the
the \js|X-Frame-Options| header, which prevents loading a page in a
nested browsing context, etc.);  the interested reader is referred
to~\tocite{} for a more complete discussion on web security.



\subsection{Same-origin Policy}
\label{sec:background:sop}

The SOP specifies that resources of an origin should only be readable
by content from the same origin~\tocite{rfc6454, VanKesteren2012,
googlehandbook}.
%
Hence, browsers ensure that code executing in a \https{a.com} context
can only inspect the DOM and cookies of another context if they share
the same origin.
%
Similarly, the code can only inspect the response of a network
request---performed with XHR---if the remote host's origin is
\https{a.com}.
%
In general, the SOP isolates code in one page from accessing client-
and server-side data associated with another origin.
 
The SOP does, not however, prevent code from disclosing data to other
origins.
%
For example, code executing in an \https{a.com} context can trivially
disclose data to \https{b.com} by using XHR to perform a network
request to \https{b.com}; the SOP only prevents the code from
inspecting the response of such XHR requests, it does not impose any
sending the request.
%
Similarly, code can exfiltrate data by encoding it in the path of a
URL, whose origin is \https{b.com}, and setting the \js|src| property
of (among other) an \js|img| element to this URL.

This ability to embed content from an arbitrary origin can also be
used to communicate data back into the page and ``bypass'' SOP's goal
of disallowing cross-origin reads.
%
This is possible because most content is not completely opaque. 
%
For example, images can encode data in properties such as width and
height (which are always readable), scripts can encode data in their
execution path (as done by JSON-P~\tocite{jsonp}), etc.
%

The popularization of such ad-hoc cross-origin communication methods,
(notably, those relying on \js|window.name| and
\js|window.location|~\tocite{thidpartyjs}), has lead to the
introduction of the HTML5 \js|postMessage| API~\tocite{webmessaging}.
%
This API allows code from different browsing contexts to exchange
messages, as shown in Figure~\toref{fig:browser-arch}.
%
Given a DOM window object \js|obj| with a foreign-origin, the
\js|postMessage| method can be invoked on it to send the
foreign-origin a message: \js|obj.postMessage(message, destOrigin)|.
%
Since pages can navigate, a second argument \js|destOrigin| is used to
specify the intended origin of the message as to prevent
man-in-the-middle attacks attacks~\tocite{barthspaper}.
%
Unfortunately, once the sender sends the foreign-origin a message, it
has no control over what the origin can do with the data.
%
Hence, sending sensitive data using \js|postMessage| should only be
done if the foreign-origin is trusted;
%
in Section~\ref{sec:system:iframe}, we describe how \sys{} precisely
allows code to impose restrictions on where the foreign-origin can
disseminate data received via \js|postMessage|, removing this need for
complete trust.

\subsection{Content Security Policy} 
\label{sec:background:csp}

Content security policy  (CSP) \tocite{} helps to significantly reduce
the risk (neglected by SOP) of freely handling URLs. CSP essentially describes
a, on a page-by-page basis, which the origins from where different resources
(scripts, images, etc.) may be safely loaded, i.e., it works as a simple
white-list policy.  Web pages rely on server-support to insert CSP headers in
\js|XMLHttpRequest|s responses. For instance, a page hosted in \js|a.com| 
which supplies the CSP header with the directives 
%
\js|default-src: ’self’; img-src: b.com| 
%
restricts the page to load images from \js|a.com| and \js|b.com|.



\subsection{Cross-origin resource sharing } 
\label{sec:background:cors}


There are situations where it is desirable from scripts at different domains to
communicate. With this in mind, cross-origin resource sharing (CORS) relaxes SOP
by implementing a new browser-server protocol through HTTP headers.  Such
headers specify from which domains scripts are allowed to fetch data 
using \js|XMLHttpRequest|s. Moreover, in the browser, scripts loaded from
those cross-origins have unrestricted access to each other's DOM
trees. Unfortunately, any technique to subvert SOP works equally well with CORS 
(e.g. fragmented-id, postMessages, etc.).


\subsection{Lattice-based security}

%% The idea of principals
\paragraph{Principals and labels}

\sys~ consider principals as the origins\footnote{consisting of triples of the
  form \js|{protocol, host, port}|} responsible for providing web
content. Principals are usually identified by URLs, e.g., 
\js|http://maps.google.com:80/| denotes a well-known map provider.
Conceptually, \sys~ describes security policies by associating labels to every
piece of data. Labels express restrictions on information propagation according
to the interests of multiple principals (i.e. origins). Among different
information-flow label systems~\cite{GenLabels}, we adopt the use of disjunction
category (DC) labels~\cite{stefan:2011:dclabels} due to its simple and clear
semantics.

For a web scenario setting, we conceive DC labels as the conjunctive normal form
of origins. Logical conjunction expresses concomitant of concerns. For instance,
data labeled as \js|Label("https://bank.ch").and("https://amazon.com")|
indicates that it might contain sensitive information from both origins;
therefore it should not be propagated to less sensitive entities, e.g.,
\js|Label("https://amazon.com")|---otherwise, some bank data could be leaked
into \js|amazon.com|. Additionally, DC labels support egalitarian access to data
through disjunctions, e.g., data labeled as 
\js|Label("https://amazon.com").or("https://bank.ch")| can be
observed by any of the mentioned origins. 

More formally, and based on logic implication, DC labels can be ordered by their
degree of sensitivity in order to form a lattice. Considering confidentiality
(integrity proceeds in a dual manner), $l_1$ is less or equally sensitive than
$l_2$, written $l_1 \sqsubseteq l_2$, iff $l_2 \Rightarrow l_1$ when
interpreting origins as boolean variables. To support a notion of 
declassification, DC labels relax the order relationship $\sqsubseteq$ based
on code's privileges.  


\sys~ support privileges in the form of unforgeable objects denoting
origins. These objects are used to assert the authority of principals.  Any
script running with a privilege denoting, for instance, \js|https://amazon.com|
is treated like coming from that origin even if it did not.  Conceptually
speaking, privileges have the same shape as labels, i.e., conjunctive normal
form of origins.  Based on the privileges in scope, scripts are capable to
restrictively declassify sensitive information.  As an example, a piece of code
running with a privilege denoting \js|"https://amazon.com"| can relabel a piece
of data with \js|Label("https://bank.ch").and("https://amazon.com")| to
\js|Label("https://bank.ch")|; and thus effectively downgrading information to
the bank. Formally, exercising privileges is captured by a more permissive
pre-order relationship $\sqsubseteq_p$, where $l_1 \sqsubseteq_p l_2$ holds
provided that $l_2 \land p \Rightarrow l_1$. Observe how the privileges are used
on the hypothesis of the implication. Intuitively, label $l_2$ does not require to
include the origins in $p$ in order to make the implication hold, i.e., 
$l_2$ could be formed by removing some origins appearing in both $p$ and $l_1$.
 
The API for handling labels and privileges are described in
Table~\ref{systemAPI}. Constructor \js|Label| create labels based on strings
given as arguments. The purpose of properties \js|and| and \js|or| 
were exemplified before in this section.  Property \js|subsumes| checks if a
label subsumes the one given as argument. When no second argument is
given, \js|l2.subsumes(l1)| tests if \js|l1| $\sqsubseteq$
\js|l2|. Alternatively, privileges are taken into account and
\js|l2.subsumes(l1,p)| tests if \js|l1| $\sqsubseteq_{\mbox{\js|p|}}$ \js|l2|.
The API for privileges deserves further explanation.

%\Red{Why both? Privilege and FreshPrivilege. Isn't privilege internal only?}
\sys~ allows the safe creation of privileges by the constructor
\js|FreshPrivilege|. Freshly created privileges cannot denote
origins---otherwise, any piece of code could run on behalf of any origin.
Nevertheless, these privileges enable web pages to organize their code using the
\emph{least-privilege discipline}: computations may be compartmentalized into
sub-computations, with the privileges of the computation subdivided so that each
sub-computation runs with least privilege. Property \js|combine| creates
potentially stronger privileges based on existing ones. The code 
\js|p1.combine(p2)| creates a privilege denoting $\mbox{\js|p1|} \land
\mbox{\js|p2|}$.  Dually, property \js|mint| create weaker privileges. Given a
label \js|l|, the code \js|p.mint(l)| creates a privilege denoting \js|l| provided that
$\mbox{\js|l|} \sqsubseteq \mbox{\js|p|}$. Minting privileges is particularly
useful for implementing some notions of delegation~\cite{stefan:2011:dclabels}.  By convention,
\sys~ threats \js|null| as the weakest privilege, i.e., no privileges. Finally,
property \js|asLabel| exposes the label that a privilege denotes. 








% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-default: "Make"
% End:

