We thank the reviewers for their helpful comments.  We've structured the
rebuttal into two parts: the (short) first section addresses some
high-level questions, and the second section addresses some factual
questions about the paper.

## High-level questions

B, D, E: What does COWL give up by taking a coarse-grained approach?

  We touch on some of the trade-offs of coarse-grained vs. fine-grained
  IFC in the related work section, although the discussion is focused on
  specific prior systems. Generally speaking, coarse-grained IFC
  requires developers to give some thought to how to compartmentalize
  a system to achieve desired security properties. Fine-grained IFC can require
  less programmer effort: we imagine that our jQuery example would be
  more natural in a fine-grained IFC system.

  Both approaches are not mutually exclusive. One could imagine using
  fine-grained IFC (e.g., JSFlow) within a compartment

D: How general is the label system?

  As described in Section 3.1, we use the logic-based DCLabels of
  [28], which have been proved in [20] to be as expressive as the
  Decentralized Label Model.  In the literature, there are more
  expressive logics (e.g., first order logic) that can allow for
  richer policies than those permitted by DCLabels, and in principle,
  one could swap one of these in. However, DCLabels have the singular
  advantage of reflecting existing web policies very closely: to
  support a more expressive logic, one would have to reimplement
  suitably generalized checks in the browser rather than reusing
  existing mechanisms.

B: The tainted component does not need communication ... is that
what's required of applications to be secured by COWL?

  A compartment cannot communicate after getting tainted unless it
  has (or receives) the privilege to downgrade/declassify its label,
  as described in Section 3.2. Moreover, if an application must
  communicate after reading sensitive data it can do so by (a priori)
  creating multiple compartments (e.g., one to that always
  communicates with the network and the other for inspecting
  sensitive data).

A: Will mashups with many libraries impose a requirement on developers
to understand overly complex policies?

  We acknowledge that programming with COWL definitely requires
  understanding COWL's primitives. However, our experience to date is
  that a relatively small set of canonical design patterns captures
  many common web application (and mashup) behaviors.  We leave the
  investigation of more case studies to future work.

## Factual questions

B, D, E: What about integrity?

  Each label contains an integrity component; the design of
  integrity is complete and implemented, but was given short shrift
  in the submission for reasons of brevity.  As suggested, we intend
  to expand on this. 

E: SOP "provides some degree of integrity" for DOM changes, what about COWL?

  In Section 3.2, we mention that a privilege is required to modify
  the DOM (which has an integrity label corresponding to the origin),
  and privileges are granted in the same manner as under the SOP.

E: Is your vision to co-exist with or replace all existing security mechanisms?

  COWL is explicitly designed to allow an incremental deployment
  path.  While prior work (e.g., [40]) discusses how a label system
  can subsume the policies that can be implemented with today's SOP,
  CSP, CORS, etc., COWL co-exists with these mechanisms, offering MAC
  to pages which opt-in to this new functionality (summarized in
  Section 3).

E: How do you address taint accumulation?

  In the case of compartments, the answer is two-fold.  First,
  compartments in browsing contexts are relatively short-lived, since
  users navigate among pages. Second, the ability to create compartments
  means operations which raise labels can be isolated in separate
  compartments. Good application design can avoid accumulation of
  taint.

  In the case of files, there is a simple design principle (seen in
  prior systems like HiStar [42] and Hails/LIO [11]) to avoid
  taint accumulation: the label associated with a file is immutable,
  and writes which cannot flow to the label are rejected. (A recent
  CSF paper shows that such systems are as expressive as those
  that allow label mutation.)

A: What kind of objects can be labeled?

  Blobs, which can include serialized JavaScript values (e.g.,
  as seen in postMessage).

A, B: How do you disallow the manual setting of label XHR header?

  The XHR API has the option for users to add custom headers to the
  request, as long as they are not reserved headers; we modified the
  XHR constructor to treat this header as reserved.

B: What is the covert channel story for COWL?

  As mentioned in Section 3, COWL both restricts and relaxes the SOP.
  When the SOP is restricted--i.e., no labeled XHR was used--the
  question of covert channels is irrelevant,  since webpages do not
  have direct access to any more sensitive data than they would have
  had access to already. This is the case for 3/4 example applications.

  Labeled XHR allows access to sensitive data that would not be
  accessible under the SOP, so covert channels are a definite concern
  here.  In Section 3.3, we discuss how clearance can be used to
  restrict the sensitivity of data that can be read (and thus leaked
  via covert channels), allowing access only to data a compartment
  "needs to know." As also mentioned, to achieve the functionality of
  third-party mashup sites, the status quo requires the user to give
  up their password; COWL significantly improves this state of
  affairs.

B: Does the sharing of heap space for LWorkers introduce new covert channels?

  Our implementation of LWorkers repurposes V8 and SpiderMonkey's
  contexts and compartments, respectively. These primitives are already
  used to isolate iframes of different origins to ensure that they
  operate on disjoint sub-heaps. Hence, we believe the chance of
  unauthorized leakage of information between LWorkers is identical to
  that between iframes.

A, C: What is the label check done when accessing DOM of compartment?

  In a footnote in Section 3.2, we mention that an integrity check is
  involved in the label check for DOM modification.  Here are the
  details: suppose compartment A tries to modify the DOM of
  compartment B. With DClabels, this operation is allowed if
  compartment A's current integrity label implies the integrity label
  on the DOM.

  Ordinarily, this label check would fail, because the current
  integrity label of all compartments defaults to public (no integrity
  guarantees), but the integrity label of a DOM defaults to its
  origin.  However, if compartment A holds the privilege for
  B, the operation would be allowed, the privilege overriding
  the label check and endorsing a cross-compartment DOM write.
  The mechanism by which this occurs is dual to declassification,
  described in Section 3.2.

D: What do you mean by ambient authority?

  Under the SOP, the notion of origin is always implicit: a page is
  loaded from a URL, and that compartment is forever associated with
  that exact origin. By "ambient authority" we mean the origin is
  implicit in the page. By contrast, under COWL, a compartment has
  explicit control over its label (and privilege).

C: Why are iframe and worker creation in Firefox faster for the labeled case?

  We believe this difference (14.5 ms unlabeled, 14.4 ms labeled)
  simply reflects these operations' distributions of running times.

C: Why do you exhaust the call stack and is this limit set by the spec?

  LWorkers run in the same context as the parent that spawns them,
  so messaging is actually a function call which runs to completion.
  The stack limit depends on the underlying JavaScript
  engine implementation and is not specified in the specification.

C: Why did you use a "simplified version" of the encrypted document editor?

  It was unclear how to securely reimplement the application without
  COWL, so we decided to err on the side of an unduly harsh baseline by
  implementing a baseline version with no privacy guarantees, which one would
  expect to run faster (it uses no cryptographic operations).

D:  Why is CSP too restrictive for the password checker example when
it can be used to whitelist origins?

  There are actually two CSP policies one might consider. A CSP
  policy which permits no origins is too restrictive because we can
  never download the password regex database. However, a CSP policy
  which permits access to the database is too *permissive*.  Once you
  grant access to an origin, that access persists for the entire page,
  even after the password checker has received the password; it could
  just send the password to the remote origin.

D: Underlines, colors, bubbles?

  An underlined origin indicates that a compartment holds the
  privilege for that origin. We colored different origins differently
  for contrast. Spiked bubbles connote the raising of labels. We will
  address these and other suggested presentation issues.
