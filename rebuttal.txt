We thank the reviewers for their helpful comments. 

B, D, E: What does COWL give up by being coarse-grained?

  We touch on some of the trade-offs of coarse-grained vs.
  fine-grained IFC in the related work section, although focusing on
  specific systems. For some applications (e.g., using jQuery with
  trusted code and sensitive-data), fine-grained IFC systems (e.g.,
  JFlow) may require less programmer effort. Coarse-grained IFC
  systems typically require developers to think about
  compartmentalization.  However, the approaches are not mutually
  exclusive: one could imagine using JSFlow within a COWL compartment.

D: How general is the label system?

  As described in Section 3.1, we use DCLabels [28], which are as
  expressive as Myers and Liskov's DLM [20]. There are more expressive
  logics (e.g., first order logic) that allow for richer policies, and
  in principle, could be used in place of DCLabels.  However, DCLabels
  have the singular advantage of reflecting existing web policies very
  closely, allowing COWL to reuse existing mechanisms to enforce IFC.

B: Is "no communication after tainting" what is required of applications?

  If an application must communicate after reading sensitive data, it
  can do so by (a priori) creating multiple compartments (e.g., one to
  that always communicates with the network and the other for
  inspecting sensitive data).  Moreover, a compartment can communicate
  after reading sensitive data if has (or receives) the privilege to
  downgrade its label (described in Section 3.2).

B, D, E: What about integrity?

  Each label contains an integrity component; the design of integrity
  is complete and implemented, but was given short shrift for reasons
  of brevity. We will expand on this. 

E: SOP "provides some degree of integrity" for DOM mutation, what about COWL?

  In COWL, a privilege is required to modify the DOM (which has an
  integrity label corresponding to the origin), and privileges are
  granted in the same manner as SOP (describe in Section 3.2)

E: Is your vision to co-exist or replace all existing security mechanisms?

  COWL is explicitly designed for incremental deployment.  While [40]
  discusses how a label system can replace today's mechanisms (SOP,
  CSP, etc.), COWL co-exists with these mechanisms, offering MAC to
  pages which opt-in to this new functionality (summarized in Section 3).

E: How do you address taint accumulation?

  Compartments: First, compartments in browsing contexts are
  relatively short-lived (due to navigation).  Second, good
  application design can avoid over-tainting, by placing operations
  which raise the label can in separate compartments.

  Files: We explicitly disallow taint accumulation (as in HiStar [42]
  and Hails/LIO [11]) by treating labels of files as immutable.  While
  this disallows writing to a public file by a sensitive compartment,
  a recent CSF paper shows that such systems are as not any less
  expressive.

A: What kind of objects can be labeled?

  Blobs, which can include serialized JavaScript values.

A, B: How do you disallow the manual setting of the label XHR header?

  We modified the XHR constructor to treat this header as reserved,
  and ignore any user-provided label headers.

B: What is the covert channel story for COWL?

  As mentioned in Section 3, COWL both restricts and relaxes the SOP.
  When the SOP is restricted--i.e., no labeled XHR was used--the
  question of covert channels is irrelevant, since webpages do not
  have direct access to any more sensitive data than they would have
  had access to already. This is the case for 3/4 example applications.

  Labeled XHR allows access to sensitive data that would not be
  accessible under the SOP, so covert channels are a definite concern
  here.  In Section 3.3, we discuss how clearance can be used to
  restrict the sensitivity of data that can be read (and thus leaked
  via covert channels), allowing access only to data a compartment
  "needs to know." As also mentioned, to achieve the functionality of
  third-party mashup sites, the status quo requires the user to give
  up their password; COWL significantly improves this state of
  affairs.

D:  Why is CSP too restrictive for the password checker?

  There are two CSP policies to consider.
  - Permit no origins: too restrictive, cannot download the regex database.
  - White-list origin: too permissive, the access persists for the
    entire page, even after the password checker has received the
    password; it could just send the password to the remote origin.

B: Does the sharing of heap space for LWorkers introduce new covert channels?

  Our implementation of LWorkers repurposes V8 and SpiderMonkey's
  contexts and compartments, respectively. These primitives are already
  used to isolate iframes of different origins to ensure that they
  operate on disjoint sub-heaps. Hence, we believe the chance of
  unauthorized leakage of information between LWorkers is identical to
  that between iframes.

A, C: What is the label check done when accessing DOM of compartment?

  In a footnote in Section 3.2, we mention that an integrity check is
  involved in the label check for DOM modification.  Here are the
  details: suppose compartment A tries to modify the DOM of
  compartment B. With DClabels, this operation is allowed if
  compartment A's current integrity label implies the integrity label
  on the DOM.

  Ordinarily, this label check would fail, because the current
  integrity label of all compartments defaults to public (no integrity
  guarantees), but the integrity label of a DOM defaults to its
  origin.  However, if compartment A holds the privilege for
  B, the operation would be allowed, the privilege overriding
  the label check and endorsing a cross-compartment DOM write.
  The mechanism by which this occurs is dual to declassification,
  described in Section 3.2.

-------

C: Why are iframe and worker creation in Firefox faster for the labeled case?

  We believe this difference (14.5 ms unlabeled, 14.4 ms labeled)
  simply reflects these operations' distributions of running times.

C: Why do you exhaust the call stack and is this limit set by the spec?

  LWorkers run in the same context as the parent that spawns them,
  so messaging is actually a function call which runs to completion.
  The stack limit depends on the underlying JavaScript
  engine implementation and is not specified in the specification.

C: Why did you use a "simplified version" of the encrypted document editor?

  It was unclear how to securely reimplement the application without
  COWL, so we decided to err on the side of an unduly harsh baseline by
  implementing a baseline version with no privacy guarantees, which one would
  expect to run faster (it uses no cryptographic operations).




D: Underlines, colors, bubbles?

  An underlined origin indicates that a compartment holds the
  privilege for that origin. We colored different origins differently
  for contrast. Spiked bubbles connote the raising of labels. We will
  address these and other suggested presentation issues.

A: Will mashups with many libraries require the understanding of
overly complex policies?

  We acknowledge that programming with COWL definitely requires
  understanding COWL's primitives. However, our experience to date is
  that a relatively small set of canonical design patterns captures
  many common web application (and mashup) behaviors.  We leave the
  investigation of more case studies to future work.

D: What do you mean by ambient authority?

  Under the SOP, the notion of origin is always implicit: a page is
  loaded from a URL, and that compartment is forever associated with
  that exact origin. By "ambient authority" we mean the origin is
  implicit in the page. By contrast, under COWL, a compartment has
  explicit control over its label (and privilege).
