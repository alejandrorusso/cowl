## High-level questions

B, D, E: What does COWL give up by taking a coarse-grained approach?

  We touch on some of the trade-offs of coarse-grained vs.
  fine-grained IFC in the related work section, but agree that this
  discussion was directed at individual prior systems rather than
  drawing conclusions about these two broad approaches.
  Coarse-grained (compartment-granularity) IFC is much
  easier to implement than fine-grained (object-granularity) IFC;
  the former requires no changes to the JavaScript
  execution engine, whereas the latter requires extensive changes to
  propagate and check labels for every low-level JavaScript
  operation. The coarse-grained approach also incurs far less
  execution overhead: label-related processing occurs nearly
  exclusively upon inter-compartment communication, rather than at
  every step of a computation, in every compartment.

  We conjecture (but have not yet proven) that coarse-grained and
  fine-grained IFC are equally expressive, provided one can
  introduce arbitrary nesting of compartments.  Even if this
  equivalence holds in theory, in practice, it's unattractive for
  the programmer to need to introduce deep nesting of compartments
  to emulate fine-grained IFC (and presumably slower than
  fine-grained IFC, if you literally put compartments around every
  individual object).

  Fine-grained IFC can require less programmer effort in some cases.
  For example (as we briefly mention in the related work discussion
  of JSFlow), when trying to confine an untrusted jQuery library in
  the same page as the trusted application code and sensitive data,
  COWL requires the programmer to explicitly partition the page into
  a trusted and untrusted compartment. (This is somewhat reminiscent
  of least-privilege partitioning, in the style of OKWS and Wedge.)
  However, the fine-grained approach lets jQuery remain in the same
  compartment as the trusted code and sensitive data.

  We remark that both approaches are not mutually exclusive, i.e., it is
  possible to easily introduce compartments where fine-grained IFC is applied
  instead (e.g., JSFlow). This is an interesting direction for future work. On
  the other hand, extending JSFlow to introduce coarse-grained IFC is more
  challenging, e.g., JSFlow would (for instance) need to introduce the notion of
  compartments.

D: How general is the label system?

  As described in Section 3.1, we use the logic-based DCLabels of
  [28]. The particular logic is propositional logic without negation
  and it has been proved in [20] to be as expressive as the
  Decentralized Label Model.  More expressive logics (e.g., first
  order logic) can allow for richer policies than those permitted by
  DCLabels. For instance, even allowing negation would permit more
  expressive policies such as "this labeled blob cannot be read by
  a.com." With DCLabels, such policies must be encoded by
  "white-listing" all the permitted readers except a.com. We chose
  DCLabels because they correspond closely to the existing web
  policies, and we thus believe that web developers will find them
  intuitive. (Of course, at the cost of potentially not being able to
  express these applications.)

B: The tainted component does not need communication after initially
obtaining its taint/private information. Is that what's required of
applications in order for them to be secured by COWL?

  A compartment cannot communicate after getting tainted unless it
  has (or receives) the privilege to downgrade/declassify its label,
  as described in Section 3.2. Moreover, if the applications must
  communicate after reading sensitive data it can do so by (a-priori)
  creating multiple compartments (e.g., one to that always
  communicates with the network and the other for inspecting the
  sensitive data).

A: Will mashups with many libraries impose a requirement on developers
to understand overly-complex policies?

  We acknowledge that programming with COWL definitely does require
  understanding COWL's primitives. However, our experience to date is
  that a relatively small set of canonical design patterns captures
  many common web application (and mashup) behaviors. We believe that
  a higher-level policy language could let developers express
  intricate policies (e.g., that involve many libraries and mutual
  distrust among them) in a straightforward way, and that a compiler
  could then compile such policies into the COWL primitives. Such a
  language and compiler are the subject of our future work.

## Factual questions

B, D, E: What about integrity?

  Each label contains an integrity component; the design of
  integrity is complete and implemented, but was given short shrift
  in the submission for reasons of brevity.  As suggested, we intend
  to expand on this. 

E: SOP "provides some degree of integrity" for DOM changes, what about COWL?

  In Section 3.2, we mention that a privilege is required to modify
  the DOM (which has an integrity label corresponding to the origin),
  and privileges are granted in the same manner as SOP.

E: Is your vision to co-exist or replace all existing security mechanisms?

    COWL is explicitly designed to allow for an incremental deployment
    path.  While prior work (e.g., [40]) discusses how a label system
    can subsume the policies that can be implemented with today's SOP,
    CSP, CORS, etc, COWL co-exists with these mechanisms, offering MAC
    to pages which opt-in to this new functionality (summarized in
    Section 3).

E: How do you address taint-accumulation?

    In the case of compartments, the answer is two-fold.  First,
    compartments in browsing contexts are relatively short-lived, after
    which any raised labels go away.  Second, the ability to create
    compartments means operations which raise labels can be isolated to
    separate compartments. Good application design can avoid
    accumulation of taint.

    In the case of files, there is a simple design principle (seen in
    prior systems HiStar [42] and Hails/LIO [11]) to avoid
    taint-accumulation: the label associated with a file is immutable,
    and writes which cannot flow to the label are rejected.

A: What kind of objects can be labeled?

    Blobs, which can include serialized JavaScript values (e.g.
    as seen in postMessage).

A, B: How do you disallow the manual setting of label XHR header?

    The XHR API has the option for users to add custom headers to the
    request, as long as they are not a reserved header.  Label headers
    are also considered reserved, disallowing their "manual" modification.

B: What is the covert channel story for COWL?

    As mentioned in Section 3, COWL both restricts and relaxes the SOP.
    When the SOP is restricted--i.e., no labeled XHR was used--the
    question of covert channels is irrelevant,  since webpages do not
    have direct access to any more sensitive data than they would have
    had access to already.  This is the case for 3/4 example applications.

    Labeled XHR allows access to sensitive data that would not be
    accessible under SOP, so covert channels are a definite concern
    here.  In Section 3.3, we discuss how clearance can be used to
    restrict the sensitivity of data that can be read (and thus leaked
    via covert channels), allowing access only to data a compartment
    "needs to know." As also mentioned, to achieve the functionality of
    third-party mashup sites, the status quo requires the user to give
    up their password; COWL significantly improves this state of
    affairs.

B: Does the sharing of heap space for LWorker introduce new covert channels?

    Our implementation of LWorkers repurposes V8 and SpiderMonkey's
    contexts and compartments, respectively. These primitives are already
    used to isolate iframes of different origins to ensure that they
    operate on disjoint sub-heaps. Hence, we believe the chance of
    unauthorized leakage of information between LWorkers is identical to
    that between iframes.

A: What is the label check done when accessing DOM of compartment?

    In a footnote in Section 3.2, we mention that an integrity check is
    involved in the label check for DOM modification.  Here are the
    details: suppose compartment A tries to modify the DOM of
    compartment B. With DClabels, this operation is allowed if
    compartment A's current integrity label implies the integrity label
    on the DOM.

    Ordinarily, this label check would fail, because the current
    integrity label of all compartments defaults to public (no integrity
    guarantees), but the integrity label of a DOM defaults to its
    origin.  However, if compartment A holds the privilege for
    B, the operation would be allowed, the privilege overriding
    the label check and endorsing a cross-compartment DOM write.
    The mechanism by which this occurs is dual to declassification,
    described in Section 3.2.

D: What did you mean by ambient authority?

    Under the SOP, the notion of origin is always implicit: a page is
    loaded from a URL, and that compartment is forever associated with
    that exact origin. By "ambient authority" we mean the origin is
    implicit in the page. By contrast, under COWL, a compartment has
    explicit control over its label (and privilege).

C: Why is the iframe and worker creation in Firefox faster for the labeled case?

    We believe this difference (14.5 ms unlabeled, 14.4 ms labeled) is
    simply measurement noise.

C: Why do you exhaust the call stack and is this limit set by the spec?

    LWorkers run in the same context as the parent which spawns them,
    so messaging is actually a function call which runs-to-completion.
    The stack limit depends on the underlying JavaScript
    engine implementation and is not specified in the specification.

C: Why did you use a "simplified version" of the encrypted document editor?

    It was unclear how to securely reimplement the application without
    COWL, so we decided to be generous and implement a version with no
    privacy guarantees, which one would expect to run faster (it utilized
    no cryptographic operations).

D:  Why is CSP too restrictive for the password checker example when it can be used to white-list origins?

    There are actually two CSP policies one might consider.  A CSP
    policy which permits no origins is too restrictive because we can
    never download the password regex database.  However, a CSP policy
    which permits access to the database is too *permissive*.  Once you
    grant access to an origin, that access persists for the entire page,
    even after the password checker has received the password: it could
    just send the password to the remote origin.

D: Underlines, colors, bubbles?

    An underlined origin indicates that a compartment holds the
    privilege for that origin. We colored different origins differently
    for contrast. Spiked bubbles connote the raising of labels.
