\section{Application-Driven Design Requirements}
\label{sec:goals}

Having reviewed the status quo browser security architecture, we now
turn our attention to its implications for flexibility in web
application design and privacy for users. We briefly explore five
case-study applications that demand different sorts of flexibility,
while raising different privacy concerns.

\para{Password-Strength Checker} 
Many web sites employ password-strength checkers:
%
given a password input, a checker estimates the password's strength by
various metrics (e.g., length, number of special characters, etc.).
%
Naturally, when using a third-party password-strength checker
(e.g.,~\cite{checker1}) the user would like to be sure that the
code does not leak her password.
%
A malicious checker should at worst lie about the password's strength.

In today's browser security architecture, a page hosted, for instance,
on \https{instagra.me} can incorporate and partially confine a
simple third-party strength checker, \https{checker.biz/checker.js}.
%
In the interest of simplicity, we consider a checker that does not
require access to the enclosing page's DOM.
%
As such, to confine the strength checker, \https{instagra.me}
can execute the code in a Worker~\cite{workers};
%
since every worker has a separate, fresh compartment with no
access to the page's DOM, the checked cannot leak the password
by embedding images, loading scripts, etc.
%
However, workers do have access to the \xhr{} constructor, and thus,
\https{instagra.me} must additionally host the checker source and set
a CSP policy that restricts its network communication (e.g.,
\verb|connect-src: 'none'|)
%

While this approach goes some way toward protecting the password, there
is much about it that is unsatisfactory.
%
First, to avoid trusting the checker's origin, the checker source code
{\em must} be hosted by \https{instagra.me}, whose server can return a
CSP policy in an HTTP header that restricts the origins with which the
checker can communicate. As a DAC mechanism, CSP policies are rigid
and thus rule out certain rich functionality. For example, this
approach cannot be used to confine a checker that fetches a list of
commonly used passwords or regular expressions {\em before} checking
the strength of the password---a completely safe and useful operation. 
%
The CSP policy can only prohibit the worker from performing any
network requests (\verb|'none'|) or limit it to a set of origins.
%
However, even limiting the requests to the same origin (\verb|'self'|)
is unsatisfactory; the checker can potentially carry out a
self-exfiltration attack and leak the password to a public page on
\https{instagra.me}~\cite{selfex}.
%
We note, then, the requirement of a confinement
mechanism that allows code in a compartment to communicate with the
network {\em until it has been exposed to sensitive data.} MAC-based
confinement meets this requirement.
%
Moreover, requiring server-side CSP support is problematic for
developers whose servers only host content, and do not support the
setting of CSP HTTP headers.
%
Requiring server-side support also means that the checker cannot
incorporate code it itself does not trust---the SOP requires
\https{instagra.me} to host {\em all} the code and express the
security concerns of the strength checker as well. We desire a
confinement mechanism that {\em allows nesting of untrusted code,}
so that confinement is {\em first class.}
%
%% Finally, in the status quo, the CSP policy of the checker cannot be
%% more restricting than that of the containing document (since the
%% checker inherits the policy from it). Hence, the checker can
%% potentially carry out a self-exfiltration attack~\cite{selfex} and
%% leak the password to a public page on \https{instagra.me}.
%
%
In part, the above limitations arise because existing browser
techniques do not allow developers to express confinement, even for
code that does not require access to the DOM.

\para{Password Manager}
%
We now consider the shortcomings of today's browser security
mechanisms as applied to a password manager application, which allows
users to use a single master password to manage multiple site-specific
passwords.

%\para{Current approach}
%
%Today's browser security mechanisms are not useful when building a
%password manager as a website.
%
Because today's browsers do not support confinement, users must either
trust the origin of a password manager web application with their
credentials for other web sites (e.g., username and password for
\https{fb.com}) or trust these other websites with the master
password.
% used to protect
% other credentials.
%
As evidence of the current browser security architecture's inability
to preserve the privacy of users' credentials in a password manager
web application, consider that all major browsers today ship with
built-in password managers.
%
But a built-in password manager only requires the user to place even
more trust in the browser.
%
Such built-in apps increase the TCB of the browser, and even worse,
they do not always behave as desired (e.g., some password managers
fill in forms with credentials before submitting them---making
passwords available to potentially untrustworthy JavaScript code).
%
Moreover, adding more and more special-purpose application-level
functionality to the browser does not scale. We note again the
requirement of {\em confinement for code that handles sensitive data.}
Support for such confinement will obviate growing the browser TCB for
every application in which code must handle sensitive data.

\todo{?}{make a note that this app requires a symmetrical confinement
system: pwd manager and website are in mutual distrust}
\todo{?}{refer to the encrypted document editor at the end; the
password manager and this app share a very similar security
architecture/require similar guarantees, should we build this app in?}
\todo{?}{refer to existing trust-based/extension apps (lastpass,
1pass, etc.)}

\para{Banking application with untrusted jQuery}
jQuery, the widely used general-purpose JavaScript library, intimately
manipulates the DOMs of pages. How would one build a banking web
application, \https{bank.ch}, that safely uses jQuery? Today the only
way to give jQuery the access to the DOM that it needs is to include
the library within \https{bank.ch}'s origin---so jQuery is free to
leak any sensitive data from the application elsewhere with \xhr{}.
We note, then, the requirement for {\em confinement of code that
  computes over sensitive data within the same context.}

\para{Browser extensions} Today's browser extensions execute with
elevated privilege: if authorized at installation time by the user
(who typically agrees to grant whatever privileges are asked for),
they can read and write the DOM in all tabs \ldots and potentially
leak what they read with \xhr{}. Many simple extensions compute
locally within the browser over data within pages. Here, again,
confinement of code processing sensitive data, to prevent leakage of
such data by extensions, would strengthen privacy guarantees for
users.

\para{Third-party mashups}
