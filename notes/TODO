New results
    - Integrity for extensions
    - UI for clearance / integrity modification (for extensions and
      mash-ups)
    - New tab for encryption verification
    - DOM access label

Trying to think of a FAQ:
    1. Is your design backwards compatible?
    2. Why is it so fast?
    3. What about covert channels?
    4. How does this interact with CSP, etc.?
    6. I don't think developers can actually program an IFC system; I think requiring requiring the user to manipulate these policies is unreasonable.
    7. Why does your design work? How do I know it's OK?
       We shoudl cite ifc-inside paper (anonymous) saying that we have
       a formal model and security proofs
    8. What's new?

[DONE] switch back to USENIX style rather than freaky IEEE proc

we definitely need to state explicitly (possibly even in the intro?)
that our design doesn't break legacy pages/scripts (true, yes?ds: yes), and
explicitly explain why this is the case in the design section.

can Deian or EZ please convert the handwritten app figures into
computer-drawn (i.e., straight lines, typeset text) ones? Thanks!

overall, "tab" depiction in figures won't be understood as "implying
DOM" by OSDI reviewers; need to draw DOM explicitly within an origin's
frame (e.g., as a rectangle within the frame)

related work: i think that some of the fine grained ifc systems can be
used to more easily deal with phishing attacks... (maybe)

in the untrusted library scenario: it's important to not only raise
the current label, but also lower the clearance to ensure that the tcb
code in the worker can always access the DOM.

one more pretty relevant piece of related work:

Embassies: Radically Refactoring the Web (Howell et al., NSDI 2013)
Broadly speaking, takes on confining malicious code supplied by web
servers within the browser. Pretty different than what we're doing in
design, but not unrelated in end-to-end goal. Also a *very* impressive
piece of work (won best paper).

