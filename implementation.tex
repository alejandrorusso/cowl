\section{Implementation}
\label{sec:implementation}

\begin{figure}[t]
  \begin{subfigure}{\columnwidth}
    {\small
    \begin{webidl}
interface Label :
  Label Label(String)
  Label and(String or Label)
  Label or(String or Label)
  bool subsumes(Label [,Privilege])
    \end{webidl}
    \begin{webidl}
interface Privilege :
  Privilege FreshPrivilege()
  Privilege combine(Privilege)
  readonly attribute Label asLabel
    \end{webidl}
    }
    \vspace*{-8pt}
    \subcaption{Policy specification}
    \label{fig:api:policy} 
    \vspace*{8pt}
  \end{subfigure}
  \begin{subfigure}{\columnwidth}
    {\small
    \begin{webidl}
interface LabeledBlob :
  readonly attribute Label label
  readonly attribute Blob blob
    \end{webidl}
    }
    \vspace*{-8pt}
    \subcaption{Labeled blobs}
    \label{fig:api:blob} 
    \vspace*{8pt}
  \end{subfigure}
  \begin{subfigure}{\columnwidth}
    {\small
    \begin{webidl}
interface COWL :
  static void enable()
  static attribute Label label
  static attribute Label clearance 
  static attribute Privilege privilege
    \end{webidl}
    \begin{webidl}
interface LWorker :
  LWorker LWorker(String, Label
                  [, Privilege, object])
  postMessage(object)
  attribute EventHandler onmessage
    \end{webidl}
    }
    \vspace*{-8pt}
    \subcaption{Labeled compartments}
    \label{fig:api:compartments}
  \end{subfigure}
  \caption{\sys{} programming interface in simplified WebIDL.}
  \label{fig:api}
\end{figure}

We implemented \sys{} for the Firefox 31.0a1 and Chromium 31.0.1612.0
browsers.
%
Because \sys{} operates at a context granularity, it admits an
implementation as a new DOM-level API for the Gecko and Blink layout
engines, without any changes to the browsers' JavaScript engines.
%
Figure~\ref{fig:api} shows the core parts of this API.
%
%Below, we describe the key aspects of our implementation.
%
We focus on the Firefox implementation and only describe the Chromium
one where the two diverge non-trivially.
%

\subsection{Compartments}
\begin{table}
\resizebox{1.0\columnwidth}{!}{
\centering
\begin{tabular}{l|l}
\toprule
\textbf{Channel}           & \textbf{Mechanism}
\\\midrule%------------------------------------------------------
\js|postMessage|           & Cross-compartment wrappers\tablefootnote{
Since the Chromium architecture does not have cross-compartment
wrappers, we modify the DOM binding code to insert
label checks.}
\\\hline%--------------------------------------------------------
DOM window properties      & Cross-compartment wrappers
\\\hline%--------------------------------------------------------
Content loading            & CSP
\\\hline%--------------------------------------------------------
XHR                        & CSP + DOM interposition
\\\hline%--------------------------------------------------------
Browser storage            & SOP + iframe sandbox
\\\hline%--------------------------------------------------------
Other (\emph{e.g.,} iframe height)& DOM interposition
\\\bottomrule
\end{tabular}
}
\caption{Confining code from exfiltrating data using existing browser
mechanisms.}
\label{tab:comm}
\end{table}
 
Gecko's existing isolation model relies on JavaScript compartments, \emph{i.e.,}
disjoint JavaScript heaps, both for efficient garbage collection and
security isolation~\cite{wagner2011compartmental}.
%
To achieve isolation, Gecko performs all cross-compartment
communication (\emph{e.g.,} \js|postMessage| between iframes) through
\emph{wrappers} that implement the object-capability \emph{membrane}
pattern~\cite{miller2003paradigm,miller2006robust}; membranes enable
sound reasoning about ``border crossing'' between compartments. 
%% I want to say that they soundly let us reason about calls back into
%% the caller's compartment and border crossing came to mind, but I
%% don't really like it
%
Wrappers ensure that an object in one compartment can
never directly reference another object in a different compartment.
And they include a security policy.
%
Thus wrappers enforce all inter-compartment access control checks
specified by the SOP\@.
%
Each compartment has a security
principal used by the wrapper policy when making security
decisions at compartment boundaries.
%
This principal contains the origin and CSP of the compartment.

Since \sys{}'s security model is very similar to this existing
model, we can leverage these wrappers to introduce \sys{}'s new
security policies.
%
We associate a label, clearance, and privilege with each compartment
alongside the security principal.
%
Wrappers consider all of these properties together when making
security decisions.

\paragraph{Cross-Compartment Communication}
%
As shown in Table~\ref{tab:comm}, we rely on compartment wrappers to
confine cross-compartment (including cross-iframe) communication.
%
Once confinement mode is enabled---upon use of any of the API in
Figure~\ref{fig:api}---we ``recompute'' all cross-compartment
wrappers to use our MAC wrapper policy and thereby ensure that all
subsequent cross-compartment access is mediated by confinement---\emph{i.e.,}
that it uses labels in addition to the SOP\@.
%
In addition to implementing the MAC wrapper policy (which
performs label checks), we modified the function that recomputes
wrappers to use \sys{}'s wrappers when confinement mode is enabled.
%
When a cross-compartment communication is \js|postMessage|, our
policy ensures that the receiver's label subsumes that of the sender
(taking the receiver's privileges into consideration); otherwise the
message is silently dropped.
%
When the communication is a DOM property access, we additionally check
that the sender's label subsumes that of the receiver---\emph{i.e.,}
that the labels of the compartments are equivalent after considering
the sender's privileges (in addition to the same-origin check
performed by the SOP).

In Blink, the notion of a compartment roughly corresponds to an
execution context.
%
Blink differs from Gecko in how it implements access control checks for
DOM elements. 
%
Rather than relying on wrappers, Blink implements the SOP
security checks in the binding code for a limited subset of DOM
elements that may allow cross-origin access.
%
This ensures that the performance penalty of wrappers between pages of the same
origin does not exist.
%
Since \sys{} allows for policies that are more fine-grained than
the SOP, we modified the binding code by extending the security
checks to all DOM objects and adding label checks; this modification
imposes a penalty of a branch condition (to check if
confinement mode is enabled) on all DOM calls.

 
\paragraph{External Communication}
%
As shown in Table~\ref{tab:comm}, we confine external communication
via XHR, content loading, and navigation using CSP\@.
%
%% CSP provides developers with a
%% means for whitelisting the origins from which their application is
%% allowed to load resources~\cite{csp}.
%% %
%% Although CSP was originally limited to address XSS
%% attacks~\cite{kerschbaum2007simple}, in practice, the mechanism has
%% been used to (partially) restrict the origins to whom data can be
%% exfiltrated.
%
While CSP alone is insufficient for providing flexible
confinement,\footnote{
There are two primary reasons. First,
JavaScript code cannot (yet) modify a page's CSP\@.
And, second, CSP does not (yet) provide a directive for restricting 
in-browser communication, \emph{e.g.,} with \js|postMessage|.
}
it sufficiently addresses our external communication concern by
precisely controlling from where a page loads content, performs XHR
requests to, \emph{etc.}
%
To this end, we set a custom CSP policy whenever the compartment label
changes, \emph{e.g.,} with \js|COWL.label|.
%
For instance, if the effective compartment label is
\js|Label("https://bank.ch").and("https://amazon.com")|, all the
underlying CSP directive are set to \verb|'none'| (\emph{e.g.,}
\verb|default-src 'none'|) as to disallow all network communication;
we additionally use the \verb|'sandbox'| directive to disable
navigation~\cite{csp1.1,whatwg-html,html5}.
%

\paragraph{Storage Access}
As shown in Table~\ref{tab:comm}, we rely on the HTML5 iframe
\verb|sandbox| flag (the same as the CSP \verb|'sandbox'| directive)
to restrict access to storage, such as cookies~\cite{html5}.
%
%% Specifically, when the effective compartment label is a conjunctive
%% label (or a singleton whose origin is not the initially set origin),
%% we change the compartment principal to a fresh, unique
%% principal by setting the \verb|sandbox| flag.
%% %
%% This effectively amounts to changing the origin of the browsing
%% context, and thus ensures that the document can no longer access its
%% original storage.
%
This conservative approach has seen prior use~\cite{Akhawe2013}.
%
We leave the implementation of labeled storage as
future work.


%\subsection{\sys{} DOM objects}
%
%DOM objects such as \js|Label|s and \js|Privilege|s are implemented in
%C++ and made available to JavaScript using DOM binding code.
%%
%The implementation of labels and privileges is straight forward and
%follows directly from~\cite{stefan:2011:dclabels}.
%
%%% We solely remark that this approach of 
%%% imlementation corresponds to rougly 1/3 of
%%% the \sys{} code base; this large fraction is a direct result of using
%%% C++ and having to, for example, implement method overloading to
%%% support a friendly API and handle exceptional code with error codes.
%%% Do we care??
%
%\paragraph{Labeled blobs}
%%
%The implementation of labeled blobs is mostly straightforward.
%%
%
%%
%However, there are two interesting details.
%%
%First, instead of overloading the definition of \js|postMessage| to
%allow sending labeled data across browsing contexts, we modified the
%layout engine to add support for structurally cloning labeled blobs;
%this allows us to flexibly use labeled blobs where other structurally
%clonable objects (\emph{e.g.,} JSON) can be used, including \js|postMessage|.
%%
%Second, we modified the XHR code to allow arbitrary cross-origin reading
%when the response type is set to \verb|labeled-blob|;
%%
%as a consequence, the \js|response| attribute returns a labeled blob.
%%
%Unfortunately, the XHR specification for other attributes, such as
%\js|status|, is to return primitive values (non-objects) and our
%implementation raises the current label to reflect the observation of
%potentially sensitive data.\footnote{
%An alternative implementation can, at the cost of backwards
%incompatibility, label all the attributes of XHR instead of raising
%the current label and returning the ``unlabeled'' attribute.
%}
%

\subsection{Lightweight Workers}
%
The \js|LWorker| API in Figure~\ref{fig:api:compartments}
creates and communicates with lightweight labeled workers.
%
These are distinguished from ``normal'' workers, which create a new OS
thread. The constructor code for \js|LWorker| simply creates a new
compartment that contains a fresh JavaScript global; the execution of
this code shares the event loop with its parent (much like creating a
callback with \js|setTimeout|).
%
As such, a page can confine code without incurring the
costs of creating OS threads or full IPC for message
passing. Dispatching messages to/from lightweight workers is cheap
since the data is on the same heap.
%
(Of course, this also means that the worker cannot run in parallel.)
%
More importantly, the sharing of the event loop also allows a page to
give workers access to its DOM\@.
%
This implementation is very similar that of
Add-on SDK content-scripts~\cite{addon-sdk}; in fact, our Firefox
implementation uses the same \js|Sandbox| objects~\cite{mdn-sandbox}
used by these content scripts.
 

% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-default: "Make"
% End:
