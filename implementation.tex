\section{Implementation}
\label{sec:implementation}

\begin{figure}[t]
  \begin{subfigure}{\columnwidth}
    {\small
    \begin{webidl}
interface Label :
  Label Label(String)
  Label and(String or Label)
  Label or(String or Label)
  bool subsumes(Label [,Privilege])
    \end{webidl}
    \begin{webidl}
interface Privilege :
  Privilege FreshPrivilege()
  Privilege combine(Privilege)
  readonly attribute Label asLabel
    \end{webidl}
    }
    \vspace*{-8pt}
    \subcaption{Policy specification}
    \label{fig:api:policy} 
    \vspace*{8pt}
  \end{subfigure}
  \begin{subfigure}{\columnwidth}
    {\small
    \begin{webidl}
interface LabeledBlob :
  readonly attribute Label label
  readonly attribute Blob blob
    \end{webidl}
    }
    \vspace*{-8pt}
    \subcaption{Labeled blobs}
    \label{fig:api:blob} 
    \vspace*{8pt}
  \end{subfigure}
  \begin{subfigure}{\columnwidth}
    {\small
    \begin{webidl}
interface SWAPI :
  static void enable()
  static attribute Label label
  static attribute Label clearance 
  static attribute Privilege privilege
  static attribute Label domLabel
    \end{webidl}
    \begin{webidl}
interface LWorker :
  LWorker LWorker(String, Label
                  [, Privilege, object])
  postMessage(object)
  attribute EventHandler onmessage
    \end{webidl}
    }
    \vspace*{-8pt}
    \subcaption{Labeled compartments}
    \label{fig:api:compartments}
  \end{subfigure}
  \caption{\sys{} programming interface in simplified WebIDL.}
  \label{fig:api}
\end{figure}

We implemented \sys{} for the Firefox 31.0a1 and Chromium 31\Red{XXX}
browsers.
%
One of the motivations behind taking a coarse grained approach was to
avoid reasoning about the complexities of information flow at the
language level.
%
This allowed us to implement \sys{} as a new DOM API for the Gecko and
Blink layout engines, without modifying the JavaScript engines.
%
The core parts of this API are shown in Figure~\ref{fig:api}; our full
specification consists of \Red{264} lines of WebIDL~\cite{webidl}.
%
The underlying Gecko and Blink implementations are roughly \Red{3.4K}
and \Red{2.6K} lines of C++, respectively.\footnote{
  In all our line counts we simply report the length of the source
  files, which includes both comments and white space.
}
%
Below, we describe the these implementations; we focus on the Firefox
implementation and only describe the Chromium implementation where the
approach diverges in a non-trivial way.
%

\subsection{\sys{} DOM objects}

\paragraph{Labels and privileges}
%
DOM objects such as \js|Label|s and \js|Privilege|s are implemented in
C++ and made available to JavaScript using DOM binding code.
%
Hence, every property access on a JavaScript object results in an
invocation of a corresponding method on the underlying Gecko/Blink C++
object.
%
For example, \js|x.subsumes(y)| calls the underlying \js|Subsumes|
method on the C++ object corresponding to \js|x|.
%
The implementation of labels and privileges is straight forward and
follows directly from~\cite{stefan:2011:dclabels}.

%% We solely remark that this approach of 
%% imlementation corresponds to rougly 1/3 of
%% the \sys{} code base; this large fraction is a direct result of using
%% C++ and having to, for example, implement method overloading to
%% support a friendly API and handle exceptional code with error codes.
%% Do we care??

\paragraph{Labeled blobs}
%
Though we rely on the cross-language barriers to ensure that arbitrary
JavaScript cannot inspect the blob contents without raising the
current label, the implementation of labels blobs is mostly straight
forward.
%
There are only two details worth remarking.
%
First, instead of overloading the definition of \js|postMessage| to
allow sending labeled data across browsing contexts, we modified the
layout engine to add support for structurally cloning labeled blobs;
this allows us to flexibly use labeled blobs where other structurally
clonable objects (e.g., JSON) can be used, including \js|postMessage|.
%
Second, we modified the XHR code allow arbitrary cross-origin reading
when the repose type is set to \verb|labeled-blob|;
%
as a consequence the \js|response| attribute returns a labeled blob.
%
Unfortunately, the XHR specification for other attributes, such as
\js|status|, is to return primitive values (non objects) and our
implementation raises the current label to reflect the observation of
potentially sensitive data.\footnote{
An alternative implementation can, at the cost of backwards
incompatibility, label all the attributes of XHR instead of raising
the current label and returning the ``unlabeled'' attribute.
}

\paragraph{Light-weight workers}
%
The \js|LWorker| API of Figure~\ref{fig:api:compartment} is used to
create and communicate with light-weight labeled workers.
%
Different from ``normal'' workers which create a new OS thread, the
constructor code for \js|LWorker| simply create a new compartment
(described below) which contains a fresh JavaScript global; the
execution of this code shares the event-loop with its parent (much
like creating a callback with \js|setTimeout|).
%
As such, a page can confine code without incurring the
penalties of creating OS threads or full IPC for message
passing---dispatching messages to/from light-weight workers is cheap
since it the data is on the same heap.
%
(Of course this is at the cost of parallelism.)
%
More importantly, the sharing of the event loop also allows a page to
give workers access their DOM.
%
Our implementation of this is very similar to the implementation of
Add-on SDK content-scripts~\cite{addon-sdk}; in fact, our Firefox
implementation uses the same \js|Sandbox| objects~\cite{mdn-sandbox}
used by these content scripts.
%
Below we consider compartments more generally.
 

\subsection{Compartments}
\begin{table}
\resizebox{1.0\columnwidth}{!}{
\centering
\begin{tabular}{l|l}
\toprule
\textbf{Channel}           & \textbf{Mechanism}
\\\midrule%------------------------------------------------------
\js|postMessage|           & Cross-compartment wrappers\tablefootnote{
Since the Chromium architecture does not have cross-compartment
wrappers, our implementation modifies the DOM binding code to insert
label checks.}
\\\hline%--------------------------------------------------------
DOM window properties      & Cross-compartment wrappers
\\\hline%--------------------------------------------------------
Content loading            & CSP
\\\hline%--------------------------------------------------------
XHR                        & CSP
\\\hline%--------------------------------------------------------
Browser storage            & SOP + iframe sandbox
\\\hline%--------------------------------------------------------
Other (e.g., iframe height)& DOM interposition
\\\bottomrule
\end{tabular}
}
\caption{Confining code from exfiltrating data using existing browser
mechanisms.}
\label{tab:comm}
\end{table}
 
Gecko's isolation model relies on JavaScript compartments, i.e.,
disjoint JavaScript heaps, for both efficient garbage collection and
security isolation~\cite{wagner2011compartmental}.
%
(Hence our use of the term ``compartments''.)
%
The isolation is enforced by ensuring that all cross-compartment
communication (e.g., \js|postMessage| between iframes) is done through
\emph{wrappers}, that implement the object-capability \emph{membrane}
pattern~\cite{miller2003paradigm,miller2006robust} to sound reason
about ``border crossing''. 
%% I want to say that they soundly let us reason about calls back into
%% the caller's compartment and border crossing came to mind, but I
%% don't really like it
%
Importantly, wrappers ensure that an object from one compartment can
never reference another object from a different compartment directly.
%
This has the benefit that all inter-browsing context access control
checks---as specified by the SOP---can be enforced by the wrappers.
%
Naturally, this is possible because each compartment has a security
principal that is used in making this policy decision; among other,
the principal contains the origin and CSP policy of the compartment.

Our implementation relies on compartments and their properties in
several ways.
%
For instance, since compartments are our units of isolation, we
associate a label, clearance, and privilege with compartments.
%
In the case of browsing contexts we also associate a DOM access label
with the compartment.
%
As shown in Figure~\ref{fig:api}, the \js|SWAPI| object exposes these
properties to JavaScript.
% 
Moreover these labels and privilege, in addition to the compartment
principal and CSP, are used when making security decisions.

\paragraph{Cross-compartment communication}
%
As shown in Table~\ref{tab:comm} we rely on compartment wrappers to
confine cross-compartment (which includes cross-iframe) communication.
%
Once confinement-mode is enabled---by using any of the APIs of
Figure~\ref{fig:api}---we ``recompute'' all the cross-compartment
wrappers to ensure that all subsequent cross-compartment access is
mediated by confinement, i.e., it uses labels, and not the SOP.
%
To this end, we implemented a new wrapper policy and modified the
function that recomputes wrappers to use \sys{}'s wrappers when
confinement-mode is enabled.
%
When the cross-compartment communication is \js|postMessage| we simply
ensure that the receiver's label subsumes that of the sender (taking
the sender's privileges into consideration); otherwise the message is
dropped.
%
When the communication is a DOM property access we additionally check
that the sender's label subsumes that of the receiver, i.e., the labels of
the compartments are equivalent when considering the sender's
privileges, and that the receiver's DOM-access label and the sender's
label are equivalent (again taking the sender's label into
consideration).

In Blink, the notion of a compartment roughly corresponds to an
execution context.
%
Hence the current label, clearance and privileges are attached to
context objects.
%
Blink differs from Gecko in the way it implements access control checks for
DOM elements. 
%
Specifically, rather than rely on wrappers, Blink implements the SOP
security checks in the binding code for a limited subset of DOM
elements that may allow cross-origin access.
%
This ensures that the performance penalty of wrappers between pages of the same
origin does not exist.
%
Since \sys{} allows for policies that are more fine grained than
same-origin, we modified the binding code by extending the security
checks to all DOM objects and adding label checks; this modification
imposes a penalty of a branch condition (that checks if
confinement-mode is enabled).

 
\paragraph{External communication}
%
As shown in Table~\ref{tab:comm} we confine external communication,
via XHR, content loading, and navigation using CSP.
%
CSP provides developers with a
means for white-listing the origins from which their application is
allowed to load resources~\cite{csp}.
%
Although CSP was originally limited to address XSS
attacks~\cite{kerschbaum2007simple}, in practice, the mechanism has
been used to (partially) restrict the origins to whom data can be
exfiltrated.
%
While CSP alone is insufficient for providing flexible
confinement,\footnote{
This is shortcoming is primarily due to two reasons. First,
JavaScript code cannot (yet) modify the page CSP.
And, second, CSP does not (yet) provide a directive for restricting 
in-browser communication, e.g., with \js|postMessage|.
}
it sufficiently addresses our external communication concern by
precisely controlling from where a page loads content, performs XHR, etc.
%
To this end, we set a custom CSP policy whenever the compartment label
changes, e.g., with \js|SWAPI.label|.
%
For instance, if the effective compartment label is
\js|Label("https://bank.ch").and("https://amazon.com")|, all the
underlying CSP directive are set to \verb|'none'| (e.g.,
\verb|default-src 'none'|) as to disallow all network communication;
we additionally use the \verb|'sandbox'| directive to disallow
navigation~\cite{csp1.1,whatwg-html,html5}.
%

\paragraph{Storage access}
As shown in Table~\ref{tab:comm}, we additionally rely on the HTML5
iframe \verb|sandbox| flag (which is the same as the CSP
\verb|'sandbox'| directive) to restrict access to (and thus leaks
through) storage, such as cookies~\cite{html5}.
%
Specifically, when the effective compartment label is a conjunctive
label (or a singleton whose origin is not the initially set origin),
we change the compartment principal to a fresh, unique (null-)
principal by setting the \verb|sandbox| flag.
%
This effectively amounts to changing the origin of the browsing
context, and thus ensures that the document can no longer access its
original storage.
%
Like~\cite{Akhawe2013}, this is a conservative approach.
%
We leave the implementation of labeled storage (and API for it) to
future work.


% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-default: "Make"
% End:
