\section{Implementation}
\label{sec:implementation}

\begin{figure}[t]
  \begin{subfigure}{\columnwidth}
    {\small
    \begin{webidl}
interface Label :
  Label Label(String)
  Label and(String or Label)
  Label or(String or Label)
  bool subsumes(Label [,Privilege])
    \end{webidl}
    \begin{webidl}
interface Privilege :
  Privilege FreshPrivilege()
  Privilege combine(Privilege)
  readonly attribute Label asLabel
    \end{webidl}
    }
    \vspace*{-8pt}
    \subcaption{Policy specification}
    \label{fig:api:policy} 
    \vspace*{8pt}
  \end{subfigure}
  \begin{subfigure}{\columnwidth}
    {\small
    \begin{webidl}
interface LabeledBlob :
  readonly attribute Label label
  readonly attribute Blob blob
    \end{webidl}
    }
    \vspace*{-8pt}
    \subcaption{Labeled blobs}
    \label{fig:api:blob} 
    \vspace*{8pt}
  \end{subfigure}
  \begin{subfigure}{\columnwidth}
    {\small
    \begin{webidl}
interface COWL :
  static void enable()
  static attribute Label label
  static attribute Label clearance 
  static attribute Privilege privilege
    \end{webidl}
    \begin{webidl}
interface LWorker :
  LWorker LWorker(String, Label
                  [, Privilege, object])
  postMessage(object)
  attribute EventHandler onmessage
    \end{webidl}
    }
    \vspace*{-8pt}
    \subcaption{Labeled compartments}
    \label{fig:api:compartments}
  \end{subfigure}
  \caption{\sys{} programming interface in simplified WebIDL.}
  \label{fig:api}
\end{figure}

We implemented \sys{} for the Firefox 31.0a1 and Chromium 31.0.1612.0
browsers.
%
Because of our coarse-grained approach,
we were able to implement \sys{} as a new DOM-level API for the Gecko and
Blink layout engines, without modifying the JavaScript engines.
%
The core parts of this API are shown in Figure~\ref{fig:api}.
%
Below, we describe the key aspects of our implementation.
%
We focus on the Firefox
implementation and only describe the Chromium implementation where the
approach diverges in a non-trivial way.
%

\subsection{Compartments}
\begin{table}
\resizebox{1.0\columnwidth}{!}{
\centering
\begin{tabular}{l|l}
\toprule
\textbf{Channel}           & \textbf{Mechanism}
\\\midrule%------------------------------------------------------
\js|postMessage|           & Cross-compartment wrappers\tablefootnote{
Since the Chromium architecture does not have cross-compartment
wrappers, our implementation modifies the DOM binding code to insert
label checks.}
\\\hline%--------------------------------------------------------
DOM window properties      & Cross-compartment wrappers
\\\hline%--------------------------------------------------------
Content loading            & CSP
\\\hline%--------------------------------------------------------
XHR                        & CSP + DOM interposition
\\\hline%--------------------------------------------------------
Browser storage            & SOP + iframe sandbox
\\\hline%--------------------------------------------------------
Other (e.g., iframe height)& DOM interposition
\\\bottomrule
\end{tabular}
}
\caption{Confining code from exfiltrating data using existing browser
mechanisms.}
\label{tab:comm}
\end{table}
 
Gecko's existing isolation model relies on JavaScript compartments, i.e.,
disjoint JavaScript heaps, for both efficient garbage collection and
security isolation~\cite{wagner2011compartmental}.
%
The isolation is enforced by ensuring that all cross-compartment
communication (e.g., \js|postMessage| between iframes) is done through
\emph{wrappers}, that implement the object-capability \emph{membrane}
pattern~\cite{miller2003paradigm,miller2006robust}; membranes enable
sound reasoning about ``border crossing'' between compartments. 
%% I want to say that they soundly let us reason about calls back into
%% the caller's compartment and border crossing came to mind, but I
%% don't really like it
%
Wrappers ensure that an object from one compartment can
never directly reference another object from a different compartment.
%
Thus, all inter-compartment access control checks---as specified by
the SOP---are enforced by the wrappers which have an accompanying
security policy.
%
Compartments have a security
principal that is used by the wrapper policy in making security
decisions at the boundaries.
%
This principal contains the origin and CSP of the compartment.

Since \sys{}'s security model is very similar to this existing
model, we can leverage these wrappers to introduce our new
security policies.
%
A label, clearance, and privilege is now associated with compartments
alongside the security principal.
%
All of these properties are taken together when making security decisions
in the wrappers.

\paragraph{Cross-compartment communication}
%
As shown in Table~\ref{tab:comm}, we rely on compartment wrappers to
confine cross-compartment (which includes cross-iframe) communication.
%
Once confinement-mode is enabled---by using any of the APIs of
Figure~\ref{fig:api}---we ``recompute'' all the cross-compartment
wrappers to use our MAC wrapper policy and thereby ensure that all
subsequent cross-compartment access is mediated by confinement, i.e.,
it uses labels in addition to the SOP\@.
%
In addition to implementing the MAC wrapper policy (which
performs the label checks), we modified the function that recomputes
wrappers to use \sys{}'s wrappers when confinement-mode is enabled.
%
When the cross-compartment communication is \js|postMessage|, our
policy ensures that the receiver's label subsumes that of the sender
(taking the receiver's privileges into consideration); otherwise the
message is silently dropped.
%
When the communication is a DOM property access, we additionally check
that the sender's label subsumes that of the receiver, i.e., the labels of
the compartments are equivalent when considering the sender's
privileges (in addition to the same-origin check performed by the
SOP).

In Blink, the notion of a compartment roughly corresponds to an
execution context.
%
Blink differs from Gecko in the way it implements access control checks for
DOM elements. 
%
Rather than relying on wrappers, Blink implements the SOP
security checks in the binding code for a limited subset of DOM
elements that may allow cross-origin access.
%
This ensures that the performance penalty of wrappers between pages of the same
origin does not exist.
%
Since \sys{} allows for policies that are more fine grained than
same-origin, we modified the binding code by extending the security
checks to all DOM objects and adding label checks; this modification
imposes a penalty of a branch condition (that checks if
confinement-mode is enabled) on all DOM calls.

 
\paragraph{External communication}
%
As shown in Table~\ref{tab:comm}, we confine external communication,
via XHR, content loading, and navigation using CSP\@.
%
CSP provides developers with a
means for white-listing the origins from which their application is
allowed to load resources~\cite{csp}.
%
Although CSP was originally limited to address XSS
attacks~\cite{kerschbaum2007simple}, in practice, the mechanism has
been used to (partially) restrict the origins to whom data can be
exfiltrated.
%
While CSP alone is insufficient for providing flexible
confinement,\footnote{
This is shortcoming is primarily due to two reasons. First,
JavaScript code cannot (yet) modify the page CSP\@.
And, second, CSP does not (yet) provide a directive for restricting 
in-browser communication, e.g., with \js|postMessage|.
}
it sufficiently addresses our external communication concern by
precisely controlling from where a page loads content, performs XHR
requests to, etc.
%
To this end, we set a custom CSP policy whenever the compartment label
changes, e.g., with \js|COWL.label|.
%
For instance, if the effective compartment label is
\js|Label("https://bank.ch").and("https://amazon.com")|, all the
underlying CSP directive are set to \verb|'none'| (e.g.,
\verb|default-src 'none'|) as to disallow all network communication;
we additionally use the \verb|'sandbox'| directive to disable
navigation~\cite{csp1.1,whatwg-html,html5}.
%

\paragraph{Storage access}
As shown in Table~\ref{tab:comm}, we rely on the HTML5
iframe \verb|sandbox| flag (which is the same as the CSP
\verb|'sandbox'| directive) to restrict access to storage, such as cookies~\cite{html5}.
%
%% Specifically, when the effective compartment label is a conjunctive
%% label (or a singleton whose origin is not the initially set origin),
%% we change the compartment principal to a fresh, unique
%% principal by setting the \verb|sandbox| flag.
%% %
%% This effectively amounts to changing the origin of the browsing
%% context, and thus ensures that the document can no longer access its
%% original storage.
%
Like~\cite{Akhawe2013}, this is a conservative approach:
%
We leave the implementation of labeled storage (and API for it) to
future work.


%\subsection{\sys{} DOM objects}
%
%DOM objects such as \js|Label|s and \js|Privilege|s are implemented in
%C++ and made available to JavaScript using DOM binding code.
%%
%The implementation of labels and privileges is straight forward and
%follows directly from~\cite{stefan:2011:dclabels}.
%
%%% We solely remark that this approach of 
%%% imlementation corresponds to rougly 1/3 of
%%% the \sys{} code base; this large fraction is a direct result of using
%%% C++ and having to, for example, implement method overloading to
%%% support a friendly API and handle exceptional code with error codes.
%%% Do we care??
%
%\paragraph{Labeled blobs}
%%
%The implementation of labeled blobs is mostly straightforward.
%%
%
%%
%However, there are two interesting details.
%%
%First, instead of overloading the definition of \js|postMessage| to
%allow sending labeled data across browsing contexts, we modified the
%layout engine to add support for structurally cloning labeled blobs;
%this allows us to flexibly use labeled blobs where other structurally
%clonable objects (e.g., JSON) can be used, including \js|postMessage|.
%%
%Second, we modified the XHR code to allow arbitrary cross-origin reading
%when the response type is set to \verb|labeled-blob|;
%%
%as a consequence, the \js|response| attribute returns a labeled blob.
%%
%Unfortunately, the XHR specification for other attributes, such as
%\js|status|, is to return primitive values (non-objects) and our
%implementation raises the current label to reflect the observation of
%potentially sensitive data.\footnote{
%An alternative implementation can, at the cost of backwards
%incompatibility, label all the attributes of XHR instead of raising
%the current label and returning the ``unlabeled'' attribute.
%}
%

\subsection{Light-weight workers}
%
The \js|LWorker| API of Figure~\ref{fig:api:compartments} is used to
create and communicate with light-weight labeled workers.
%
These are distinguished from ``normal'' workers, which create a new OS thread; the
constructor code for \js|LWorker| simply creates a new compartment
which contains a fresh JavaScript global; the
execution of this code shares the event-loop with its parent (much
like creating a callback with \js|setTimeout|).
%
As such, a page can confine code without incurring the
penalties of creating OS threads or full IPC for message
passing---dispatching messages to/from light-weight workers is cheap
since the data is on the same heap.
%
(Of course, this also means that the worker cannot run in parallel.)
%
More importantly, the sharing of the event loop also allows a page to
give workers access their DOM\@.
%
Our implementation of this is very similar to the implementation of
Add-on SDK content-scripts~\cite{addon-sdk}; in fact, our Firefox
implementation uses the same \js|Sandbox| objects~\cite{mdn-sandbox}
used by these content scripts.
 

% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-default: "Make"
% End:
