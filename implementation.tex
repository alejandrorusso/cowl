\section{Implementation}
\label{sec:implementation}

We implemented \sys{} in the Firefox and Chrome browsers.
%
The API shown in Table~\toref{table:components} is specified in 264
lines of WebIDL~\cite{webidl}, common to both
implementations.
%
The remaining system is implemented in C++, modifying/extending the Gecko and
Blink layout engines, in roughly 3.4K and \Red{XXX} lines of code (LOC),
respectively.
%
In all our LOC reports, we simply count the length of the source files which
includes comments and empty-lines.
%
Below we detail the implementation of the various \sys{} components;
in Section~\ref{sec:eval}, we describe the implementation of the
Section~\ref{sec:system} applications.

%\subsection{Policies}
%
Our implementation of \js|Label|s and \js|Privilege|s is simply a port
of the Haskell implementation presented
in~\cite{stefan:2011:dclabels,stefan:2011:flexible}. 
%
This implementation is straight forward and only differs in the two
browsers because of their dependence on different container libraries;
the Firefox and Chrome implementations are roughly 1K and \Red{XXX}
lines of C++ code, respectively.
%
We note that much of this is a result of using C++ (and thus having
to, for example, implement method overloading to support a friendly
API)---as a comparison our JavaScript implementation of labels is
roughly 100 lines. \todo{ds}{Here, we should explain that the JS implementation
  is simply calling the native implementation. This is done because i) we need
  labels at C++ when comparisons take place ii) It could be DC labels
  implemented in JS but it would be super slow}
%
Below we focus on less-obvious implementation details.
%

\subsection{Firefox}
\label{sec:implementation:firefox}

Gecko's isolation model relies on \emph{compartments}, i.e., disjoint
JavaScript heaps, for both garbage collection (GC) and
security~\cite{wagner2011compartmental}.
%
The isolation is guaranteed by ensuring that all cross-compartment
communication (e.g., \js|postMessage| between iframes) is done through
\emph{wrappers}---an object from one compartment can never reference
another object from a different compartment directly.
%
This has the benefit that GC can be done in parallel, on different compartments,
and that all inter-browsing context access control checks---as specified, for
instance, by the SOP---can be enforced by the wrappers.
%
Naturally, this is possible because each compartment has a security
principal, i.e., the origin, which is used in making this policy
decision, in addition to those described in
Section~\ref{sec:background} (e.g., SOP, CSP and CORS when using XHR).


Our implementation relies on compartments and their properties in
several ways.
%
First, we associate label, clearance, and privilege with every 
compartment.
%
Once confinement-mode is enabled, we ``recompute'' all the
cross-compartment wrappers: this ensures that all subsequent
cross-compartment access is mediated by confinement, i.e., it uses
labels, and not the SOP. %, i.e., the principal.
%
We modified the function that recomputes wrappers to ues \sys{}'s
wrappers when confinement-mode is enabled.
%
This 81-line patch, in addition to adding a new field (pointing to a \sys{}
object that contains a label, privileges, etc.) to the compartment
object is our most intrusive patch---the other \sys{} components can be
maintained independently.
 
%
In order to enforce confinement, we use the CSP mechanism already present 
in the browser. 
%We use CSP policies, already present in browsers, to enforce
%confinement. 
By doing so, \sys{} does not require to add specific hooks or extra machinery. 
CSP policies are very expressive; in fact, they are
information flow control policies~\cite{yang:2013:towards}. This fact allows us
to precisely control how a page loads content, perform XHR, etc.
To enforce CSP, Gecko associates a CSP policy object with a principal.
%We use the compartment principal, and its associated CSP policy to
%restrict network access.
%
We set a custom CSP policy whenever the label is
explicitly set with \js|Browbound.label|.
%
For example, if the compartment label is
\js|Label("https://bank.ch").and("https://amazon.com")| and privilege
is simply \https{mint.biz}, we set the all the CSP directives to
\js|'none'| (e.g., \js|default-src 'none'|) in addition to the
\js|sandbox| flag that disallows
navigation~\cite{csp1.1,whatwg-html,html5}.
%

When the effective compartment label, i.e.., label considering privileges, is
a conjunctive label (or a singleton whose origin is not the initially set), 
we change the compartment principal to a fresh, unique (null-)
principal. 
%
This ensures that the document is no longer of same origin (as that
at the start of the load) and can thus no longer access the
initially-set-origin's storage.
%
Since these fresh principals always differ, the lifetime of the data does not
span multiple requests.
%
Hence, we additionally set the HTML5 \js|iframe sandbox| flag~\cite{html5},
to revoke access to persistent storage.


When privileges are set (either granted or revoked), the CSP policy is adapted
to reflect that change and allows the corresponding flows of
information. Nevertheless, a compartment that has been associated to a fresh
principal (e.g. when the effective label of a compartment is a conjunction), it
cannot access the storage even when it later gets granted the privilege to do
so. While conservative, we believe this approach is reasonable; it is not clear
what it means for a cookie to be labeled with a conjunction of
two principals.

%

Finally, we note that rather than executing labeled workers in a
separate OS-thread, as is the case for existing workers (whose goals
%% To have consistency with other part of the text which use this format
are different from ours), our \js|LWorker| constructor simply creates a new
compartment. This design decision provides 
%
%In addition to 
faster parent-worker calls (e.g.,
\js|postMessage|, or \js|onmessage| dispatch), which are effectively function
calls for which we add confinement checks. 
%
More importantly, it allows us to provide lightweight workers with access to the
DOM.
%
Specifically, like the new Add-on SDK content-script
extensions~\cite{addon-sdk}, we rely on Gecko's wrappers (which implement the
object-capability \emph{membrane}
pattern~\cite{miller2003paradigm,miller2006robust}) to ensure that each DOM
access abides by confinement (in our case, we conservatively treat each DOM
access, including a \js|get|, from a worker as a read-write effect).
%

\subsection{Chrome}
\label{sec:implementation:firefox}




% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-default: "Make"
% End:
