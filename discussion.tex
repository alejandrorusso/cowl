\section{Discussion and Limitations}
\label{sec:discussion}

In this section we discuss various design trade-offs, the limitations
of \sys{} that arise as result of these trade-offs, and future work
directions for addressing some of these limitations.

\paragraph{User-Configured Confinement} \Red{bk: moved this here
wholesale from 3, per discussion with Deian; probably needs tailoring
to fit here, but definitely belongs here.} Recall that in the
status-quo web security architecture, the SOP by default blocks an
origin from reading the response from a server of a different
origin. A server can use CORS to grant individual foreign origins
access to its data in all-or-nothing, DAC fashion. How does COWL's MAC
compose with the SOP and CORS's DAC? When a COWL-aware server grants a
foreign origin access to its data, it confines the foreign origin's
script(s) by setting a label on responses it sends the client. If a
COWL-enabled browser encounters an unlabeled response, but a CORS
header whitelisting the requesting foreign origin, COWL assumes that
the server is not COWL-aware and COWL itself labels the response with
a \emph{unique} origin (as described in
Section~\ref{sec:system:privileges}). Doing so ensures that once the
response has been inspected the code cannot communicate with
\emph{any} server, including at the \emph{same} origin,
% (e.g., \https{chase.com}),
since such requests carry the risks of
self-exfiltration~\cite{selfex} and cross-site request
forgery~\cite{CSRF}.

In both these cases, COWL's confinement system improves privacy over
the status quo by preventing the foreign origin's scripts from
straightforwardly disclosing the server's data. Absent a CORS header
that whitelists a foreign origin, however, the SOP would still
prohibit that foreign origin from reading responses from the server,
even in a COWL-enabled browser. The result would be the same
status-quo unpalatable choice between functionality and
privacy---e.g., give one's bank login credentials to Mint, or one
cannot use the Mint application. Given that COWL confines third-party
scripts, why not have COWL {\em discard} the SOP, and treat {\em all}
server responses as though they CORS-whitelist the requesting foreign
origin? A malicious third-party script could attempt to leak sensitive
data through covert channels, as we discuss below. As such, disabling
the SOP by default is ill advised. A server's operator can
CORS-whitelist specific remote origins, and COWL significantly
improves privacy over the status quo in such cases. But a server's
operator may not be aware of all applications its users may wish to
use. For this reason, COWL also allows browser users to augment CORS
by configuring for an origin any foreign origins they wish to
additionally whitelist. COWL will confine these foreign origins'
scripts as above, again improving privacy over the status quo.

\paragraph{Covert Channels}
In an ideal confinement system, it would always be safe to let untrusted
code compute on sensitive data.
%
Unfortunately, real-world systems such as browsers typically have
\emph{covert} channels which malicious code may exploit to exfiltrate
sensitive data.
%
Since our implementations of COWL modify existing browsers, we do not
protect against covert channel attacks.
%
Indeed, malicious code can leverage covert channels already present in
the browser to leak sensitive information.
%
For instance, a malicious compartment may exploit rendering durations,
as in~\tocite{}, to leak sensitive data to a less-tainted compartment
which may, in turn, exfiltrate the data to a remote host.
%
Importantly, however, COWL does not introduce new covert channels--our
implementations re-purpose existing (software-based) browser isolation
mechanisms (V8 contexts and SpiderMonkey compartments) to enforce MAC
policies.
%
Moreover, these MAC policies are generally more restricting than
existing browser policies: they prevent unauthorized data exfiltration
through \emph{overt} channels and, in effect, force malicious code to
resort to using covert channels.


COWL only relaxes existing policies with \lcors.
%
As described in Section~\toref{}, a compartment can use \lcors{} to
read cross-origin XHR responses otherwise not be permitted by the SOP
or (potentially) even CORS.
%
Of course, COWL confines such code and restricts its ability to
communicate once it inspects a response.
%
But, nevertheless, if the code is malicious it may potentially leak the
sensitive information through a covert channel.
 
At first this may appear as new risk.
%
However, we remark that \lcors{} is user controlled (e.g., the user
must explicitly allow \https{mint.com} to read \https{amazon.com} and
\https{chase.com} data), and code reading cross-origin data is
subject to MAC (e.g., \https{mint.com} will arbitrarily exfiltrate
the \https{amazon.com} or \https{chase.com} data after reading it).
%
This is in contrast to the approaches used by existing mash-up such as
\https{mint.com} which ask users for their passwords.
%
Indeed, COWL is a strict improvement over existing approaches: when
deciding to trust a mashup integrator such as \https{mint.com} users
are only trusting the app to not leak their data through covert
channels.

Trustworthy developers can further leverage COWL's support for
\emph{clearance} when compartmentalizing their application to ensure
that only code that actually relies on \lcors{} can access
cross-origin responses.
%
Clearance is a label that serves as an upper bound on the (current)
label of a compartment and since the current label is adjusted
according to the sensitivity of the data being read, code cannot read
(and thus leak) data labeled above the clearance.
%
Hence, apps like \https{mint.com} can assign a ``low'' clearance to
third-party libraries that they do not trust to keep (e.g.,
\https{chase.com}) data confidential.
%
In turn, these libraries, even if they are malicious, will not be able
to leak such data through covert channels.
%
While COWL fully implements clearance, we do not discuss it further;
our treatment of it is standard and follows directly
from~\cite{efstathopoulos:asbestos, Zeldovich:2006,
stefan:2011:flexible, Breeze13}.

%%%%

%
% \todo{}{it's important for us to note that we do not address covert
% channels even for conservative-design, since developers may have the
% impression that they're getting bullet-proof security when sending a
% password to another frame, when in actuality it can be leaked (though
% at a low bit rate)}


\Red{


\paragraph{DC Labels and Lattice-based Policies}
\label{sec:discussion:lattice}
 
Second, and more importantly, \sys{} only enforces latticed-based
policies, i.e., DC labels dictate where information can be
disseminated.
%
DC labels are similar in expressiveness as the \emph{Decentralized Label
Model}~\cite{GenLabels}(DLM)\footnote{DLM secrecy policies can be encoded as DC
  labels when no principals hierarchy is considered.}, but less expressive than first
order logic. Nevertheless, they closely reflect existing web policies---allowing
COWL to reuse CSP 
to enforce them.
%

%Although DC labels captures a wide-set of policies, it does not capture 
%all possible confinement policies.
%
%For instance, 
Although lattice-based policies capture a wide-set of confinement practices, 
they 
%Lattice-based policies 
are not suitable for scenarios in which a circular flows of information is
desired~\cite{Badger:1995}.
%
Although we could have taken an approach similar to DCS~\cite{Akhawe2013}, where
policies are given in the form of developer-provided code, we believe that the
trade-off for DC labels' simplicity---that of simply specifying which origins
are allowed to read a piece of data---outweighs the ability to specify
arbitrarily policies and the accompanying complexities.

}


% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-default: "Make"
% End:

