\section{Discussion and Limitations}
\label{sec:discussion}

In this section we discuss various design trade-offs, the limitations
of \sys{} that arise as result of these trade-offs, and future work
directions for addressing some of these limitations.

\paragraph{User-Configured Confinement}
Recall that in the status-quo web security architecture, the SOP by
default blocks an origin from reading the response from a server of a
different origin. To allow cross-origin sharing, a server can use CORS
to grant individual foreign origins access to its data in
all-or-nothing, DAC fashion.
%
COWL improves this state of affairs
by allowing a COWL-aware server to impose restrictions on how its
shared data is disseminated, i.e., when the server
grants a foreign origin access to its data, it can confine the foreign
origin's script(s) by setting a label on responses it sends the
client.

Unfortunately, absent a permissive CORS header that whitelists the
origins of applications that a user wishes to use, the SOP
prohibits foreign origins from reading responses from the server,
even in a COWL-enabled browser.
%
Since a server's operator may not be aware of all applications its
users may wish to use, the result is usually the same status-quo
unpalatable choice between functionality and privacy---e.g., give
one's bank login credentials to Mint, or one cannot use the Mint
application.
%
For this reason, we allow browser users to augment CORS
by configuring for an origin (e.g., \https{chase.com}) any foreign
origins (e.g., \https{mint.com}, \https{geko-cash.com}) they wish to
additionally whitelist.
%
In turn, COWL will confine these client-whitelisted origins (e.g.,
\https{mint.com}) by labeling every response from the configured
origin (\https{chase.com}).
%
In particular, COWL will use the server-supplied label when available
and server white-listing is \emph{not} provided;
otherwise, we conservatively label the response with a
\emph{fresh} origin (as described in
Section~\ref{sec:system:privileges}). The latter ensures that once the
response has been inspected, the code cannot communicate with
\emph{any} server, including at the \emph{same} origin, since such
requests carry the risks of self-exfiltration~\cite{selfex} and
cross-site request forgery~\cite{CSRF}.
%


\paragraph{Covert Channels}
In an ideal confinement system, it would always be safe to let untrusted
code compute on sensitive data.
%
Unfortunately, real-world systems such as browsers typically have
\emph{covert} channels which malicious code may exploit to exfiltrate
sensitive data.
%
Since our implementations of COWL modify existing browsers, we do not
protect against covert channel attacks.
%
Indeed, malicious code can leverage covert channels already present in
the browser to leak sensitive information.
%
For instance, a malicious context may exploit rendering durations, as
in~\cite{kotcher2013cross}, to leak sensitive data to a less-tainted
context which may, in turn, exfiltrate the data to a remote host.
%
Importantly, however, COWL does not introduce new covert channels--our
implementations re-purpose existing (software-based) browser isolation
mechanisms (V8 contexts and SpiderMonkey compartments) to enforce MAC
policies.
%
Moreover, these MAC policies are generally more restricting than
existing browser policies: they prevent unauthorized data exfiltration
through \emph{overt} channels and, in effect, force malicious code to
resort to using covert channels.


COWL only relaxes existing policies when allowing users to override
CORS as to permit cross-origin (labeled) sharing.
%
At first this may appear as a completely new risk.
%
However, we remark that the white-listing is user controlled (e.g.,
the user must explicitly allow \https{mint.com} to read
\https{amazon.com} and \https{chase.com} data), and code reading
cross-origin data is subject to MAC (e.g., \https{mint.com} cannot
arbitrarily exfiltrate the \https{amazon.com} or \https{chase.com}
data after reading it).
%
This is in contrast to the approaches used by existing mash-up such as
\https{mint.com} which ask users for their passwords.
%
Indeed, COWL is a strict improvement over existing approaches: when
deciding to trust a mashup integrator such as \https{mint.com} users
are only trusting the app to not leak their data through covert
channels.
%
Nevertheless, users make poor security choices and whitelisting
malicious origins will be no exception; we recognize this is as a
limitation of COWL that must ultimately be communicated to the end-user
(much like SSL certificates).

Trustworthy developers, can leverage COWL's support for
\emph{clearance} when compartmentalizing their application to ensure
that only code that actually relies on cross-origin data has access to
it.
%
Clearance is a label that serves as an upper bound on the (current)
label of a compartment and since the current label is adjusted
according to the sensitivity of the data being read, code cannot read
(and thus leak) data labeled above the clearance.
%
With clearance, Mint can assign a ``low'' clearance to
third-party libraries that they do not trust to keep (e.g.,
\https{chase.com}) data confidential.
%
In turn, these libraries, even if they are malicious, will not be able
to leak such data through covert channels.

%%%%

%
% \todo{}{it's important for us to note that we do not address covert
% channels even for conservative-design, since developers may have the
% impression that they're getting bullet-proof security when sending a
% password to another frame, when in actuality it can be leaked (though
% at a low bit rate)}



\paragraph{DC labels and lattice-based Policies}
\label{sec:discussion:lattice}

COWL uses DC labels~\cite{stefan:2011:dclabels} to enforce
confinement according to an information flow control discipline.
%
Although this approach captures a wide-set of confinement policies, it
is not expressive enough to handle policies with a circular flow of
information~\cite{Badger:1995}, policies expressible in
more powerful logics (e.g., first order logic, as used by
Nexus~\cite{sirer2011logical}), etc.
%
Indeed, even allowing negative formulas in a label would permit more
expressive policies (e.g., ``this labeled Blob cannot be read by \https{a.com},
but can be read by any other origin''); with DC labels, such policies must be
encoded by `whitelisting'' all the permitted readers.
%
DC labels are, however, as expressive as other popular label
models~\cite{GenLabels}, including Myer's and
Liskov's~\emph{Decentralized Label Model}~\cite{dlm}.

We primarily chose DC labels because of their close correspondence to
web origins.
%
This has two important benefits.
%
First, we believe that web developers will find DC labels intuitive
and expressive enough to build real applications.
%
(Recall that developers typically express policies by whitelisting
origins.)
%
Our experience building applications, some of which we described in this
paper, supports this hypothesis;
their use in server-side applications is also
encouraging~\cite{giffin:2012:hails, Breeze13, stoughton2014you,
stefan:2011:flexible}.
%
Second, while modifying the browser to support more powerful logics
and mechanisms is possible, DC labels have the advantage of mapping
naturally to existing web policies:
we were able to reuse existing security mechanisms, such as
CSP, to implement most of the COWL design.
%% %
%% (This was a surprising given our previous work showed how IFC can be
%% used to enforce existing policies, but not the
%% converse~\cite{yang:2013:towards}.)


% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-default: "Make"
% End:

