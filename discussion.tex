\section{Discussion and Limitations}
\label{sec:discussion}

In this section we discuss various design trade-offs, the limitations
of \sys{} that arise as result of these trade-offs, and future work
directions for addressing some of these limitations.


\paragraph{Covert Channels}
In an ideal confinement system, it would always be safe to let untrusted
code compute on sensitive data.
%
Unfortunately, real-world systems such as browsers typically have
\emph{covert} channels which malicious code may exploit to exfiltrate
sensitive data.
%
Since our implementations of COWL modify existing browsers, we do not
protect against covert channel attacks.
%
Indeed, malicious code can leverage covert channels already present in
the browser to leak sensitive information.
%
For instance, a malicious compartment may exploit rendering durations,
as in~\tocite{}, to leak sensitive data to a less-tainted compartment
which may, in turn, exfiltrate the data to a remote host.
%
Importantly, however, COWL does not introduce new covert channels--our
implementations re-purpose existing (software-based) browser isolation
mechanisms (V8 contexts and SpiderMonkey compartments) to enforce MAC
policies.
%
Moreover, these MAC policies are generally more restricting than
existing browser policies: they prevent unauthorized data exfiltration
through \emph{overt} channels and, in effect, force malicious code to
resort to using covert channels.


COWL only relaxes existing policies with \lcors.
%
As described in Section~\toref{}, a compartment can use \lcors{} to
read cross-origin XHR responses otherwise not be permitted by the SOP
or (potentially) even CORS.
%
Of course, COWL confines such code and restricts its ability to
communicate once it inspects a response.
%
But, nevertheless, if the code is malicious it may potentially leak the
sensitive information through a covert channel.
 
At first this may appear as new risk.
%
However, we remark that \lcors{} is user controlled (e.g., the user
must explicitly allow \https{mint.com} to read \https{amazon.com} and
\https{chase.com} data), and code reading cross-origin data is
subject to MAC (e.g., \https{mint.com} will arbitrarily exfiltrate
the \https{amazon.com} or \https{chase.com} data after reading it).
%
This is in contrast to the approaches used by existing mash-up such as
\https{mint.com} which ask users for their passwords.
%
Indeed, COWL is a strict improvement over existing approaches: when
deciding to trust a mashup integrator such as \https{mint.com} users
are only trusting the app to not leak their data through covert
channels.

Trustworthy developers can further leverage COWL's support for
\emph{clearance} when compartmentalizing their application to ensure
that only code that actually relies on \lcors{} can access
cross-origin responses.
%
Clearance is a label that serves as an upper bound on the (current)
label of a compartment and since the current label is adjusted
according to the sensitivity of the data being read, code cannot read
(and thus leak) data labeled above the clearance.
%
Hence, apps like \https{mint.com} can assign a ``low'' clearance to
third-party libraries that they do not trust to keep (e.g.,
\https{chase.com}) data confidential.
%
In turn, these libraries, even if they are malicious, will not be able
to leak such data through covert channels.
%
While COWL fully implements clearance, we do not discuss it further;
our treatment of it is standard and follows directly
from~\cite{efstathopoulos:asbestos, Zeldovich:2006,
stefan:2011:flexible, Breeze13}.

%%%%

%
% \todo{}{it's important for us to note that we do not address covert
% channels even for conservative-design, since developers may have the
% impression that they're getting bullet-proof security when sending a
% password to another frame, when in actuality it can be leaked (though
% at a low bit rate)}


\Red{


\paragraph{DC Labels and Lattice-based Policies}
\label{sec:discussion:lattice}
 
Second, and more importantly, \sys{} only enforces latticed-based
policies, i.e., DC labels dictate where information can be
disseminated.
%
Although this captures a wide-set of policies, it does not capture all
possible confinement policies.
%
For instance, lattice-based policies are not suitable for scenarios in
which a circular flows of information is desired~\cite{Badger:1995}.
%
Though we could have taken an approach, as in DCS~\cite{Akhawe2013},
to allow policies to be in the form of developer-provided code, we
believe that the trade-off for DC labels' simplicity---that of simply
specifying which origins are allowed to read a piece of
data---outweighs the ability to specify arbitrarily policies and the
accompanying complexities.



\paragraph{Policy-granularity}

\sys{} associates a label with a compartment, or (informally) browsing
context.
%
This is in contrast to systems such as JSFlow~\cite{Hedin:2012} and
FlowFox~\cite{DeGroef:2012}, which, rely on fine-grained labeling.
%
Inspired by the HiStar~\cite{Zeldovich:2006} and
LIO~\cite{stefan:2011:flexible} confinement systems, we took a coarse-grained
approach because of three cor reasons.
%
First, policies on the web are specified in terms of origins which
interact at the granularity of browsing contexts in the browser.
%
Hence, developers already compartmentalize applications at this
granularity---\sys{} simply provides developers with the stronger
guarantee of confinement.
%
Second, modifying the JavaScript engine
(e.g.,~\tocite{scriptpolice}), providing an alternative interpreted
engine (e.g.,~\cite{Hedin:2012}), or executing the same page for each
security label (e.g.,~\cite{DeGroef:2012}) is not practical, in the
general case; patches that have intrusive browser changes, especially
to the JavaScript engine, or introduce drastic performance
degradations are typically rejected by popular browsers such as
Firefox and Chromium.\footnote{
  Personal communication with SpiderMonkey and V8 developers.
}
%
The goals of being minimally-intrusive, backwards compatible with the
existing Web, while still performant almost necessarily lends itself
to a coarse-grained design such \sys{}.
%
Finally, associating labels with individual DOM objects is error
prone and not scalable as it requires reasoning about the individual
side-effects of each property/method---reasoning about information
flow at the granularity of compartments is more straight forward,
especially since browsers already need to do so to enforce the SOP.
\todo{ds}{say something about sub-resource integrity}

%% We implemented \sys{} in the browser layout engine (without
%% modifying the JavaScript engine), reusing existing security mechanisms
%% (e.g., CSP) to enforce confinement, while exposing the system in a
%% modular fashion as a new DOM API; 

However, the ability to associate labels with individual objects
simplifies the implementation of certain applications. 
%
For instance, JSFlow can associate a label with a password object
to ensure that potentially malicious code within the browsing context
cannot leak it arbitrarily.
%
In \sys{}, such fine-grained labeling requires restructuring the
application (as opposed to simply associating a label with an object)
%
Concretely, we must partition the application such that
heterogeneously labeled objects/DOM-elements are in separate labeled
workers or iframes.
%
For example, labeling a JavaScript password object would entail
placing this object in a separate labeled worker, while associating a
label with a password-input field would require a new iframe (to
render the element).
%
Though we believe that the expressively of \sys{} when compared to
fine-grained systems is comparable, the need for separate compartments
to hold differently-labeled data may require code to interact with the
data asynchronously.
}

% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-default: "Make"
% End:

