\section{Discussion and Limitations}
\label{sec:discussion}

In this section we discuss various design trade-offs, the limitations
in \sys{} that arise as result of these trade-offs, and our approach
to addressing some of these limitation in future work.


\subsection{Covert channels}
\label{sec:discussion:covert}

Part of our future work entails the development of a W3C
specification detailing the \sys{} system.
%
Hence, we must consider the effects of covert channels.
%
To this end, we divide our system into two designs:
%
we refer to the system as described in
Section~\ref{sec:system} as the \emph{full design};
and, the subset without the labeled XHR object of
Section~\ref{sec:system:mashup} is referred to as the
\emph{conservative design}.

Though the conservative \sys{} enables new kinds of applications by
eliminating full trust in any single individual component, \sys{}
strictly imposes more restrictions on code than the SOP.
%
Consequently, attackers that leverage covert channels, which are
introduced by races to shared resources, such as caches, schedulers,
etc. to leak information in a browser with \sys{} will leak at most as
much information as a version of the browser without confinement.
%
Nevertheless, we note that outside of introducing the notion of
clearance, which restricts the kinds of data a piece of code can
access and thus leak, we do not address covert channels in this work. 

%
% \todo{}{it's important for us to note that we do not address covert
% channels even for conservative-design, since developers may have the
% impression that they're getting bullet-proof security when sending a
% password to another frame, when in actuality it can be leaked (though
% at a low bit rate)}


The labeled XHR object allows arbitrary code to read cross-origin
data, at the cost of giving up arbitrary communication capabilities
when inspecting the response.
%
Unfortunately, this allows code to leak a bit by not terminating.
%
For example, to leak one bit of \https{bank.ch} data, \https{evil.com}
solely needs to create a labeled iframe within which the labeled XHR
is used to read bank data.
%
In the parent, code periodically sends a request to \https{evil.com},
while in the labeled iframe (which is no longer allowed to communicate
arbitrarily) the code loops forever if bit is 1.
%
This, unfortunately, blocks the event loop and prevents further
request to \https{evil.com}, thereby leaking the bit.



At first glance, it may appear that executing labeled workers and
iframes in separate threads would remove this termination covert
channel, as previously observed in~\cite{stefan:addressing-covert}. 
%
Unfortunately, this approach is not be feasible in current web browser
implementations; both Firefox and Chrome bound the number of worker
threads to five, as to avoid attacks that create a large number of
threads.
%
And, imposing such a limit on the number of threads does trivially
reintroduces the attack.
%
While using light-weight threads as used in~\cite{stefan:addressing-covert},
hierarchical- and instruction-based
schedulers~\cite{stefan:2013:eliminating,buiras2013library}, and predicative
mitigation techniques~\cite{askarov:termination-insensitive} is promising, we do
not expect browsers to be amendable to such heavy-weight techniques.
%
Instead, simple heuristics may be more practical since the browser,
in the case of Firefox, and tab, in Chrome's case, hang when an
attacker exploits the termination covert channel.

Nevertheless, since the labeled XHR constructor allows code to access
data not otherwise permitted by the SOP, we recognize that exposing
the labeled XHR to arbitrary code is dangerous.
%
However, the conservative \sys{} already improves the state of the art
in web security, and we thus leave the investigation of covert channel
bandwidths and practicality in exploiting this construct as future
work.
%
In the interim, this construct is useful when considering extensions,
which currently access cross-origin data without any restrictions or
confinement---our constructor can be used to impose some restrictions
on what extensions can do once they read cross-origin data.

\subsection{DC Labels and Lattice-based Policies}
\label{sec:discussion:lattice}

The implementation of \sys{} is tied to DC labels.
%
This design decision has several consequences.
%
First, developers must familiarize themselves with labels to express
security policies on their data.
%
However, we believe that the encoding of web policies maps naturally
to DC labels and though simple, the evaluation in
Hails~\cite{giffin:2012:hails}, and our ability to implement diverse
applications with \sys{} supports this conjecture.
%
We further remark that \sys{} conceptually provides developers with
the ability to dynamically set CSP directives, and only share data
with browsing contexts if their directives impose a more strict
policy; with the increase usage of CSP, this minimizes the additional
knowledge developers need to pick up to set correct policies.
%
Nevertheless, we leave a more extensive analysis of policy
specification to future work.
 
Second, and more importantly, \sys{} only enforces latticed-based
policies, i.e., DC labels dictate where information can be
disseminated.
%
Although this captures a wide-set of policies, it does not capture all
possible confinement policies.
%
For instance, lattice-based policies are not suitable for scenarios in
which a circular flows of information is permitted~\cite{Badger:1995}.
%
Though we could have taken an approach, as in DCS~\cite{Akhawe2013},
to allow policies to be in the form of developer-provided code, we
believe that the trade-off for DC labels' simplicity---that of simply
specifying which origins are allowed to read a piece of
data---outweighs the ability to specify arbitrarily policies and the
accompanying complexities.


\subsection{Policy-granularity}
\label{sec:discussion:granularity}

\sys{} associates a label with a compartment, or (informally) browsing
context.
%
This is in contrast to systems such as JSFlow~\cite{Hedin:2012} and
FlowFox~\cite{DeGroef:2012}, which, rely on fine-grained labeling.
%
Inspired by the HiStar~\cite{Zeldovich:2006} and
LIO~\cite{stefan:2011:flexible} confinement systems, we took a coarse-grained
approach because of three core reasons.
%
Firstly, policies on the web are specified in terms of origins which
interact at the granularity of browsing contexts in the browser.
%
Hence, developers already compartmentalize applications at this
granularity---\sys{} simply provides developers with the stronger
guarantee of confinement.
%
Secondly, modifying the JavaScript engine (e.g.~\tocite{scriptpolice}),
providing an alternative interpreted engine (e.g.,~\cite{Hedin:2012}),
or executing content per security label (e.g.,~\cite{DeGroef:2012}) is
not practical, in the general case;
patches that have intrusive browser changes, especially to the
JavaScript engine,\footnote{
  Personal communication with SpiderMonkey and V8 developers.
} or introduce drastic performance degradations are typically rejected
by popular browsers such as Firefox and Chromium.
%
The goals of being minimally-intrusive, backwards compatible with the
existing Web, while still performant almost necessarily lends itself
to a coarse-grained design such \sys{}.
%
Thirdly, associating labels with individual DOM objects is error
prone and not scalable as it requires reasoning about the individual
side-effects of each property/method---reasoning about information
flow at the granularity of compartments is more straight forward,
especially since browsers already need to do so to enforce the SOP.

%% We implemented \sys{} in the browser layout engine (without
%% modifying the JavaScript engine), reusing existing security mechanisms
%% (e.g., CSP) to enforce confinement, while exposing the system in a
%% modular fashion as a new DOM API; 

However, the ability to associate labels with individual objects
simplifies the implementation of certain applications. 
%
For instance, JSFlow can associate a label with a password object
to ensure that potentially malicious code within the browsing context
cannot leak it arbitrarily.
%
In \sys{}, such fine-grained labeling requires restructuring the
application (as opposed to simply associating a label with an object)
%
Concretely, we must partition the application such that
heterogeneously labeled objects/DOM-elements are in separate labeled
workers or iframes.
%
For example, labeling a JavaScript password object would entail
placing this object in a separate labeled worker, while associating a
label with a password-input field would require a new iframe (to
render the element).
%
Though we believe that the expressively of \sys{} when compared to
fine-grained systems is comparable, the need for separate compartments
to hold differently-labeled data does affect
semantics~\cite{Ingram:2012}---specifically, it requires code interact
with the data asynchronously.

\subsection{Extension-API coverage}
\label{sec:discussion:extension}

\todo{We do not wrap the trusted extension API with labels. We can
do this, but haven't...}


% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-default: "Make"
% End:

