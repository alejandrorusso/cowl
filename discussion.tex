\section{Discussion and Limitations}
\label{sec:discussion}


\subsection{Covert channels}

%% Intro covert channel
As many confinement systems, \sys{} is not flawless. The existence of covert
channels allows malicious scripts to reveal sensitive
information~\cite{lampson:confinement}.  Such channels often arise when
programming language features are misused to leak information; The tolerance to
their presence is usually determined by their bandwidth and how easy is to
exploit them.

%% Browbound suffer from the termination channel
\sys{} suffers from the termination covert channel. Scripts are then capable to
reveal information by diverging based on confidential values. The reason for
that relies in the implementation of labeled workers: \emph{they all run in the
  same thread}. If a labeled worker diverges, then the corresponding browser tab
hangs. The best strategy for malicious scripts is then to perform a brute-force
attack every time that a page is loaded, e.g., a worker hangs when guessing the
exact value of the secret~\cite{askarov:termination-insensitive}. In our
setting, the termination channel has a capacity where the time needed to reliably
leak the secret is exponential in the number of secret bits.

%% Solution: labeled workers as real workers (threads)

%% a) Labeled workers as workers
%% b) We have a limited of 5 
%% c) Useless, since we do not have restriction how to create threads
%% d) Having them in a different threads will require for us to instrument some 
%%    synchronizaiton to accesing the DOM

At first glance, labeled workers could be run on separate threads, which indeed
removes the termination channel~\cite{stefan:addressing-covert}.  Unfortunately,
this idea might not be feasible to implement in modern web browsers. Firefox and
Chrome bound the number of workers (running on separate threads) to five. The
reason for that being two fold; first, the creation of threads is heavy-weight,
and second, workers are not intended  to be used in large numbers
by web pages. 
%\sys{} could remove the termination channel at the price of
%allowing a maximum of five labeled workers which are guarantee to terminate.  
Observe that the termination channel could still be exploited.  It would be
enough for a script to exhaust the number of allowed labeled workers (five) in
order to make a program crash.
%\sys{} could remove the termination channel at the price of
%allowing a maximum of five labeled workers. 
Alternatively, and as it is now, \sys{}
permits to freely create any number of labeled workers, while leaving the
termination channel exploitable only by brute-force attacks.

% \Red{Make sure to note that in the presence of covert channels
% relaxing the SOP is very dangerous. So, COLWorkers could really be
% limited to extensions/pages that explicitly request this feature.}

\subsection{DC Labels and Lattice-based Policies}

The implementation of \sys{} is tied to DC labels.
%
This design decision has several consequences.
%
First, developers must familiarize themselves with labels to express
security policies on their data.
%
However, we believe that the encoding of web policies maps naturally
to DC labels and though simple, the evaluation in
Hails~\tocite{hails}, and our ability to implement diverse
applications with \sys{} supports this conjecture.
%
We further remark that \sys{} conceptually provides developers with
the ability to dynamically set CSP directives, and only share data
with browsing contexts if their directives impose a more strict
policy; with the increase usage of CSP, this minimizes the additional
knowledge developers need to pick up to set correct policies.
%
Nevertheless, we leave a more extensive analysis of policy
specification to future work.
 
Second, and more importantly, \sys{} only enforces latticed-based
policies, i.e., DC labels dictate where information can be
disseminated.
%
Although this captures a wide-set of policies, it does not capture all
possible confinement policies.
%
For instance, lattice-based policies are not suitable for scenarios in
which a circular flows of information is permitted~\cite{Badger:1995}.
%
Though we could have taken an approach, as in DCS~\cite{Akhawe2013},
to allow policies to be in the form of developer-provided code, we
believe that the trade-off for DC labels' simplicity---that of simply
specifying which origins are allowed to read a piece of
data---outweighs the ability to specify arbitrarily policies and the
accompanying complexities.


\subsection{Policy-granularity}

\sys{} associates a label with a compartment, or (informally) browsing
context.
%
This is in contrast to systems such as JSFlow~\cite{Hedin:2012} and
FlowFox~\cite{DeGroef:2012}, which, rely on fine-grained labeling.
%
Inspired by the HiStar~\tocite{histar} and
LIO~\tocite{lio} confinement systems, we took a coarse-grained
approach because of three core reasons.
%
Firstly, policies on the web are specified in terms of origins which
interact at the granularity of browsing contexts in the browser.
%
Hence, developers already compartmentalize applications at this
granularity---\sys{} simply provides developers with the stronger
guarantee of confinement.
%
Secondly, modifying the JavaScript engine (e.g.~\tocite{scriptpolice}),
providing an alternative interpreted engine (e.g.,~\cite{Hedin:2012}),
or executing content per security label (e.g.,~\cite{DeGroef:2012}) is
not practical, in the general case;
patches that have intrusive browser changes, especially to the
JavaScript engine,\footnote{
  Personal communication with SpiderMonkey and V8 developers.
} or introduce drastic performance degradations are typically rejected
by popular browsers such as Firefox and Chromium.
%
The goals of being minimally-intrusive, backwards compatible with the
existing Web, while still performant almost necessarily lends itself
to a coarse-grained design such \sys{}.
%
Thirdly, associating labels with individual DOM objects is error
prone and not scalable as it requires reasoning about the individual
side-effects of each property/method---reasoning about information
flow at the granularity of compartments is more straight forward,
especially since browsers already need to do so to enforce the SOP.

%% We implemented \sys{} in the browser layout engine (without
%% modifying the JavaScript engine), reusing existing security mechanisms
%% (e.g., CSP) to enforce confinement, while exposing the system in a
%% modular fashion as a new DOM API; 

However, the ability to associate labels with individual objects
simplifies the implementation of certain applications. 
%
For instance, JSFlow can associate a label with a password object
to ensure that potentially malicious code within the browsing context
cannot leak it arbitrarily.
%
In \sys{}, such fine-grained labeling requires restructuring the
application (as opposed to simply associating a label with an object)
%
Concretely, we must partition the application such that
heterogeneously labeled objects/DOM-elements are in separate labeled
workers or iframes.
%
For example, labeling a JavaScript password object would entail
placing this object in a separate labeled worker, while associating a
label with a password-input field would require a new iframe (to
render the element).
%
Though we believe that the expressively of \sys{} when compared to
fine-grained systems is comparable, the need for separate compartments
to hold differently-labeled data does affect
semantics~\cite{Ingram:2012}---specifically, it requires code interact
with the data asynchronously.


% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-default: "Make"
% End:

