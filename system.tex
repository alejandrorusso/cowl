\section{The \sys{} system}
\label{sec:system}

In \sys, every browsing context has an associated security \emph{label},
\emph{privilege}, and \emph{clearance}.
%
The label of the browsing context serves as a ``taint,'' indicating
the sensitivity of data the code executing within the context has
read.
%
Labels are specified in terms of \emph{principals}, which
correspond to origins, whose privacy is at stake.\footnote{
  We note that our system also handles integrity, or trust, which
  serves as the dual of privacy.
  %
  For simplicity of exposition we omit integrity from our discussion.
}
%
For example, the label
\js|Label("http://bank.ch").and("http://amazon.com")| specifies that
the context potentially contains data sensitive to \http{bank.ch}
\emph{and} \http{amazon.com}.
%
In turn, \sys{} uses the context label to confine code by restricting
writes---code in the context is restricted to communicating with other
browsing contexts (using \js|postMessage|) if their labels are at
least as restricting; without privileges, network communication and
local storage is not allowed since the effective labels of these
end-points are less restricting (end-point labels protect the privacy
of a single origin).

Privileges are objects with which code can assert the authority of
principals. 
%
In \sys, scripts are granted the privilege corresponding to the
page origin.\footnote{
More specifically, only \emph{privileged} scripts, as described in
Section~\ref{sec:system:script}, are granted the privilege of the page
origin.
}
For example, a script running in an \http{amazon.com} page has the
privilege of the origin, allowing it to declassify data sensitive to
\http{amazon.com}.
%
Specifically if the context label is
\js|Label("http://bank.ch").and("http://amazon.com")|, this privilege
can be used to downgrade the label to \js|Label("http://bank.ch")|
and, as a result, allow code to communicate with additional browsing
contexts and even perform network requests (to \http{bank.ch}).
%
Importantly, code cannot synthesize arbitrary privileges, e.g., for
\http{bank.ch}---this would trivially violate any confinement
guarantees;
%
in our system, code can only create the empty privilege
(\js|new Privilege()|) 
and privileges corresponding to fresh, unique principals/origins
(\js|new FreshPrivilege()|).

In ideal confinement systems, code can typically read arbitrary data
at the cost of raising its label and giving up write privileges.
%
Unfortunately, practical systems typically have covert channels which
may be exploitable.
%
Hence, as in HiStar~\tocite{histar} and Hails~\tocite{hails},
we use clearance to impose a limit on the kind of data a piece of code
can access.
%
Specifically, clearance serves as an upper bound on the context label,
code cannot read from or write to entities labeled ``above'' the
clearance.

In the rest of this section, we describe the \sys{} design through
three concrete examples: a password-strength checker
(Section~\ref{sec:system:worker}), a third-party mashup
(Section~\ref{sec:system:mashup}), a
password manager (Section~\ref{sec:system:iframe}), and an extension
that converts phone numbers to links
(Section~\ref{sec:system:script}).
%
For completeness, we summarize the different system components and
security mechanisms in Table~\toref{table:components}.



\subsection{Confining third-party DOM-less code}
\label{sec:system:worker}
%Password-strength checker: 

Password-strength checkers are common to many websites;
%
given a password, a checker computes the strength of the input,
according to some metric.
%
Naturally, when using a third-party password-strength checker
(e.g.,~\tocite{checker1, checker2}) we would like to ensure that the
code does not leak the user's password.
%
A malicious checker should at worst lie about the strength of a
password.

\paragraph{Current approach}
With server-side support and existing browser mechanisms, a page
(e.g., \http{instagra.me}) can incorporate and partially ``confine'' a
simple third-party strength checker (e.g.,
\http{checker.ru/checker.js}) that does not require DOM access.
%
To this end, \http{instagra.me} must host the checker source on a
trusted domain and execute the checker code in a Worker; since workers
have separate, fresh browsing contexts with no access to the page DOM,
this ensures that the password cannot be leaked by inserting images,
loading scripts, etc.
%
However, workers have access to the \xhr{} constructor and
\http{instagra.me} must, in turn, create the checker Worker object in
an iframe that has a CSP policy that restricts network communication
(e.g., \texttt{connect-src 'self'} if the checker source is hosted on
the same domain as the page incorporating it); this is necessary since
workers inherit the CSP policy of the owner document~\tocite{csp}.
%
We assume that the messaging layers between the Worker, the iframe
incorporating it, and main page are trivial.

Unfortunately, this approach is unsatisfactory due to four main reasons.
%
First, to avoid trusting the checker website, the checker source code
must be hosted by \http{instagra.me}, wherein a CSP policy can be used
to restrict the checker's communication capabilities. 
%
This need for server-side support is problematic for developers that
do not have server-side access to set such headers.
\Red{dherman put this very nicely; can we fish that sentence?}
%
Second, the fact that this requires server-side support to set
policies that restrict communication means that the password-checker
cannot incorporate code it itself does not trust.
%
Third, the CSP policy of the checker cannot be more restricting than
that of the owner document---hence, the checker can potentially carry
out a self-exfiltration attack and leak the password to a public page
on the trusted domain, \http{instagra.me}~\tocite{self-exfiltration}.
%
Finally, this approach cannot be used to confine a password
strength-checker that, for example, fetches a list of commonly used
passwords before checking the strength of the password---a completely
safe and useful operation.

\paragraph{\sys{} approach}
%
In part, the above limitations arise because existing browser
techniques do not allow developers to express confinement, event for
code that does not require DOM access.
%
Addressing these limitations, \sys{} allows developers to distinguish
between such code and confine it in turn.
%
Below we consider confining ``DOMless'' code; in
Sections~\ref{sec:system:iframe}-\ref{sec:system:script} we address
confinement of third-party code with access to the DOM.

Specifically, we extend the Worker DOM API~\tocite{workers} with a
Labeled worker (LWorker).
%
Like a standard Worker, an LWorker executes a piece of code in a fresh
browsing context that exposes a limited set of objects and properties.
%
Namely, we expose the \sys{} API (including the \js|LWorker|
constructor used to construct additional workers), the \xhr{}
constructor used to perform network requests, and
\js|onmessage|/\js|postMessage| used for communicating with the
parent.
%
Different from standard workers, the \js|LWorker| constructor takes an
additional argument: a label that specifies the clearance on the code
running in the worker browsing context.

For example, we can create a new LWorker that executes the
password-strength checker code as follows:
\begin{lstlisting}
var url = "http://checker.ru/checker.js";
var l = new Label(window.location.origin);
// 1. Execute checker in new context
var checker = new LWorker(url, l);
\end{lstlisting}
%
Assuming the browsing context (main page) creating the worker has not
enabled ``confinement-mode,'' \sys{} first enables this mode by
setting the page label to the public label (\js|Label()|).
%
Subsequently, we ensure that the current page is allowed to make an
anonymous\footnote{
  Since we allow LWorkers to execute inline scripts (via
  data-URLs~\tocite{blob}) that can be fetched with \xhr{}, workers
  scripts are fetched without sending sending user-credentials.
  This ensures that fetching the script effectively only constitutes a
  write: reading the source will not leak any user-sensitive from the
  provided URL.
} request to \js|url| to fetch the source code.
%
Assuming a public page label, \sys{} fetches the script and executes
it in the new browsing context, as shown in
Figure~\toref{fig:strength-1}

The LWorker starts executing the checker code with an initial label
equal to that of the parent (the public label \js|Label()|).
%
As shown in Figure~\toref{fig:strength-2}, at this point, the strength
checker may fetch data, such as a list of weak passwords, from the
same origin as the page, or any origins, CORS-permitting.
%
It is important to note that since the checker has not yet read any
sensitive data, as reflected by the context label, this is a
completely safe operation!

Since the goal of the page is to have the LWorker check the strength
of the password, it sends the checker the password with
\js|postMessage|, and registers a message handler to receive the
score:
\begin{lstlisting}
var password = 
 document.getElementById("password").value;
// 3. Send checker password 
checker.postMessage(password, l);
// 5. Get score
checker.onmessage = function(event) {
  var score = event.data; 
  // ...
}
\end{lstlisting}
Here, the \js|postMessage| takes a second argument: the label of the
message.
%
This ensures that the message is dispatched to the checker only ifs
context label is at least as sensitive as \js|l|---thereby ensuring
that the privacy of \http{instagra.me} is preserved by the checker.
%
Since this code ``owns'' the principal corresponding to the page
origin, we register the \js|onmessage| hander without needing to raise
the context label. If the page did not own said privilege it would
have to raise the context label to \js|l|---\sys{} would not otherwise
dispatch the handler, since data from the worker (which is at least as
sensitive as \js|l|) would be more sensitive than the context label
and thus a leak would incur.

In the LWorker, to retrieve the password, the checker must register a
message handler, which is invoked when the parent sends it a message:
\begin{lstlisting}
// checker.js ...
function checkPassword(pass) { /* ... */ }

// Browbound.label == Label()

// 2. Raise context label & register handler
Browbound.label = Brobound.clearance;
// ...label == Label("http://instagra.me")
onmessage = function(event) {
  var password = event.data;
  // 4. Check score & send it to parent:
  postMessage(checkPassword(password));
};
\end{lstlisting}
%
Here, the LWorker first raises the context label to the clearance.
%
In doing so, it is effectively stating that it's ready to receive data
at that sensitivity level, at the cost of giving up arbitrary network
communication privileges.
%
As shown in Figure~\toref{fig:strength-3}, it can now receive the
sensitive password, but it can only use \xhr{} to communicate with
\http{instagra.me}.
%
Hence, the checker registers an event handler which takes the
parent-supplied password and checks its strength with
\js|checkPassword|.
%
This result is then returned to the parent with \js|postMessage|.

The life-cycle of the this application is shown in
Figure~\toref{fig:system:strength}.
%
In this example we used we relied on the page having ownership of the
privilege corresponding to \http{instagra.me}.
%
Unfortunately, this also means that our confinement of the checker was
limited: we cannot confine the code with this label, while also
disallowing it from using \xhr{} to self-exfiltrate data to
\http{instagra.me}.
%
Hence, code can generate fresh privileges that correspond to a unique
principal/origin whose scheme, prefixed by \texttt{x-}, ensures that
code cannot communicate with.
%
By modifying the page code to first create such a privilege and use
the corresponding label when creating the LWorker, we can ensure that
no direct leaks through \xhr{} can occur.
%
This modified code is shown below.
\begin{lstlisting}
// Create fresh unique privilege
var p = new FreshPrivilege();
// Take ownership of this privilege
Browbound.own(p);
// Use it to confine the worker completely:
var checker = new LWorker(url, p.asLabel);
checker.postMessage(password, p.asLabel);
// ...
\end{lstlisting}
%

%
We remarks that, different from current approaches our system provides
a client-side approach for truly confining untrusted code: the strength
checker can perform arbitrary XHR until it raises its label to
register the password-message handler.
%
This is in contrast to either giving the checker irrevocable network
access or none at all.
%
Moreover, our first-class workers and privileges makes security a
first class citizen: not only can the page consider the checker
untrusted, but if the checker could itself create fresh privileges and
an LWorker in which it can execute code it itself does not consider
trustworthy!

\subsection{Cross-iframes confinement}
\label{sec:system:iframe}
%Password manager 

In the previous section, the \http{instagra.me} page imposed the
requirement that the password-strength checker, executing in an
LWorker, have a sufficiently high context label (such that it cannot
exfiltrate the password) before receiving the password.
%
More generally, our confinement mechanism allows developers to control
where their data flows, even once said data is made available to an
untrusted browsing context.
%
Below, we illustrate the notion of first-class confinement used
in building a mostly untrusted password manager.

\paragraph{Current approach}
%
Today's browser security mechanisms are not amendable for building a
password manager as a website.
%
Using existing mechanisms users are forced to either trust a password
manager website with their website-specific (e.g., \http{fb.com})
credentials or trust arbitrary websites (e.g., \http{fb.com}) with a
master password they use to protect other site-specific
credentials.\footnote{
  Without loss of generality, we assume client-side encryption where
  the credentials are decrypted by either the password manager or
  \http{fb.com}.
}
%
This issue of handling sensitive data is grave; insomuch, that all
major browsers ship with build-in password managers.
%
A built-in password manager simply requires the user to place more
trust on the browser, which they already trust to handle sensitive
data.
%
Unfortunately, such built-in apps also increases the TCB of the
browser.
%
Moreover, the approach does not scale; do we keep integrating apps
into the browser TCB simply because there exists no mechanism that
allows developers to express security policy on code that handles
sensitive data?





\subsection{Relaxing SOP for confined code}
\label{sec:system:mashup}
%Third-party Mashup

\subsection{Privilege separation within iframes}
\label{sec:system:script}
%Phone2Links extension
