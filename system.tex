\section{The \sys{} Confinement System}
\label{sec:system}

The COWL confinement system augments today's web browser with three
primitives, all of which appear in the simple password-checker
application example in Figure~\ref{fig:checker}.
% need to introduce "structural" primitives (ones that are visible in
% figures for example apps):
%
% labeled browsing contexts: in Figure 2. the central construct in
% COWL. they introduce MAC-based confinement to the browser. And they
% support hierarchical confinement, which is essential to allowing
% nesting of untrusted libraries (as described in section ...).

% privilege: in Figure 2 (though not used in example). in a MAC-based
% confinement system, certain operations are dangerous because
% untrusted code could use them to cause the release of sensitive
% information to unauthorized parties. for example, declassification
% of sensitive data strips the data's label, after which that data
% will not be confined within other compartments running potentially
% untrusted code that processes it. In COWL we term the authorization to execute
% such dangerous operations privilege, and express privilege in terms
% of origins.

% labeled communication: in Figure 2 (focus in that example chiefly on
% inter-context communication).  IPC between browsing contexts carries
% labeled data, so that when one compartment sends another sensitive
% data, it may confine the potentially untrusted code within the other
% compartment. This explicitly carrying of labels in IPC allows
% symmetric confinement, which is essential to building applications
% that compose scripts that are mutually distrusting, as described in
% section ....
%

{\em Labeled browsing contexts} enforce MAC-based confinement of
JavaScript at the granularity of a browsing context (e.g., a worker or
iframe). The rectangular frames in Figure~\ref{fig:checker} are
labeled browsing contexts. As contexts may be nested, labeled browsing
contexts allow hierarchical confinement, whose importance for
supporting nesting of untrusted libraries we discussed in
Section~\ref{sec:motivating-examples}. Throughout this paper, when
describing a COWL-enabled browser, we use the terms compartment,
browsing context, and labeled browsing context interchangeably.

When one browsing context sends sensitive information to another, {\em
  labeled communication} allows the sending context to confine the
potentially untrusted code within the receiving context. Explicitly
carrying labels in this fashion allows symmetric confinement, whose
importance in building applications that compose mutually distrusting
scripts we articulated in Section~\ref{sec:motivating-examples}. In
Figure~\ref{fig:checker}, the arrows between compartments indicate
labeled communication, where a subscript on the communicated data
denotes the data's label.

A MAC system must restrict access to certain operations whose abuse
would permit the release of sensitive information to unauthorized
parties. We refer to such access-controlled operations in COWL as
privileged, and the right to invoke them as a {\em privilege.} For
example, if a script {\em declassifies} messages it receives from
another context, it will retain the ability to do as it pleases with
the data received in those messages---i.e., the sending context will
not have confined the receiving context. One must trust the script
invoking a privileged operation like declassification not to abuse
it. In COWL we express privilege in terms of origins. The crown icon
in the left compartment in Figure~\ref{fig:checker} denotes that this
compartment may execute privileged operations on data labeled with the
origin {\tt fb.com}---more succinctly, that the compartment holds the
privilege for {\tt fb.com}. The compartment uses that privilege to
remain unconfined by declassifying the checker response labeled {\tt
  fb.com}.

We now describe these three constructs in greater detail.

% need to state that MAC system and all primitives related to it are
% opt-in (and somewhere, how the developer opts in--what is the
% incantation?). Point is that we coexist alongside status quo
% browser, so we don't break any existing pages. It may be that
% incremental deployability is important enough to articulate as a
% goal in section 2. (we can potentially footnote that in our prior
% workshop paper, we explored how to implement all of today's browser
% security primitives in COWL-like primitives---a clean-slate
% approach that subsumed and improved on the status quo. here we take
% the complementary approach of prioritizing backward compatibility
% with existing mechanisms.)


\subsection{Labeled Browsing Contexts}
\label{sec:system:contexts}
A COWL application consists of multiple labeled contexts.
%
Labeled contexts naturally extend today's browser contexts, used to
isolate iframes, pages, etc., with MAC \emph{labels}.
%
A context's label specifies the security policy for all data within
the context, which COWL enforces by restricting the flow of
information to and from other contexts and servers.
%% in addition to the restrictions imposed by existing DAC policies such
%% as the SOP.

As we have proposed previously~\cite{yang:2013:towards,
  stefan:2011:dclabels}, a label is a pair of boolean formulas: a
\emph{secrecy} formula specifying which origins may read a context's
data, and an \emph{integrity} formula specifying which origins may
write it.
%
For example, only Amazon or Chase may read data labeled
\dcLabel{\https{amazon.com} $\lor$
  \https{chase.com}}{\https{amazon.com}}, and only Amazon may modify
it.\footnote{$\lor$ and $\land$ denote disjunction and conjunction. A
  comma separates the secrecy and integrity formulas.}
%
Amazon could assign this label to its order history page to allow a
Chase-hosted mashup to read the user's purchases.
%
On the other hand, after a third-party mashup hosted by
\https{mint.com} (as described in
Section~\ref{sec:motivating-examples}) reads {\em both} the user's
Chase bank statement data {\em and} Amazon purchase data, the label on
data produced by the third-party mashup will be
\dcLabel{\https{amazon.com} $\land$
  \https{chase.com}}{\https{mint.com}}.
%
This secrecy label component specifies that the data may be sensitive
to both parties, and without both their consent (see
Section~\ref{sec:system:privileges}), should only be read by the user;
the integrity label component, on the other hand, permits only code
hosted by Mint to modify the resulting data.
 
COWL enforces label policies in MAC fashion by only allowing a context
to communicate with other contexts or servers whose labels are at
least as restricting. (A server's ``label'' is simply its origin.)
%
Intuitively, when a context wishes to send a message, the target must
not allow additional origins to read the data (preserving secrecy);
dually, the source context must not be writable by origins not
otherwise trusted by the target. That is, the source must be at least
as trustworthy as the target.
%
We say that such a target label ``subsumes'' the source
label.\footnote{ If communication is bidirectional, e.g., when a
  script accesses the DOM in a different context (but of the same
  origin), then both the target and source must subsume each other.}
%
For example, a context labeled
\dcLabel{\https{amazon.com}}{\https{mint.com}} can send messages to
one labeled \dcLabel{\https{amazon.com} $\land$
\https{chase.com}}{\https{mint.com}}, since the latter is trusted
to preserve the privacy of \https{amazon.com} (and
\https{chase.com}).
%
However, communication in the reverse direction is not possible since
it may violate the privacy of \https{chase.com}.
%
In the rest of this paper, we limit our discussion to secrecy and only
comment on integrity where relevant; we refer the interested reader
to~\cite{stefan:2011:dclabels} for a full description of the label
model.

A context can freely \emph{raise} its label, i.e., change its label to
any label that is more restricting, in order to receive a message
from an otherwise prohibited context.
%
Of course, in raising its label to read more sensitive data from
another context, the context also becomes more restricted in where it
can write.
%
For example, a Mint context labeled
\dcLabelS{\https{amazon.com}}{\https{mint.com}} can raise its label to
\dcLabelS{\https{amazon.com} $\land$
  \https{chase.com}}{\https{mint.com}} to read bank statements, but
only at the cost of giving up its ability to communicate with Amazon
(or, for that matter, any other) servers.
%
When creating a new context, code can impose an upper bound on the
context's label to ensure tha untrusted code cannot raise its label
and read data above this \emph{clearance}.
%
This notion of clearance is well
established~\cite{efstathopoulos:asbestos, Zeldovich:2006,
  stefan:2011:flexible, Breeze13}; we discuss its relevance to covert
channels in Section~\ref{sec:discussion}.

As noted, COWL allows a labeled context to create additional labeled contexts,
much like existing browsing contexts can create sub-compartments
in the form of iframes, workers, etc.
%
This functionality is crucial for compartmentalizing a system
hierarchically, where the developer places code of different degrees
of trustworthiness in separate contexts.
%
For example, in the password checker example in
Section~\ref{sec:motivating-examples}, we create a child context in
which we execute the untrusted checker script.
%
Importantly, however, code should not be able to leak information by
laundering data through a newly created context.
%
Hence, newly created contexts implicitly inherit the current label of
their parent.
%
When creating a child, however, a parent may specify an initial
current label for the child that is {\em more} restrictive than the
parent's, to confine the child further.
%
To ensure compatibility with pages written for the legacy SOP, a
COWL-enabled browser assigns a default label of public to top-level
contexts (i.e., to pages).
%
Finally, a web server can restrict browsing contexts by setting a
\js|COWL-label| HTTP response header, which dictates the minimal
document label the browser must enforce on the associated content.

COWL applications can create two types of context.
%
First, an application can create standard (but labeled) contexts in
the form of pages, iframes, workers, etc.
%
Indeed, it may do so because a COWL application is merely a regular
web application that additionally uses the COWL API. It thus is
confined by MAC, in addition to today's web security policies.
%
Note that to enforce MAC, COWL must mediate all pre-existing
communication channels---even subtle and implicit channels, such as
content loading---according to contexts' labels.
%
We describe how COWL does so in Section~\ref{sec:implementation}.

Second, a COWL application can create lightweight labeled contexts in
the form of \emph{labeled workers (LWorkers)}.
%
Like normal workers~\cite{workers}, the API exposed to LWorkers is
compact; its global only contains constructs for communicating with
the parent, the XHR constructor, and the COWL API.
%
Unlike normal workers, which execute in separate threads, an LWorker
executes in the same thread as its parent, sharing its event loop.
%
This sharing has the added benefit of allowing the parent to give the
child (labeled) access to its DOM, any access to which is treated as
both a read and a write, i.e., bidirectional communication.
%
Our third-party library example uses such a \emph{DOM worker} to
isolate the trusted application code, which requires access to the DOM
through the untrusted jQuery library.
%
In general, LWorkers---especially when given DOM access---simplify the
isolation and confinement of scripts (e.g., the password strength
checker) that would otherwise run in a shared context, as when loaded
with \js|<script>| tags.

\subsection{Labeled Communication}
\label{sec:system:communication}
Since COWL enforces a label check whenever a context sends a message,
the design described thus far is already symmetric: a source context
can confine a target context by raising its label (or a child
context's label) and thereafter send the desired message. To read this
message, the target context must confine itself by raising its label
accordingly. These semantics can make interactions between contexts
cumbersome, however. For example, a sending context may wish to
communicate with multiple target contexts, and need to confine those
target contexts with different labels, or even confine individual
messages to the same target context with different labels. And a
receiving context may wish to communicate unfetteredly with one or
more origins for a time before losing the ability to do so once it
raises its label to receive a message. In the password-checker example
application, the untrusted checker script at the right of
Figure~\ref{fig:checker} exhibits exactly this latter behavior: it
needs to communicate with untrusted remote origin {\tt sketchy.ru}
before reading the password labeled {\tt fb.com}.

%% %
%% Unfortunately, this approach of (ab)using the context label to impose
%% restrictions on a target context is cumbersome.
%% %
%% (Consider the case where a context wishes to impose different
%% restrictions according to the message or target context.)

\paragraph{Labeled Blob Messages (Intra-Browser)}
To simplify communication with confinement, we introduce the {\em
  labeled Blob,} which binds together the payload of an individual
inter-context message with the label protecting it. The payload takes
the form of a serialized immutable object of type Blob~\cite{html5}.
Encapsulating the label with the message avoids the cumbersome label
raisings heretofore necessary in both sending and receiving contexts
before a message may even be sent or received. Instead, COWL allows
the developer sending a message from a context to specify the label to
be attached to a labeled Blob; any label more restrictive than the
sending context's current label may be specified. While the receiving
context may receive a labeled Blob with no immediate effect on the
origins with which it can communicate, it may only inspect the label,
but not the payload. Only after raising its label as needed may the
receiving context read the payload.
%
%% A labeled Blob encapsulates a serialized immutable object, of type
%% Blob~\cite{html5}, and the label protecting it.
%
%% Since messages between contexts must be serializable objects, labeled
%% Blobs can be used to associate explicit labels with messages.
%
%% Unsurprisingly, these ``labeled messages'' can be sent from one
%% context to another.
%
%% When doing so, COWL does not impose any more restrictions than those of
%% Section~\ref{sec:system:contexts}.
%% %
%% Importantly, however, a receiving context cannot arbitrarily inspect
%% such labeled messages;
%% %
%% until the message is ``unlabeled'' and the context label is raised to
%% subsume the blob label, the received labeled message is mostly opaque:
%% the receiving context can only inspect its label.

Labeled Blobs simplify building applications that incorporate distrust
among contexts. Not only can a sender impose confinement on a receiver
simply by labeling a message; a receiver can delay inspecting a
sensitive message until it has completed communication with untrusted
origins (as does the checker script in Figure~\ref{fig:checker}). They
also ease the implementation of integrity in applications, as they
allow a context that is not trusted to modify content in some other
context to serve as a passive conduit for a message from a third
context that {\em is} so trusted.
%
%% For example, a sender can impose confinement restrictions on a
%% receiver by simply labeling a message.
%
%% Since the label of the message can be above the sender's context label
%% this alleviates the need for the sender to raise its label only to
%% impose restrictions on the receiver.
%
%% (Indeed, when creating a labeled Blob, the specified label \emph{must}
%% be at least as restricting as the current context label.)
%
%% Equally important, the receiver can delay inspecting a sensitive
%% message until it is ready to raise its label and be more restricted in
%% where it can write.
%
%% (Or alternatively, it can serve as an intermediary and pass the
%% labeled Blob to yet another context, a pattern we found useful when
%% considering ``high'' integrity message.)
%
%% For example, in the password checker example of
%% Section~\ref{sec:motivating-examples} we label the password
%% \https{fb.com} before sending it to the untrusted checker.
%% %
%% The latter has the flexibility of communicating arbitrarily until it
%% unlabels the password, at which point it will be constrained to
%% sending messages to its parent.

\paragraph{Labeled XHR Messages (Browser--Server)}
\label{sec:system:labeled-xhr}
Thus far we have focused on confinement as it arises when two browser
contexts communicate. Confinement is of use in browser-server
communication, too. As noted in Section~\ref{sec:system:contexts},
COWL only allows a context to communicate with a server (whether with
XHR, retrieving an image, or otherwise) when the server's origin
subsumes the context's label. Upon receiving a request, a COWL-aware
web server may also wish to know the current label of the context that
initiated it. For this reason, COWL attaches the current label to
every request the browser sends to a server.\footnote{COWL also
  attaches the current privilege; Section~\ref{sec:system:privileges}
  describes COWL's privilege primitive.} As also noted in
Section~\ref{sec:system:contexts}, a COWL-aware web server may elect
to label a response it sends the client by including a \js|COWL-label|
header on it. In such cases, the COWL-aware browser will only allow
the receiving context to read the response if its current label
subsumes that on the response.

%% The ability of a context to impose confinement restrictions on
%% another naturally extends to servers, when using the XHR constructor.
%% % 
%% Traditionally, an XHR request is composed of two parts: a write to an
%% external origin (sending the request), and then a read from the external
%% origin (reading the response, which is restricted according to the
%% SOP).
%% %
%% Before initiating a request, COWL, however, also checks to see
%% if the label of the origin subsumes the label of context. 
%% %
%% Since COWL-enabled servers may be interested in the current label of
%% the context which initiated the request, we send this (and a
%% description of the context privileges) with every request.
%
%% Similarly, when reading the response, we check to see if the label of
%% the context subsumes the label of the response, which may be
%% explicitly set with the \js|COWL-label| header.
%% %

Here, again, a context that receives labeled data---in this case from
a server---may wish to defer raising its label until after it has
completed communication with other remote origins. To give a context
this freedom, COWL supports {\em labeled XHR} communication. Rather
than invoking the standard XHR constructor, a script can invoke COWL's
labeled XHR constructor, which specifies that the response should be
delivered to the initiating script as a labeled Blob. Just as with
labeled Blob intra-browser IPC, the script is then free to delay
raising its label to read the payload of the response---and being
confined---until after it has completed its other remote
communication.
%% While the server can set the response label (with the \js|COWL-label|)
%% to ensure that the context can only inspect the response if it is
%% appropriately confined, the client can decide to delay this decision by
%% setting the response type---when opening the connection---to
%% \js|labeled-blob|.
%% %
%% As with inter-context labeled communication, the returned response
%% of this \emph{labeled XHR} constructor is a labeled Blob (whose label
%% is specified by the \js|COWL-label| header).
%% %
%% This flexibly allows the application to delay the inspection of a
%% sensitive response, which would confine it.
%
For example, in the third-party mashup example, Mint only confines
itself once it has received all necessary (labeled) responses from
both Amazon and Chase. At this point it processes the data and
displays results to the user, but it can no longer send requests since
doing so may leak information.\footnote{To continuously process data
  in ``streaming'' fashion, one may partition the application into
  contexts that poll Amazon and Chase's servers for new data and pass
  labeled responses to the confined context that processes the
  payloads of the responses.}

\Red{bk: Lock on the rest of 3.2; significant changes underway...}

We note that COWL's introduction of labeled XHR composes usefully with
CORS. Today's CORS policies are DAC-only, such that a server must
either allow another origin to read its data, and fully trust that
origin not to disclose the data, or deny the other origin access to
the data altogether. Under COWL, however, a server could
CORS-whitelist a foreign origin to permit that origin to read its
data, and by setting a label on its response, be safe in the knowledge
that COWL would appropriately confine the foreign origin's scripts in
the browser. For example, Chase could expose a read-only bank
statement HTTP API that whitelists known applications' origins, such
as \https{mint.com}, but sets MAC labels on responses. Here, Chase
need not trust Mint to write bug-free code---COWL confines the Mint
code to ensure that it cannot arbitrarily leak bank statements. As we
discuss in Section~\ref{sec:discussion}, however, a malicious Mint
application could potentially leak data through covert channels. We
stress that COWL nevertheless offers a significant improvement over
the status quo, in which users give their login credentials to Mint,
and thus not only trust Mint to keep their bank statements
confidential, but also not to steal their funds! \Red{bk: this
  paragraph feels like it is more discussion than design. No? Litmus
  test: what construct is being introduced?}

%% With MAC in place, we envision that there are scenarios in which web
%% servers would share resources by setting more flexible CORS policies, but
%% only do so if the client to be appropriately confined.
%% %
%% For instance, 
%
%% This is appealing because it allows a server to share resources
%% without completely trusting the white-listed cross-origin.
%
%
%% Of course, and as discussed in Section~\ref{sec:discussion}, a malicious
%% Mint application can leak data through covert channels.
%
%% Nevertheless, this improves the state of affairs where users give up
%% their credentials and place complete trust in Mint---not only to keep
%% their bank statements confidential, but also from stealing their
%% funds.

The operator of a server that provides useful data to mashup
applications cannot be expected to know all applications users may
wish to use. A user might prefer the niche \https{gekko-cash.com}
application to the \https{mint.com} one. If Chase doesn't
CORS-whitelist the lesser-known application's origin, the user will
still face today's unpalatable choice between functionality and
privacy. Note that in a COWL-enabled browser, however, it is safe to
relax the CORS policy to allow a foreign origin to read Chase's data,
{\em so long as} Chase's responses are labeled---in which case COWL
will confine any script that reads them. COWL thus allows a user to
configure her browser to effectively add additional foreign origins to
those whitelisted (if any) in the CORS policy returned by an origin's
web server. For example, the user can configure her COWL-enabled
browser to allow \https{gekko-cash.com} to read data from the
\https{chase.com} origin. If the server labels its response label,
COWL confines the context that reads the response accordingly.
Otherwise, COWL assumes that the server is not COWL-enabled and labels
the response with a \emph{unique} origin (as described in
Section~\ref{sec:system:privileges}). Doing so ensures that once the
response has been inspected the code cannot communicate with
\emph{any} server, including that at \emph{same} origin (e.g.,
\https{chase.com}), since such requests carry the risks of
self-exfiltration~\cite{selfex} and cross-site request
forgery~\cite{CSRF}.

%% overrides of web sites' CORS
%% policies

%% Since trust varies between users, a server cannot be expected to use
%% CORS white-lists (beyond a handful of reputable domains) to
%% accommodate everybody.  For example, a user may wish to use a
%% lesser-known mashup, \https{wutang-financial.com}, instead of
%% \https{mint.com}; unless Chase white-lists this domain (maybe at the
%% user's request), the user is, again, forced to decide between giving
%% up their privacy (credentials) and using the service.  Intuitively,
%% however, it is safe relax the CORS policy to allow cross-origin code
%% to read the result of a response, as long as it is confined
%% thereafter.  Hence, COWL allows users to override the default CORS
%% policy of a website (if there is any) to white-list origins they
%% trust.  For example, the user can white-list
%% \https{wutang-financial.com} to read cross-origin data from
%% \https{chase.com}.  Importantly, however, all such cross-origin
%% responses must be labeled.  (We call this feature labeled CORS
%% (LCORS).) 
%% %
%% A server that is protected against self-exfiltration and cross-site
%% request forgery using end-to-end labels can relax this requirement by
%% supplying a less restricting label.


\subsection{Privileges}
\label{sec:system:privileges}

COWL provides every context with unforgeable objects called
\emph{privileges} with which code can assert authority over
origins.
%
Privileges are used to allow flows otherwise not permitted by COWL's
label checks.
%
For example, code executing on behalf of \https{nsa.gov} with a
current label \dcLabelS{\https{nsa.gov} $\land$ \https{gdoc.com}}{}
is allowed to send messages to a context labeled
\dcLabelS{\https{gdoc.com}}{}.
%
Without the \https{nsa.gov} privilege this flow would not be
allowed since it may be leaking NSA information to Google.
%
Indeed by using privileges NSA is declassifying the message, i.e., it
no longer considers it sensitive (since, for instance, it may be
encrypted).
%
Similarly, code can declassify information when unlabeling messages.
%
For example, Facebook leverages the \https{fb.com} privilege to
declassify the password strength result, labeled with its origin, to
avoid raising its label to \https{fb.com}.
%
Alternatively it would need to use the privilege to lower its current
label.

In COWL, privileges are \emph{implicitly} exercised: if a context
has a privilege, code will always attempt to use it.
%
While the alternative approach of requiring privileges to be exercised
explicitly (e.g., when sending messages) may be safer~\tocite{histar,
lio}, we found this to over-complicate existing asynchronous web
APIs.\footnote{
  Exposing a new set of communication primitives would simplify this,
  but one our goals with COWL is not change the programming model web
  developers have grown accustomed to.
}
%
Instead, COWL gives code control over the use of privileges by
allowing it to get and set the underlying context privileges.
%
(Code can drop privileges by setting the context privileges to
\js|null|.)
%
This is useful, for example, when confining a context that contains
(intrusive) untrusted libraries such as jQuery; here, we drop the
context privilege to ensure that jQuery cannot act on behalf of the
origin and arbitrarily leak data.
%
Equally important, COWL allows a context to grant its privileges (or a
subset of its privileges) to another.
%
In the jQuery example, the application also creates a child context
to which it grants its privileges before loading jQuery; this allows
the context to act on behalf of the origin while the main browing
context is confined.
%
With these capabilities we can additionally provide a programming
model wherein privileges must be explicitly exercised as a library
that wraps functions, such as \js|postMessage|, which sets and drops
privileges appropriately.

%% %%XXX(ds): MOVE to implementation:
%% For example, our implementation modifies existing browsing contexts to
%% mediate:
%% %
%% \js|postMessage|,
%% same-origin cross-compartment DOM object access,
%% content loading (via {\tt img} tags, CSS, etc.),
%% form submission,
%% use of the \js|XMLHttpRequest| object,
%% navigation, and
%% browser storage (cookies and local storage).



% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-default: "Make"
% End:

