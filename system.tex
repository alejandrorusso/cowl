\section{The \sys{} Confinement System}
\label{sec:system}

The COWL confinement system augments today's web browser with three
primitives, all of which appear in the simple password-checker
application example in Figure~\ref{fig:checker}.
% need to introduce "structural" primitives (ones that are visible in
% figures for example apps):
%
% labeled browsing contexts: in Figure 2. the central construct in
% COWL. they introduce MAC-based confinement to the browser. And they
% support hierarchical confinement, which is essential to allowing
% nesting of untrusted libraries (as described in section ...).

% privilege: in Figure 2 (though not used in example). in a MAC-based
% confinement system, certain operations are dangerous because
% untrusted code could use them to cause the release of sensitive
% information to unauthorized parties. for example, declassification
% of sensitive data strips the data's label, after which that data
% will not be confined within other compartments running potentially
% untrusted code that processes it. In COWL we term the authorization to execute
% such dangerous operations privilege, and express privilege in terms
% of origins.

% labeled communication: in Figure 2 (focus in that example chiefly on
% inter-context communication).  IPC between browsing contexts carries
% labeled data, so that when one compartment sends another sensitive
% data, it may confine the potentially untrusted code within the other
% compartment. This explicitly carrying of labels in IPC allows
% symmetric confinement, which is essential to building applications
% that compose scripts that are mutually distrusting, as described in
% section ....
%

{\em Labeled browsing contexts} enforce MAC-based confinement of
  JavaScript at the granularity of a browsing context (e.g., a worker
  or iframe). The rectangular frames in Figure~\ref{fig:checker} are
  labeled browsing contexts. As contexts may be nested, labeled
  browsing contexts allow hierarchical confinement, whose importance
  for supporting nesting of untrusted libraries we discussed in
  Section~\ref{sec:motivating-examples}. Throughout this paper, when describing a
  COWL-enabled browser, we use the terms compartment, browsing
  context, and labeled browsing context interchangeably.

When one browsing context sends sensitive information to
  another, {\em labeled communication} allows the sending context to
  confine the potentially untrusted code within the receiving
  context. Explicitly carrying labels in this fashion allows symmetric
  confinement, whose importance in building applications that compose
  mutually distrusting scripts we articulated in
  Section~\ref{sec:motivating-examples}. In Figure~\ref{fig:checker},
  the arrows between compartments indicate labeled communication,
  where a subscript on the communicated data denotes the data's label.

  A labeled browsing context may be granted one or more {\em
    privileges.} A privilege authorizes scripts within a context to
  execute certain operations whose abuse would permit the release of
  sensitive information to unauthorized parties. For example, a script
  can use its privileges to {\em declassify} messages it receives from
  another context to avoid being overly-confined. In COWL we express
  privilege in terms of origins. The crown icon in the left
  compartment in Figure~\ref{fig:checker} denotes that this
  compartment holds the privilege to execute these certain operations
  on data labeled with the origin {\tt fb.com}. (In this example, the
  {\tt fb.com} compartment uses its privilege to remain unconstrained
  by declassifying the checker response labeled {\tt fb.com}.)


We now describe these three constructs in greater detail.

% need to state that MAC system and all primitives related to it are
% opt-in (and somewhere, how the developer opts in--what is the
% incantation?). Point is that we coexist alongside status quo
% browser, so we don't break any existing pages. It may be that
% incremental deployability is important enough to articulate as a
% goal in section 2. (we can potentially footnote that in our prior
% workshop paper, we explored how to implement all of today's browser
% security primitives in COWL-like primitives---a clean-slate
% approach that subsumed and improved on the status quo. here we take
% the complementary approach of prioritizing backward compatibility
% with existing mechanisms.)


\subsection{Labeled Browsing Contexts}
\label{sec:system:contexts}
COWL applications are partitioned into multiple labeled contexts.
%
Labeled contexts naturally extend existing browser contexts (which
are used to isolate iframes, pages, etc.) with MAC \emph{labels}.
%
The context label is the security policy on all the data within the
context, which COWL enforces by restricting the flow of information
to/from other contexts and servers.
%% in addition to the restrictions imposed by existing DAC policies such
%% as the SOP.

Following~\cite{yang:2013:towards, stefan:2011:dclabels}, a label is a
pair of boolean formulas: a \emph{secrecy} formula specifying which
origins are allowed to read the data, and an \emph{integrity} formula
specifying which origins can write it.
%
For example, data labeled \dcLabel{\https{amazon.com} $\lor$
\https{chase.com}}{\https{amazon.com}}
can be only read by Amazon or Chase, and modified by Amazon.
%
Amazon may use this label to allow a Chase mashup to read
user purchases.
%
On the other hand, the label on data produced by the third-party
mashup integrator of Section~\ref{sec:motivating-examples} after
reading the purchases and statements will be
\dcLabel{\https{amazon.com} $\land$
\https{chase.com}}{\https{mint.com}}.
%
The secrecy component specifies that the data may be sensitive to both
parties, and without their consent (see
Section~\ref{sec:system:privileges}), can only be read by the user;
the integrity component, on the other hand, restricts Mint code to
modifying the results.
 
COWL enforces label policies in a mandatory fashion by only allowing a
context to communicate with other contexts or servers whose labels are
at least as restricting.
%
Intuitively, when a context wishes to send a message, the target must
not allow additional origins to read the data (preserving secrecy);
dually, the source context must not be writable by origins not
otherwise trusted by the target, i.e., the source must be at least as
trustworthy as the target.
%
We say the target label ``subsumes'' the source label.\footnote{
  If the communication is bidirectional, e.g., accessing a
cross-context (but same-iring) DOM, then both the target and source
must subsume each other.}
%
For example, a context labeled
\dcLabel{\https{amazon.com}}{\https{mint.com}} can send messages to
one labeled \dcLabel{\https{amazon.com} $\land$
\https{chase.com}}{\https{mint.com}}, since the latter is guaranteed
to preserves the privacy of \https{amazon.com} (and
\https{chase.com}).
%
However, communication in the inverse direction is not possible since
the privacy of \https{chase.com} may be violated.
%
In the rest of the paper, we limit our discussion to secrecy and only
comment on integrity where relevant; the interested reader is referred
to~\cite{stefan:2011:dclabels} for a complete description of the label
model.

A context can freely \emph{raise} its label, i.e., change its label to
any label that is more restricting, in order to receive message
from otherwise prohibited contexts.
%
Of course, in raising its label to read more sensitive data (from
another context) the context is also more restricted in where it can
write.
%
For example, a Mint context labeled
\dcLabelS{\https{amazon.com}}{\https{mint.com}} can raise its label to
\dcLabelS{\https{amazon.com} $\land$
\https{chase.com}}{\https{mint.com}} to read bank statements; of
course, this is at the cost of giving up its ability to communicate
with Amazon (or, for that matter, any other) servers.
%
When creating a new context, code can impose an upper-bound
on the context label to ensure the untrusted code cannot raise it
label and read data above this \emph{clearance}.
%
Since our notion of clearance is
standard~\cite{efstathopoulos:asbestos, Zeldovich:2006,
stefan:2011:flexible, Breeze13}, our brief treatment of it is limited
to Section~\ref{sec:discussion}, where we discuss covert channels.

As noted, COWL allows a labeled context to create additional labeled contexts,
much like existing browsing contexts can create sub-compartments
in the form of iframes, workers, etc.
%
This is crucial for compartmentalizing a system in a hierarchical
fashion, where code of different trustworthiness is placed in
a separate context.
%
For example, in the password checker example of
Section~\ref{sec:motivating-examples} we create a child context in
which we execute the untrusted checker script.
%
Importantly, however, code should not be able to leak information by
laundering data through a newly created context.
%
Hence, newly created contexts implicitly inherit the current label of
their parent.
%
(For backwards compatibility with the SOP, the initial label of a
top-level context, i.e., a page, is public.) 
%
COWL, however, allows the parent to override this and specify---at
creation time---the child's initial current label (which must be at
least as restricting as the parent's label) to confine it further.

There are two kinds of contexts that COWL applications can create.
%
First, an application can create standard (but labeled) contexts in
the form of pages, iframes, workers, etc.
%
Indeed, this is possible because COWL applications are just regular
web applications that additionally use the COWL API and abide by MAC,
in addition to existing web security policies.
%
Importantly, to enforce MAC, COWL must mediate all the pre-existing
communication channels---even subtle and implicit channels, such as
content loading---according to the context label.
%
In Section~\ref{sec:implementation} we describe how COWL does this.

Second, COWL applications can create light-weight labeled contexts
in the form of \emph{labeled workers (LWorkers)}.
%
Like normal workers~\cite{workers}, the API exposed to LWorkers is
minimal; its global only contains constructs for communicating
with the parent, the XHR constructor, and the COWL API.
%
Unlike normal workers, which execute in separate threads, an LWorker
executes in the same thread as its parent, sharing the event loop.
%
This has the added benefit of allowing the parent to give the child
(labeled) access to its DOM, any access of which is treated as both a
read and a write, i.e., bidirectional communication.
%
Such a ``DOM worker'' is used by our third-party library example to
isolate the trusted application code, which requires access to the
DOM, form the untrusted jQuery library.
%
In general, LWorkers, especially when given DOM access, simplify the
isolation and confinement of scripts (e.g. the password strength
checker) which would otherwise run in a shared context, as loaded with
\js|<script>| tags.


\subsection{Labeled Communication}
\label{sec:system:communication}
Since COWL always enforces a label check when a context sends
messages, the design described thus far is already symmetric: a source
context can impose restrictions on a target context by raising its
label (or the label of a child context) and only then send the desired
messages; to read the messages, the target context must confine itself
by raising the context label.
%
Unfortunately, this approach of (ab)using the context label to impose
restrictions on a target context is cumbersome.
%
(Consider the case where a context wishes to impose different
restrictions according to the message or target context.)

To address this issue, COWL allows code to heterogeneously label
messages using labeled Blobs.
%
A labeled Blob encapsulates a serialized immutable object, of type
Blob~\cite{html5}, and the label protecting it.
%
Since messages between contexts must be serializable objects, labeled
Blobs can be used to associate explicit labels with messages.
%
Unsurprisingly, these ``labeled messages'' can be sent from one
context to another.
%
When doing so, COWL does not impose any more restrictions than those of
Section~\ref{sec:system:contexts}.
%
Importantly, however, a receiving context cannot arbitrarily inspect
such labeled messages;
%
until the message is ``unlabeled'' and the context label is raised to
subsume the blob label, the received labeled message is mostly opaque:
the receiving context can only inspect its label.

While simple, labeled Blobs are very useful in building applications
with (mutual) distrust.
%
For example, a sender can impose confinement restrictions on a
receiver by simply labeling a message.
%
Since the label of the message can be above the sender's context label
this alleviates the need for the sender to raise its label only to
impose restrictions on the receiver.
%
(Indeed, when creating a labeled Blob the specified label must be at
least as restricting as the current context label.)
%
Importantly, the receiver can delay inspecting a sensitive message
until it is ready to raise its label and be more restricted in where
it can write.
%
For example, in the password checker example of
Section~\ref{sec:motivating-examples} we label the password
\https{fb.com} before sending it to the untrusted checker.
%
The latter has the flexibility of communicating arbitrarily until
it unlabels the password, at which point it will it be constrained to
sending messages to its parent.



\paragraph{LabeledXHR}

- 

Tie back to third-party mashup example.

\subsection{Privileges}
\label{sec:system:privileges}
Relate to declassification and delegation.


%% %%XXX(ds): MOVE to implementation:
%% For example, our implementation modifies existing browsing contexts to
%% mediate:
%% %
%% \js|postMessage|,
%% same-origin cross-compartment DOM object access,
%% content loading (via {\tt img} tags, CSS, etc.),
%% form submission,
%% use of the \js|XMLHttpRequest| object,
%% navigation, and
%% browser storage (cookies and local storage).



% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-default: "Make"
% End:

