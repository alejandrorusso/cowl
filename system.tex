\section{The \sys{} Confinement System}
\label{sec:system}

The COWL confinement system augments today's web browser with three
primitives, all of which appear in the simple password-checker
application example in Figure~\ref{fig:checker}.
% need to introduce "structural" primitives (ones that are visible in
% figures for example apps):
%
% labeled browsing contexts: in Figure 2. the central construct in
% COWL. they introduce MAC-based confinement to the browser. And they
% support hierarchical confinement, which is essential to allowing
% nesting of untrusted libraries (as described in section ...).

% privilege: in Figure 2 (though not used in example). in a MAC-based
% confinement system, certain operations are dangerous because
% untrusted code could use them to cause the release of sensitive
% information to unauthorized parties. for example, declassification
% of sensitive data strips the data's label, after which that data
% will not be confined within other compartments running potentially
% untrusted code that processes it. In COWL we term the authorization to execute
% such dangerous operations privilege, and express privilege in terms
% of origins.

% labeled communication: in Figure 2 (focus in that example chiefly on
% inter-context communication).  IPC between browsing contexts carries
% labeled data, so that when one compartment sends another sensitive
% data, it may confine the potentially untrusted code within the other
% compartment. This explicitly carrying of labels in IPC allows
% symmetric confinement, which is essential to building applications
% that compose scripts that are mutually distrusting, as described in
% section ....
%

{\em Labeled browsing contexts} enforce MAC-based confinement of
JavaScript at the granularity of a browsing context (e.g., a worker or
iframe). The rectangular frames in Figure~\ref{fig:checker} are
labeled browsing contexts. As contexts may be nested, labeled browsing
contexts allow hierarchical confinement, whose importance for
supporting nesting of untrusted libraries we discussed in
Section~\ref{sec:motivating-examples}. Throughout this paper, when
describing a COWL-enabled browser, we use the terms compartment,
browsing context, and labeled browsing context interchangeably.

When one browsing context sends sensitive information to another, {\em
  labeled communication} allows the sending context to confine the
potentially untrusted code within the receiving context. Explicitly
carrying labels in this fashion allows symmetric confinement, whose
importance in building applications that compose mutually distrusting
scripts we articulated in Section~\ref{sec:motivating-examples}. In
Figure~\ref{fig:checker}, the arrows between compartments indicate
labeled communication, where a subscript on the communicated data
denotes the data's label.

A MAC system must restrict access to certain operations whose abuse
would permit the release of sensitive information to authorized
parties. We refer to such access-controlled operations in COWL as
privileged, and the right to invoke them as a {\em privilege.} For
example, if a script {\em declassifies} messages it receives from
another context, it will retain the ability to do as it pleases with
the data received in those messages---i.e., the sending context will
not have confined the receiving context. One must trust the script
invoking a privileged operation like declassification not to abuse
it. In COWL we express privilege in terms of origins. The crown icon
in the left compartment in Figure~\ref{fig:checker} denotes that this
compartment may execute privileged operations on data labeled with the
origin {\tt fb.com}---more succinctly, that the compartment holds the
privilege for {\tt fb.com}. The compartment uses that privilege to
remain unconfined by declassifying the checker response labeled {\tt
  fb.com}.

We now describe these three constructs in greater detail.

% need to state that MAC system and all primitives related to it are
% opt-in (and somewhere, how the developer opts in--what is the
% incantation?). Point is that we coexist alongside status quo
% browser, so we don't break any existing pages. It may be that
% incremental deployability is important enough to articulate as a
% goal in section 2. (we can potentially footnote that in our prior
% workshop paper, we explored how to implement all of today's browser
% security primitives in COWL-like primitives---a clean-slate
% approach that subsumed and improved on the status quo. here we take
% the complementary approach of prioritizing backward compatibility
% with existing mechanisms.)


\subsection{Labeled Browsing Contexts}
\label{sec:system:contexts}
A COWL application consists of multiple labeled contexts.
%
Labeled contexts naturally extend today's browser contexts, used to
isolate iframes, pages, etc., with MAC \emph{labels}.
%
A context's label specifies the security policy for all data within
the context, which COWL enforces by restricting the flow of
information to and from other contexts and servers.
%% in addition to the restrictions imposed by existing DAC policies such
%% as the SOP.

As we have proposed previously~\cite{yang:2013:towards,
  stefan:2011:dclabels}, a label is a pair of boolean formulas: a
\emph{secrecy} formula specifying which origins may read a context's
data, and an \emph{integrity} formula specifying which origins may
write it.
%
For example, only Amazon or Chase may read data labeled
\dcLabel{\https{amazon.com} $\lor$
  \https{chase.com}}{\https{amazon.com}}, and only Amazon may modify
it.\footnote{$\lor$ and $\land$ denote disjunction and conjunction. A
  comma separates the secrecy and integrity formulas.}
%
Amazon could assign this label to its order history page to allow a
Chase-hosted mashup to read the user's purchases.
%
On the other hand, after a third-party mashup hosted by
\https{mint.com} (as described in
Section~\ref{sec:motivating-examples}) reads {\em both} the user's
Chase bank statement data {\em and} Amazon purchase data, the label on
data produced by the third-party mashup will be
\dcLabel{\https{amazon.com} $\land$
  \https{chase.com}}{\https{mint.com}}.
%
This secrecy label component specifies that the data may be sensitive
to both parties, and without both their consent (see
Section~\ref{sec:system:privileges}), should only be read by the user;
the integrity label component, on the other hand, permits only code
hosted by Mint to modify the resulting data.
 
COWL enforces label policies in MAC fashion by only allowing a context
to communicate with other contexts or servers whose labels are at
least as restricting.
%
Intuitively, when a context wishes to send a message, the target must
not allow additional origins to read the data (preserving secrecy);
dually, the source context must not be writable by origins not
otherwise trusted by the target. That is, the source must be at least
as trustworthy as the target.
%
We say that such a target label ``subsumes'' the source
label.\footnote{ If communication is bidirectional, e.g., when a
  script accesses the DOM in a different context (but of the same
  origin), then both the target and source must subsume each other.}
%
For example, a context labeled
\dcLabel{\https{amazon.com}}{\https{mint.com}} can send messages to
one labeled \dcLabel{\https{amazon.com} $\land$
\https{chase.com}}{\https{mint.com}}, since the latter is trusted
to preserve the privacy of \https{amazon.com} (and
\https{chase.com}).
%
However, communication in the reverse direction is not possible since
it may violate the privacy of \https{chase.com}.
%
In the rest of this paper, we limit our discussion to secrecy and only
comment on integrity where relevant; we refer the interested reader
to~\cite{stefan:2011:dclabels} for a full description of the label
model.

A context can freely \emph{raise} its label, i.e., change its label to
any label that is more restricting, in order to receive a message
from an otherwise prohibited context.
%
Of course, in raising its label to read more sensitive data from
another context, the context also becomes more restricted in where it
can write.
%
For example, a Mint context labeled
\dcLabelS{\https{amazon.com}}{\https{mint.com}} can raise its label to
\dcLabelS{\https{amazon.com} $\land$
  \https{chase.com}}{\https{mint.com}} to read bank statements, but
only at the cost of giving up its ability to communicate with Amazon
(or, for that matter, any other) servers.
%
When creating a new context, code can impose an upper bound on the
context's label to ensure tha untrusted code cannot raise its label
and read data above this \emph{clearance}.
%
This notion of clearance is well
established~\cite{efstathopoulos:asbestos, Zeldovich:2006,
  stefan:2011:flexible, Breeze13}; we discuss its relevance to covert
channels in Section~\ref{sec:discussion}.

As noted, COWL allows a labeled context to create additional labeled contexts,
much like existing browsing contexts can create sub-compartments
in the form of iframes, workers, etc.
%
This functionality is crucial for compartmentalizing a system
hierarchically, where the developer places code of different degrees
of trustworthiness in separate contexts.
%
For example, in the password checker example in
Section~\ref{sec:motivating-examples}, we create a child context in
which we execute the untrusted checker script.
%
Importantly, however, code should not be able to leak information by
laundering data through a newly created context.
%
Hence, newly created contexts implicitly inherit the current label of
their parent.
%
When creating a child, however, a parent may specify an initial
current label for the child that is {\em more} restrictive than the
parent's, to confine the child further.
%
To ensure compatibility with pages written for the legacy SOP, a
COWL-enabled browser assigns a default label of public to top-level
contexts (i.e., to pages).
%
Finally, a web server can restrict browsing contexts by setting a
\js|COWL-label| HTTP response header, which dictates the minimal
document label the browser must enforce on the associated content.

COWL applications can create two types of context.
%
First, an application can create standard (but labeled) contexts in
the form of pages, iframes, workers, etc.
%
Indeed, it may do so because a COWL application is merely a regular
web application that additionally uses the COWL API. It thus is
confined by MAC, in addition to today's web security policies.
%
Note that to enforce MAC, COWL must mediate all pre-existing
communication channels---even subtle and implicit channels, such as
content loading---according to contexts' labels.
%
We describe how COWL does so in Section~\ref{sec:implementation}.

Second, a COWL application can create lightweight labeled contexts in
the form of \emph{labeled workers (LWorkers)}.
%
Like normal workers~\cite{workers}, the API exposed to LWorkers is
compact; its global only contains constructs for communicating with
the parent, the XHR constructor, and the COWL API.
%
Unlike normal workers, which execute in separate threads, an LWorker
executes in the same thread as its parent, sharing its event loop.
%
This sharing has the added benefit of allowing the parent to give the
child (labeled) access to its DOM, any access to which is treated as
both a read and a write, i.e., bidirectional communication.
%
Our third-party library example uses such a \emph{DOM worker} to
isolate the trusted application code, which requires access to the DOM
through the untrusted jQuery library.
%
In general, LWorkers---especially when given DOM access---simplify the
isolation and confinement of scripts (e.g., the password strength
checker) that would otherwise run in a shared context, as when loaded
with \js|<script>| tags.

\subsection{Labeled Communication}
\label{sec:system:communication}
Since COWL enforces a label check whenever a context sends a message,
the design described thus far is already symmetric: a source context
can confine a target context by raising its label (or a child
context's label) and thereafter send the desired message. To read this
message, the target context must confine itself by raising its label
accordingly. These semantics can make interactions between contexts
cumbersome, however. For example, a sending context may wish to
communicate with multiple target contexts, and need to confine those
target contexts with different labels, or even confine individual
messages to the same target context with different labels. And a
receiving context may wish to communicate unfetteredly with one or
more origins for a time before losing the ability to do so once it
raises its label to receive a message. In the password-checker example
application, the untrusted checker script at the right of
Figure~\ref{fig:checker} exhibits exactly this latter behavior: it
needs to communicate with untrusted remote origin {\tt sketchy.ru}
before reading the password labeled {\tt fb.com}.

%% %
%% Unfortunately, this approach of (ab)using the context label to impose
%% restrictions on a target context is cumbersome.
%% %
%% (Consider the case where a context wishes to impose different
%% restrictions according to the message or target context.)

\paragraph{Labeled Blob Messages (Intra-Browser)}
To simplify communication with confinement, we introduce the {\em
  labeled Blob,} which binds together the payload of an individual
inter-context message with the label protecting it. The payload takes
the form of a serialized immutable object of type Blob~\cite{html5}.
Encapsulating the label with the message avoids the cumbersome label
raisings heretofore necessary in both sending and receiving contexts
before a message may even be sent or received. Instead, COWL allows
the developer sending a message from a context to specify the label to
be attached to a labeled Blob; any label more restrictive than the
sending context's current label may be specified. While the receiving
context may receive a labeled Blob with no immediate effect on the
origins with which it can communicate, it may only inspect the label,
but not the payload. Only after raising its label as needed may the
receiving context read the payload.
%
%% A labeled Blob encapsulates a serialized immutable object, of type
%% Blob~\cite{html5}, and the label protecting it.
%
%% Since messages between contexts must be serializable objects, labeled
%% Blobs can be used to associate explicit labels with messages.
%
%% Unsurprisingly, these ``labeled messages'' can be sent from one
%% context to another.
%
%% When doing so, COWL does not impose any more restrictions than those of
%% Section~\ref{sec:system:contexts}.
%% %
%% Importantly, however, a receiving context cannot arbitrarily inspect
%% such labeled messages;
%% %
%% until the message is ``unlabeled'' and the context label is raised to
%% subsume the blob label, the received labeled message is mostly opaque:
%% the receiving context can only inspect its label.

Labeled Blobs simplify building applications that incorporate distrust
among contexts. Not only can a sender impose confinement on a receiver
simply by labeling a message; a receiver can delay inspecting a
sensitive message until it has completed communication with untrusted
origins. They also ease the implementation of integrity in
applications, as they allow a context that is not trusted to modify
content in some other context to serve as a passive conduit
for a message from a third context that {\em is} so trusted.
%
%% For example, a sender can impose confinement restrictions on a
%% receiver by simply labeling a message.
%
%% Since the label of the message can be above the sender's context label
%% this alleviates the need for the sender to raise its label only to
%% impose restrictions on the receiver.
%
%% (Indeed, when creating a labeled Blob, the specified label \emph{must}
%% be at least as restricting as the current context label.)
%
%% Equally important, the receiver can delay inspecting a sensitive
%% message until it is ready to raise its label and be more restricted in
%% where it can write.
%
%% (Or alternatively, it can serve as an intermediary and pass the
%% labeled Blob to yet another context, a pattern we found useful when
%% considering ``high'' integrity message.)
%
%% For example, in the password checker example of
%% Section~\ref{sec:motivating-examples} we label the password
%% \https{fb.com} before sending it to the untrusted checker.
%% %
%% The latter has the flexibility of communicating arbitrarily until it
%% unlabels the password, at which point it will be constrained to
%% sending messages to its parent.

\paragraph{Labeled XHR Messages (Browser--Server)}
\label{sec:system:labeled-xhr}
The ability of a context to impose confinement restrictions on
another naturally extends to servers, when using the XHR constructor.
% 
Traditionally, an XHR request is composed of two parts: a write to an
external origin (sending the request), and then a read from the external
origin (reading the response, which is restricted according to the
SOP).
%
Before initiating a request, COWL, however, also checks to see
if the label of the origin subsumes the label of context. 
%
Since COWL-enabled servers may be interested in the current label of
the context which initiated the request, we send this (and a
description of the context privileges) with every request.
%
Similarly, when reading the response, we check to see if the label of
the context subsumes the label of the response, which may be
explicitly set with the \js|COWL-label| header.
%

While the server can set the response label (with the \js|COWL-label|)
to ensure that the context can only inspect the response if it is
appropriately confined, the client can decide to delay this decision by
setting the response type---when opening the connection---to
\js|labeled-blob|.
%
As with inter-context labeled communication, the returned response
of this \emph{labeled XHR} constructor is a labeled Blob (whose label
is specified by the \js|COWL-label| header).
%
This flexibly allows the application to delay the inspection of a
sensitive response, which would confine it.
%
For example, in our mashup example, Mint only confines itself once it
receives all the necessary (labeled) responses from both Amazon and
Chase; at this point it can perform its task and display the result to
the user, but can no longer send requests since doing so may leak
information.
%
(Of course, a separate context can always be used to continuously poll
the servers and send the labeled responses to the more tainted
context.)

With MAC in place, we envision that there are scenarios in which web
servers would share resources by setting more flexible CORS policies, but
only do so if the client to be appropriately confined.
%
For instance, Chase may expose a read-only bank statement (HTTP) API
that white-lists reputable domains, such as \https{mint.com}, but
imposes restrictions on what these origins can do with the shared data
(namely, where they can disseminate it).
%
This is appealing because it allows a server to share resources without
completely trusting the white-listed cross-origin.
%
In this example, Chase does not need to trust Mint to write bug-free
code---COWL confines the Mint code to ensure that it cannot arbitrarily
leak the bank statements.
%
Of course, and as discussed in Section~\ref{sec:discussion}, a malicious
Mint application can leak data through covert channels.
%
Nevertheless, this improves the state of affairs where users give up
their credentials and place complete trust in Mint---not only to keep
their bank statements confidential, but also from stealing their
funds.

Since trust varies between users, a server cannot be expected to use
CORS white-lists (beyond a handful of reputable domains) to
accommodate everybody.  For example, a user may wish to use a
lesser-known mashup, \https{wutang-financial.com}, instead of
\https{mint.com}; unless Chase white-lists this domain (maybe at the
user's request), the user is, again, forced to decide between giving
up their privacy (credentials) and using the service.  Intuitively,
however, it is safe relax the CORS policy to allow cross-origin code
to read the result of a response, as long as it is confined
thereafter.  Hence, COWL allows users to override the default CORS
policy of a website (if there is any) to white-list origins they
trust.  For example, the user can white-list
\https{wutang-financial.com} to read cross-origin data from
\https{chase.com}.  Importantly, however, all such cross-origin
responses must be labeled.  (We call this feature labeled CORS
(LCORS).) If the server supplies a response label, COWL uses this
label.  Otherwise, we assume that the server is not COWL-enabled and
label the response with a \emph{unique} origin (see
Section~\ref{sec:system:privileges}).  This ensures that once the
response is inspected the code cannot communicate with \emph{any}
server, including the \emph{same} origin (e.g., \https{chase.com}),
since these requests carry the risk of self-exfiltration~\cite{selfex}
and cross-site request forgery~\cite{CSRF}.
%% %
%% A server that is protected against self-exfiltration and cross-site
%% request forgery using end-to-end labels can relax this requirement by
%% supplying a less restricting label.


\subsection{Privileges}
\label{sec:system:privileges}
Relate to declassification and delegation.


%% %%XXX(ds): MOVE to implementation:
%% For example, our implementation modifies existing browsing contexts to
%% mediate:
%% %
%% \js|postMessage|,
%% same-origin cross-compartment DOM object access,
%% content loading (via {\tt img} tags, CSS, etc.),
%% form submission,
%% use of the \js|XMLHttpRequest| object,
%% navigation, and
%% browser storage (cookies and local storage).



% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-default: "Make"
% End:

