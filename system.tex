\section{The \sys{} system}
\label{sec:system}

In \sys, every browsing context has an associated security \emph{label},
\emph{privilege}, and \emph{clearance}.
%
The label of the browsing context serves as a ``taint,'' indicating
the sensitivity of data the code executing within the context has
read.
%
Labels are specified in terms of \emph{principals}, which
correspond to origins, whose privacy is at stake.\footnote{
  We note that our system also handles integrity, or trust, which
  serves as the dual of privacy.
  %
  For simplicity of exposition we omit integrity from our discussion.
}
%
For example, the label
\js|Label("http://bank.ch").and("http://amazon.com")| specifies that
the context potentially contains data sensitive to \http{bank.ch}
\emph{and} \http{amazon.com}.
%
In turn, \sys{} uses the context label to confine code by restricting
writes---code in the context is restricted to communicating with other
browsing contexts (using \js|postMessage|) if their labels are at
least as restricting; without privileges, network communication and
local storage is not allowed since the effective labels of these
end-points are less restricting (end-point labels protect the privacy
of a single origin).

Privileges are objects with which code can assert the authority of
principals. 
%
In \sys, scripts are granted the privilege corresponding to the
page origin.\footnote{
More specifically, only \emph{privileged} scripts, as described in
Section~\ref{sec:system:script}, are granted the privilege of the page
origin.
}
For example, a script running in an \http{amazon.com} page has the
privilege of the origin, allowing it to declassify data sensitive to
\http{amazon.com}.
%
Specifically if the context label is
\js|Label("http://bank.ch").and("http://amazon.com")|, this privilege
can be used to downgrade the label to \js|Label("http://bank.ch")|
and, as a result, allow code to communicate with additional browsing
contexts and even perform network requests (to \http{bank.ch}).
%
Importantly, code cannot synthesize arbitrary privileges, e.g., for
\http{bank.ch}---this would trivially violate any confinement
guarantees;
%
in our system, code can only create the empty privilege
(\js|new Privilege()|) 
and privileges corresponding to fresh, unique principals/origins
(\js|new FreshPrivilege()|).

In ideal confinement systems, code can typically read arbitrary data
at the cost of raising its label and giving up write privileges.
%
Unfortunately, practical systems typically have covert channels which
may be exploitable.
%
Hence, as in HiStar~\tocite{histar} and Hails~\tocite{hails},
we use clearance to impose a limit on the kind of data a piece of code
can access.
%
Specifically, clearance serves as an upper bound on the context label,
code cannot read from or write to entities labeled ``above'' the
clearance.

In the rest of this section, we describe the \sys{} design through
three concrete examples: a password-strength checker
(Section~\ref{sec:system:worker}), a password manager
(Section~\ref{sec:system:iframe}), and an extension that converts
phone numbers to links (Section~\ref{sec:system:script}).
%
For completeness, we summarize the different system components and
security mechanisms in Table~\toref{table:components}.



\subsection{Isolating third-party code}
\label{sec:system:worker}
%Password-strength checker: 

Password-strength checkers are common to many websites;
%
given a password, a checker computes the strength of the input,
according to some metric.
%
Naturally, when using a third-party password-strength checker
(e.g.,~\tocite{checker1, checker2}) we would like to ensure that the
code does not leak the user's password.
%
A malicious checker should at worst lie about the strength of a
password.

With server-side support and existing browser mechanisms, we can
incorporate and partially ``confine'' a simple third-party strength
checker.
%
To this end, we must host the checker source on a trusted domain and
execute the code in a Worker; since Workers have separate, fresh
browsing contexts with no access to the page DOM, this ensures that
the password cannot be leaked by inserting images, loading scripts,
etc.
%
However, Workers have access to the \xhr{} constructor and we must, in
turn, create the checker Worker object in an iframe that has a CSP
policy that restricts network communication (e.g., \texttt{connect-src
'self'} if the checker source is hosted on the same domain as the page
incorporating it); this is necessary since Workers inherit the CSP
policy of the owner document~\tocite{csp}.
%
Finally, we need to implement the messaging layers between the Worker,
the iframe incorporating it, and main page.

Unfortunately, this approach is unsatisfactory due to four main reasons.
%
First, to avoid trusting the checker website, the checker source code
must be hosted by the library user, wherein a CSP policy can be used
to restrict the checker's communication capabilities. 
%
This need for server-side support is problematic for developers that
do not have server-side access to set such headers.
\Red{dherman put this very nicely; can we fish that sentence?}
%
Second, the fact that we require server-side support to set policies
that restrict communication means that the password-checker cannot
incorporate code it itself does not trust.
%
Third, the CSP policy of the checker cannot be more restricting than
that of the owner document---hence, the checker can potentially carry
out a self-exfiltration attack and leak the password to a public page
on the trusted domain~\tocite{self-exfiltration}.
%
Finally, this approach cannot be used to confine a password
strength-checker that, for example, fetches a list of commonly used
passwords before checking the strength of the password---a completely
safe and useful operation.



\subsection{Confining iframes}
\label{sec:system:iframe}
%Password manager 

\subsection{Privilege separation within iframes}
\label{sec:system:script}
%Phone2Links extension
