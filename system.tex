\section{The \sys{} confinement system}
\label{sec:system}

In \sys, every browsing context has an associated security
\emph{label}, \emph{privilege}, and \emph{clearance}.
%
The label of the browsing context serves as a ``taint,'' indicating
the sensitivity of data the code executing within the context has
read.
%
Labels are specified in terms of \emph{principals}, which
correspond to origins, whose privacy is at stake.\footnote{
  We note that our system also handles integrity, or trust, which
  serves as the dual of privacy.
  %
  For simplicity of exposition we omit integrity from our discussion.
}
%
For example, the label
\js|Label("https://bank.ch").and("https://amazon.com")| specifies that
the context potentially contains data sensitive to \https{bank.ch}
\emph{and} \https{amazon.com}.
%
In turn, \sys{} uses the context label to confine code by restricting
writes---code in the context is restricted to communicating with other
browsing contexts (e.g., using \js|postMessage|) if their labels are at
least as restricting; without privileges, network communication and
local storage is not allowed since the effective labels of these
end-points are less restricting (end-point labels protect the privacy
of a single origin).

Privileges are objects with which code can assert the authority of
principals. 
%
In \sys, scripts are granted the privilege corresponding to the
page origin.
%
For example, a script running in an \https{amazon.com} page has the
privilege of the origin, allowing it to declassify data sensitive to
\https{amazon.com}.
%
Specifically if the context label is
\js|Label("https://bank.ch").and("https://amazon.com")|, this privilege
can be used to downgrade the label to \js|Label("https://bank.ch")|
and, as a result, allow code to communicate with additional browsing
contexts and even perform network requests (to \https{bank.ch}).
%
Importantly, code cannot synthesize arbitrary privileges.
%
For example a  script from \https{amazon.com} cannot create a
privilege for \https{bank.ch}---this would trivially violate any
confinement guarantees;
%
in our system, code can only create the empty privilege
(\js|new Privilege()|) 
and privileges corresponding to fresh, unique principals/origins
(\js|new FreshPrivilege()|).

In ideal confinement systems, code can read arbitrary data at the cost
of raising the context label and thus giving up write privileges.
%
Unfortunately, practical systems typically have covert channels which
may be exploited to leak sensitive data.
%
Hence, as in HiStar~\tocite{histar} and Hails~\tocite{hails}, we use
clearance to impose a limit on the kind of data a piece of code can
access.
%
In \sys, clearance is a label that is used to restrit code from
reading and writing to entities labeled ``above'' this label, i.e.,
more sensitive entities.

In the rest of this section, we describe the \sys{} design through
three concrete examples: 
a password-strength checker (Section~\ref{sec:system:worker}),
a password manager (Section~\ref{sec:system:iframe}), 
a third-party mashup (Section~\ref{sec:system:mashup}), and
an extension that converts phone numbers to links
(Section~\ref{sec:system:script}).  %
%
For completeness, we summarize the different system components and
security mechanisms in Table~\toref{table:components}.

\begin{table*}[t]
\centering
\begin{tabular}{l | m{2.35in} | m{3.5in}}
\hline
\textbf{Component} & \textbf{API} & \textbf{Description} 
\\\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Labels &  
\begin{webidl}
Label {
  Label Label([String])
  Label and(String or Label)
  Label or(String or Label)
  bool subsumes(Label [,Privilege])
}
\end{webidl}
&
\\\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Privileges &  
\begin{webidl}
Privilege {
  Privilege FreshPrivilege()
  Privilege combine(Privilege)
  Privilege mint(Label)
  Label asLabel(Privilege)
}
\end{webidl}
&
\\\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Context label &  
\begin{webidl}
Browbound {
  prop Label privacyLabel
}
\end{webidl}
&
The context label is used to restrict reads and writes from the
current browsing context.
%
Code can only write to entities above the current label.
%
Code can read from entities whose label is at most as restricting as
the context label---when wishing to read more sensitive data, the
context label can be raised (set) to the more restricting label,
clearance permitting (see below).
%
This comparison between labels (using the current context's
privileges) is the single mechanism used to restrict reads and writes.
\\\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Context clearance  &  
\begin{webidl}
Browbound {
  prop Label privacyClearance
}
\end{webidl}
&
Clearance is a label that is used to restrict access to data.
%
Code cannot read form or write to entities more sensitive than the
clearance.
%
In the case of reads, this simply implies that the clearance is an
upper bound on the context label.
%
The clearance can be set by code running in the context, but only to a
label that is more restricting than the context label and less
restricting than the current clearance.
\\\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Context privileges  &  
\begin{webidl}
Browbound {
  prop Privilege privileges
}
\end{webidl}
&
Privileges are used to relax label comparisons when performing reads
and writes.
%
Code running in the context can get and set the current privileges.
\\\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Labeled Workers  &  
\begin{webidl}
LWorker {
  LWorker LWorker(String, Label[, Privilege])
  LWorker SOLWorker(String, Label)
  postMessage(Object [,Label])
  prop EventHandler onmessage
  void grant(Privilege)
}
\end{webidl}
&
\\\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{tabular}
\caption{\label{systemAPI} \sys{} design components and API}
\end{table*}


\subsection{Confining third-party DOM-less code}
\label{sec:system:worker}
%Password-strength checker: 

Password-strength checkers are common to many websites;
%
given a password input, a checker computes the strength of the
password according to some metric (e.g., length, number of special
characters, etc.).
%
Naturally, when using a third-party password-strength checker
(e.g.,~\tocite{checker1, checker2}) we would like to ensure that the
code does not leak the user's password.
%
A malicious checker should at worst lie about the strength of a
password.

\subsubsection{Current approach}
%
Using existing mechanisms, a page hosted, for instance, on
\https{instagra.me}, can incorporate and partially ``confine'' a
simple third-party strength checker (e.g.,
\https{checker.ru/checker.js}).
%
For simplicity we consider a password strength checker that does not
require access to the DOM.
%
As such, to ``confine'' the strength checker, \https{instagra.me}
can execute the code in a Worker~\tocite{worker};
%
since every worker has a separate, fresh browsing context with no
access to the page DOM, this ensures that the password cannot be
leaked by inserting images, loading scripts, etc.
%
However, workers do have access to the \xhr{} constructor, and, thus,
\https{instagra.me} must additionally host the checker source and set
a CSP policy that restricts its network communication (e.g.,
\texttt{connect-src: 'self'}).
\footnote{
  Workers inherit the CSP policy of the containing page~\tocite{csp},
  hence \https{instagra.me} can create the worker in a ``dummy''
  iframe which has the set policy.
  %
  We assume that the messaging layers between the worker, its parent
  iframe, and main page are straight forward to implement.
}
%

Though this approach (mostly) accomplishes the desired goal of
protecting the password, the approach is widely unsatisfactory.
%
First, to avoid trusting the checker's origin, the checker source code
must be hosted by \https{instagra.me}, wherein a CSP policy, in the
form of a HTTP  header, can be used to restrict the checker's
communication capabilities. 
%
This need for server-side support is problematic for developers that
do not have server-side access to set such headers.
\todo{dherman}{you had a much better argument for why client-side-only
a la developers is so important.}
%
Moreover, the need for server-side support also means that the
password-strength checker cannot incorporate code it itself does not
trust---the SOP would require \https{instagra.me} to host all the code
and express the security concerns of the strength checker as well.
%
Second, the CSP policy of the checker cannot be more restricting than
that of the containing document---hence, the checker can potentially
carry out a self-exfiltration attack~\tocite{self-exfiltration} and
leak the password to a public page on \https{instagra.me}.
%
Finally, this approach cannot be used to confine a password
strength-checker that, for example, fetches a list of commonly used
passwords before checking the strength of the password---a completely
safe operation.
%

\subsubsection{New approach}
%
In part, the above limitations arise because existing browser
techniques do not allow developers to express confinement, even for
code that does not require DOM access.
%
(Rather today's mechanisms give developers a limited form of access
control.)
%
Addressing these limitations, \sys{} allows developers to treat a
piece of code as untrusted and confine it in turn.
%
Below we consider the confinement of ``DOM-less'' code; in
Sections~\ref{sec:system:iframe} and \ref{sec:system:extension} we
address confinement of third-party code with access to the DOM.

As described above, workers are a good first step towards reasoning
about the security implications of untrusted code that does not need
to access the DOM.
%
Hence, we extend the Worker DOM API~\tocite{workers} with a
Labeled-Worker (LWorker).
%
Like a standard worker, an LWorker executes a piece of code in a fresh
browsing context that exposes a limited set of objects and properties.
%
Specifically, we expose the \sys{} API (including the \js|LWorker|
constructor used to construct additional labeled Workers), the \xhr{}
constructor used to perform network requests, and
\js|onmessage|/\js|postMessage| used for communicating with the
parent.
%
Different from the \js|Worker| constructor, the \js|LWorker|
constructor takes an additional argument: a label that specifies the
clearance on the code running in the worker browsing context.

An LWorker is created using the \js|LWorker| constructor, which takes
two arguments: the URL of the code to execute in the worker, and the
worker label.
%
For example, we create a new LWorker that executes the
password-strength checker code as follows:
\begin{jscode}
var url = "https://checker.ru/checker.js";
var label = new Label(window.location.origin);
// 1. Execute checker in new context
var checker = new LWorker(url, label);
\end{jscode}
%
Assuming the browsing context (main page) creating the worker has not
enabled \emph{confinement-mode}, \sys{} first enables confinement-mode
and sets the page label to the public label \js|Label()|.
%
In general, a context can explicitly enable confinement-mode and set
the context label to a label more restricting than the current label;
when enabling confinement-mode implicitly, \sys{} takes a permissive
approach and sets the current label to the public label.
 
Subsequently, we ensure that the current page is allowed to make a
request to \js|url| to fetch the source code.
%
As with loading content (e.g., images, styles and scripts), writing to
storage (e.g., cookies), or performing explicit network requests with
\xhr{}, \sys{} asserts that, given the current context privileges, the
label of the resource---which is implicitly \js|Label(|\emph{resource
origin}\js|)|---subsumes the context label.
%
In this case, \js|Label("https://checker.ru")| subsumes the context
label \js|Label()| and thus fetching the script is permitted.

Before executing the fetched script in a new browsing context, \sys{}
ensures that the label of the worker is at least as restricting as the
current label.
%
Just as the context label protects all data in the context, the label
of a worker protects the data within the worker (as observed by
reading from the worker).
%
This check ensures that the page cannot ``declassify'' data by
laundering it through a worker whose label is less sensitive than the
context label.

As shown in Figure~\toref{fig:strength-1}, \sys{} starts executing the
checker code in the LWorker; the initial, worker context label is set
to that of the parent (in this case, the public label \js|Label()|).
%
At this point, the code can fetch data, such as a list of weak
passwords, from any origin, CORS-permitting.
%
It is important to note that since the password-strength checker has
not yet read any sensitive data, which is reflected in the context
label, this is a safe operation: making the request does not leak any
information.
%
Only once the code has decided to inspect the password should it not
be able to perform such arbitrary network requests.

To check the strength of the password, the page sends the LWorker the
password via \js|postMessage|, and registers a message handler to
receive the strength score:
\begin{jscode}
var password = 
 document.getElementById("password").value;
// 3. Send checker password 
checker.postMessage(password, l);
// 5. Get score
checker.onmessage = function(event) {
  var score = event.data; 
  // ...
}
\end{jscode}
Here, \js|postMessage| additionally takes the label of the message
\js|l|, which must be at most as restricive as the worker label.
%
(If an explicit label is not supplied to \js|postMessage|, \sys{}
uses the context label of the sender as the message label.)
%
We use this label to ensure that the message is dispatched to the
checker only if its context label is at least as sensitive as
\js|l|---thereby preserving the privacy of the password (which is
protected by \js|l == Label("https://instagra.me")|.

To retrieve the password, the password-strength checker registers a
message-event handler, which is invoked when the parent sends it a
message (step 3 above):
\begin{jscode}
// checker.js ...
// Browbound.label == Label()
function computeStrength(pass) { /* ... */ }

// 2. Raise context label & register handler
Browbound.label = Browbound.clearance;
// Browbound.label == Label("https://instagra.me")
onmessage = function(event) {
  var password = event.data;
  // 4. Check score & send it to parent:
  postMessage(computeStrength(password));
};
\end{jscode}
%
Importantly, the worker first raises the context label to the
clearance, which is the worker label, by setting \js|Browbound.label|.
%
In doing so, the code is effectively stating that it is ready to
receive data at sensitivity level \https{instagra.me}, at the cost of
giving up arbitrary communication privileges.
%
As shown in Figure~\toref{fig:strength-3}, the checker can now receive
the sensitive password, but, for example, can only use \xhr{} to
communicate with \https{instagra.me};
%
performing arbitrary network requests or creating arbitrarily labeled
workers is no longer permitted.

Finally, the event handler, which is supplied with the parent-supplied
password, invokes the underlying password-strength checking function
\js|computeStrength|.
%
The result of this function is returned to the page via
\js|postMessage|.
%
Since the page registered an event handler (step 5), as shown in
Figure~\toref{fig:system:strength-4}, \sys{} ensures that the label of
the parent context is at least as restrcting as the message label
(which is the worker context label) and then dispatches the handler.
 
The full life-cycle of this application is shown in
Figure~\toref{fig:system:strength}.
%
In this example we relied on the page having ownership of the
\https{instagra.me} privilege as to avoid tainting the context when
reading the score from the checker worker, which was labeld with this
principal.
%
Unfortunately, this also means that our confinement of the checker is
limited: we cannot label the context with this label and restrict the
code from using \xhr{} to self-exfiltrate data to \https{instagra.me}.
%
Instead, the page must label the worker with a principal that it owns
and, moreover, does not correspond to an actual origin.

This is precisely the role of fresh privileges.
%
A fresh privilege corresponds to a unique principal/origin whose
scheme is prefixed by \texttt{x-}; this ensures that the \xhr{}
constructor cannot be used to make requests to a real host.
%
Hence, to fully confine the password-strength checker we modify the
\https{instagra.me} page to first create a fresh privilege and use the
corresponding label when creating the LWorker.
%
Th modified code is shown below.
\begin{jscode}
// Create fresh unique privilege
var p = new FreshPrivilege();
// Take ownership of this privilege
Browbound.own(p);
// Use it to confine the worker completely:
var checker = new LWorker(url, p.asLabel);
// As before ..
var password = 
 document.getElementById("password").value;
// 3. Send checker password 
checker.postMessage(password, p.asLabel);
// ...
\end{jscode}

\paragraph{Discussion}
Different from current approaches, our system provides a client-side
approach for flexibly and fully confining untrusted code:
%
the strength checker can perform arbitrary XHR until it raises its
label to register the \js|onmessage| handler that will inspect the
password; from this point on it can only communicate with the parent.
%
This is in contrast to either giving the checker irrevocable network
access or none at all.
%
Moreover, our first-class workers and privileges makes security a
first class citizen: not only can the page consider the checker
untrusted, but the checker can itself create fresh privileges and a
LWorkers in which it can execute code it itself does not consider
trustworthy!

\subsection{Cross-iframes confinement}
\label{sec:system:iframe}
%Password manager 

In the previous section, the \https{instagra.me} page imposed the
requirement that the password-strength checker, executing in an
LWorker, have a sufficiently high context label such that it cannot
exfiltrate the password; otherwise \sys{} would not dispatch the
password message.
%
In general, our confinement mechanism allows developers to control
where their data can flow, even after said data is made available to
an untrusted browsing context.
%
Below, we extend our notion of first-class confinement to iframes by
describing the design of a mostly untrusted password manager--- an
application that allows users to use a single master password to
manage multiple site-specific passwords.

\subsubsection{Current approach}
%
Today's browser security mechanisms are not useful when building a
password manager as a website.
%
Specifically, the lack of confinement forces users to either trust the
password manager website with their website-specific (e.g.,
\https{fb.com}) credentials or trust arbitrary websites (e.g.,
\https{fb.com}) with the master password that is used to to protect
other credentials.
%
This issue of handling sensitive data is grave; insomuch, that all
major browsers ship with build-in password managers.
%
A built-in password manager simply requires the user to place more
trust on the already-trusted browser.
%
Unfortunately, such built-in apps increase the TCB of the browser and
don't always behave as desired (e.g., some password managers fill in
forms with credentials before the form is submitted---making the
password available to potentially untrustworthy JavaScript code).
%
Moreover, the approach does not scale: are we to integrate apps into
the browser TCB simply because there exists no mechanism that allows
developers to express security policy on code that handles sensitive
data?

\subsubsection{\sys{} approach}
%
With \sys{}, we can leverage confinement to build a password manager
as a website that does not force the user to place complete trust on
any of the participating parties.
%
Our password manager is divided into two mutually distrusting
components: a management layer (provided by e.g., \https{pwd.eff.org})
that interacts with the user to store and fetch credentials, and a
storage layer (provided by e.g., \https{dropcu.be}) that provides a
simple---in effect, labeled---server-side storage API for the
management layer.
%
The mutual distrust between the layers is instrumental to ensuring
that neither party can individually compromise the user's privacy (and
would thus have to be wholly trusted).
%

%
Though a user can use such a password manager to store and fetch
secrets directly, for simplicity, we assume that a website (e.g.,
\https{fb.com}) integrates with the manager to save and retrieve login
credentials,\footnote{
  In Section~\ref{sec:system:extension} we describe an untrusted
  extenion system that can be used to inject the password-manager
  specific code into the integrator page.
} as shown in Figure~\toref{fig:manager-s-1}.
%
Without loss of generality we also assume that encryption and
decryption is carried out on the client-side by the management layer.
%
Given this architecture, the security guarantees and trust concerns
are as follows:
\begin{enumerate}
\item The management layer never learns the site-specific
  (\https{fb.com}) credentials. The user need only trust this
  component with their master password, which without the collusion of
  the storage layer is not useful.
  %
  To eliminate this trust, users can inspect the label of a browsing
  context using standard developer tools or by right-clicking on the
  page (a functionality implemented by our supporting extension,
  describe in Section~\toref{XXX}).
\item The storage layer never learns the site-specific credentials or
  master password. The user need only trust this layer to not collude
  with the management layer.
\item Finally, the integrator never learns the master password or
  credentials private to other websites (e.g., \https{goo.gl}).
\end{enumerate}
%
Importantly, the guarantees must be preserved when both, the
password manager is used to save and retrieve the credentials.
%
Below we respectively describe the interaction of all the components
in saving and retrieving credentials, respectively.

\paragraph{Saving credentials}
%
To save credentials, the integrator, \https{fb.com}, first creates two
iframes: one containing the \https{pwd.eff.org} management layer and
another containing the \https{dropcu.be} storage layer.
%
As part the initialization process, the management layer saves a
pointer to the storage layer (via \js|window.parent.frames|), both
layers register \js|onmessage| event handlers, and the expected
sensitivity of data, i.e., labels, to be shared is exchanged.
%
Subsequently, the integrator sends the credentials to the management
layer via \js|postMessage|.
%
The label of the message is set to
\js|Label("https://fb.com").or("https://dropcu.be")|; this ensures
that the management layer can only receive the message if it has
raised its context label to a label that is at least as
restricting---thereby loosing ability to communicate outside the
\https{fb.com} and \https{dropcu.be} layers.\footnote{
  To confine the management layer more strictly, the message can be
  labeled with a label corresponding to a fresh principal generated by
  \https{fb.com}. Importantly, the privilege must be granted to the
  storage layer.
}
 
As shown in Figure~\toref{fig:manager-s-2}, upon receiving the
credentials (\js|credentials|), the management layer requests the
master password (\js|mpass|) from the user, and generates a salt
(\js|salt|) and encryption key $k =
H(\texttt{mpass}\|\texttt{"}\https{fb.com}\texttt{"}\|\texttt{salt})$.
%
The credentials are then encrypted using function \js|E| (e.g., AES).
% 
Here, $H$ is a hash function such as SHA-256.
%
We use the integrator origin in addition to the master
password and salt in the key generation.
%
In doing so, the management layer ensures that a malicious storage
layer will not be able to confuse it, during the retrieval process,
into decrypting \https{fb.com}'s credentials when invoked by a
different site, e.g., \https{goo.gl}.

After, the management layer sends \js|E|$_k$\js|(credentials)| and the
\js|salt| via \js|postMessage| to the storage layer (the pointer to
which was saved during initialization).
%
Assuming that the label of the message is at most as restricting as
\js|Label("https://dropcu.be")|, the storage layer's \js|onmessage|
handler will be dispatched. 
%
Since the frame has the \https{dropcu.be} privilege, it need not raise
its context label; this allows the storage layer to use \xhr{} to send
the data to the server. 
 
We note that, in addition to the credentials and salt, the storage
layer also stores the origin of the parent, i.e., \https{fb.com}, as
meta-data (label) identifying for whom the data is being stored.
%
Rather than having the management layer provide this meta-data to the
storage layer alongside the credentials, by requiring \https{fb.com}
to create the frame, we ensure that a malicious management layer
cannot confuse the storage layer into associating \https{fb.com}'s
encrypted data with a different origin, e.g., \https{goo.gl}, and thus
leak it on retrieval.

\paragraph{Retrieving credentials}
%
As in the case of saving credentials the integrator, \https{fb.com},
creates two frames containing the management and storage layers.
%
In this scenario, the storage layer retrieves the encrypted credentials
\js|E|$_k$\js|(credentials)|, salt and ownership meta-data (in this
case, \https{fb.com}) and register an \js|onmessage| event handler, 
similar to the one showed below.
\begin{jscode}
function handler(event) {
  // ... check origin ...
  // owner == "https://fb.com"
  // credentials == E_k(...)
  var l = new Label(owner);
  event.origin.postMessage(credentials, l);
} 
window.addEventListener("message", handler);
\end{jscode}
This handler simply replies via \js|postMessage| with the credentials.
%
Importantly, however, the message is labeled with the origin meta-data
retrieved from the server.
%
This ensures that the frame requesting the credentials---the
management layer---must have a context label that is at least as
restricting.
%
This guarantees that even if the management layer did not encrypt the
credentials during the save procedure, it cannot learn and
exfiltrate the credentials through the retrieval process; the context
label ensures that it can only disseminate the credentials to the
corresponding owner.
%

Like the storage layer, in this scenario, the management layer first
registers a message handler to receive the encrypted credentials.
%
Via \js|window.parent.frames| the layer retrieves a pointer to the
storage layer to which it sends a message requesting the encrypted
credentials after raising its context label to
\js|Label("https://fb.com")|.
%
Figure~\toref{fig:manager-r-2} illustrates this.
%
Subsequently, the message containing the encrypted
credentials and salt is dispatched and the
master password (\js|mpass|) is retrieved from the user. 
%
Using the master password and salt, the management layer reconstructs
key $k$, which used to decrypt the encrypted credentials.
%
Finally, the decrypted credentials are sent (via \js|postMessage|) to
the \https{fb.com} browsing context.
%
Importantly, the management layers' context label,
\js|Label("https://fb.com")|, disallows it from disseminating the data
to any other origin.
%
As shown in Figure~\toref{fig:manager-r-3}, at this point,
\https{fb.com}, whose label remains public can carry out the login
procedure, i.e., submit the login form.


\subsection{Privilege separation within iframes}
\label{sec:system:extension}
%Phone2Links extension
\Red{TODO: change section title; this should talk about stashing
privileges and extending LWorkers with DOM objects}


\subsection{Relaxing SOP for confined code}
\label{sec:system:mashup}
%Third-party Mashup
%
\sys{} restricts the communication capabilities of a browsing context
once it has read sensitive data, i.e., data from a browsing context
with a more restricting label.
%
As envisioned in~\tocite{hotos}, by equipping the browser with such
confinement mechanism we can safely relax the SOP.
%
This relaxation, in turn, allows developers to build applications that access
cross-origin data---in a safe manner and without server-side support---to build
applications that are not otherwise possible today.
%
As an example, we consider third-party mashups.

In a third-party mashup, a party, such as \https{mint.biz},
incorporates user-sensitive data from unaffiliated origins, such as
\https{bank.ch} and \https{amazon.com}, in order to present users with new
interfaces or functionality.
%
For instance, the third party, \https{mint.biz}, may wish to present the user with a
visualization of their spending habits, or identify fraudulent
\https{amazon.com} purchases using their \https{bank.ch} account, etc.
%
Currently, such applications cannot be built since the SOP prevents
\https{mint.biz} from accessing the users' \https{amazon.com} and
\https{bank.ch} data, e.g., using \xhr{}.\footnote{
 We assume that neither \https{amazon.com} nor \https{bank.ch}
 explicitly trust \https{mint.biz}; otherwise, the parties can
 explicitly set CORS headers~\tocite{CORS} to provide \https{mint.biz}
 access to such data.
}
%
In contrast, \sys{} is able to allow \https{mint.biz} to access such
data, provided that once the data is inspected, scripts cannot perform
arbitrary network requests (or storage writes).
 
To this end, we modify the \xhr{} constructor to add an additional
flag that indicates whether the object should be treated as a
\emph{implicitly labeled XHR object}.
%
When set, the  label of the object corresponds to the origin
to whom the request is being made (set with the \js|open| method). 
Accessing the object state, including the response, is dictated by
confinement (not SOP).
%
Specifically, when accessing any of the methods or properties of
the object, \sys{} ensures that underlying read- and write-effects do
not violate the confinement guarantees provided by the context label.
%
For example, when calling the \js|send| method, which performs the
actual network request, \sys~ checks that the (implicit) label of the
remote origin, to whom the request is being sent, subsumes the current
context label;
%
this ensures that performing the request does not leak any
information.
%
When accessing any of the response attributes (e.g., \js|status|,
\js|responseText|, etc.), \sys~ ensures that the browsing context can inspect
(read) the state of the XHR object which may contain data from the remote host.
%
Specifically, it checks that the context label is at least as
restricting as the label of the XHR object.
%
However, when reading from labeled XHR objects, \sys{} removes the
burden of manually raising the context from the developer and flexibly
raises the context label as necessary, clearance permitting, as
in~\tocite{lio}.
%
Finally, and as in the case of dispatching \js|onmessage| handlers,
%between labeled browsing contexts, 
when dispatching any registered XHR
handlers (e.g., \js|onabort|, \js|onload|, etc.), \sys~ ensures that the
context label subsumes the label of the XHR object, i.e., it can observe 
the presence of the message.
 
We note that our modified notion of a XHR object allows the response of a
cross-origin request to be inspected, regardless of the CORS headers.
%
Though more flexible than the SOP, such action is still safe since inspecting
the response raises the context label, and thus restricts all subsequent side
effects.
%
Returning to our mashup example, once \https{mint.biz} inspects the
response of an \https{amazon.com} request, it cannot perform requests
to any origin other than \https{amazon.com}.
%
Once the code further inspects a response from \https{bank.ch}, no
additional requests can be made: the context label  
\js|Label("https://amazon.com").and("https://bank.ch")|
cannot be subsumed by any origin label. 
% in order to 
% to inspect the response.
%
However, data in the browsing context can still be shared with labeled pages and
workers which preserve its privacy.
%whose context labels preserve the privacy described by 
%\js|Label("https://amazon.com").and("https://bank.ch")|.
% %ensures that the privacy of the will be preserved.
% 
Sometimes, applications need to be carefully designed to avoid loosing the
capability of performing XHR request. In fact, our third-party mashup
application creates two LWorkers, one communicating with \https{amazon.com} and
another with \https{bank.ch}. After all, the mashup may need to, for example,
fetch multiple statements or invoices due to user interaction (e.g. scrolling
down); the parent iframe in turn simply reads from the two workers and combines
the data in order to present it to the user.
%into a graph that the user interacts
%with.
%





\Red{Put somewhere:

Communication between different browsing contexts is dictated by the
context label.
%
A \js|postMessage| from browsing context \js|A| will be
sent to browsing context \js|B| if
\js|B.privacyLabel.subsumes(A.privacyLabel.and(B.privacyLabel), A.privileges)|,
i.e., the label of the label on the message payload on the receiving
end is at lest as restricting.
%
\Red{Our labeled \js|postMessage| API is given below.}

Similarly, loading content, writing to local storage (including
cookies), and performing explicit HTTP requests with \xhr{} requires
that the current label be at most as restricting as the label of the
resource.
The implicit label of such entities corresponds to the origin named in
the resource URL. For example, when loading a script (with the
\js|<script>| tag) from \https{jquery.com} the label of the resource
is implicitly \js|Label("https://jquery.com")|.

%

}



% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-default: "Make"
% End:
