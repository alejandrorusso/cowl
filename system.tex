\section{The \sys{} Confinement System}
\label{sec:system}

The COWL confinement system augments today's web browser with three
primitives, all of which appear in the simple password-checker
application example in Figure~\ref{fig:checker}.
% need to introduce "structural" primitives (ones that are visible in
% figures for example apps):
%
% labeled browsing contexts: in Figure 2. the central construct in
% COWL. they introduce MAC-based confinement to the browser. And they
% support hierarchical confinement, which is essential to allowing
% nesting of untrusted libraries (as described in section ...).

% privilege: in Figure 2 (though not used in example). in a MAC-based
% confinement system, certain operations are dangerous because
% untrusted code could use them to cause the release of sensitive
% information to unauthorized parties. for example, declassification
% of sensitive data strips the data's label, after which that data
% will not be confined within other compartments running potentially
% untrusted code that processes it. In COWL we term the authorization to execute
% such dangerous operations privilege, and express privilege in terms
% of origins.

% labeled communication: in Figure 2 (focus in that example chiefly on
% inter-context communication).  IPC between browsing contexts carries
% labeled data, so that when one compartment sends another sensitive
% data, it may confine the potentially untrusted code within the other
% compartment. This explicitly carrying of labels in IPC allows
% symmetric confinement, which is essential to building applications
% that compose scripts that are mutually distrusting, as described in
% section ....
%

{\em Labeled browsing contexts} enforce MAC-based confinement of
  JavaScript at the granularity of a browsing context (e.g., a worker
  or iframe). The rectangular frames in Figure~\ref{fig:checker} are
  labeled browsing contexts. As contexts may be nested, labeled
  browsing contexts allow hierarchical confinement, whose importance
  for supporting nesting of untrusted libraries we discussed in
  Section~\ref{sec:motivating-examples}. Throughout this paper, when describing a
  COWL-enabled browser, we use the terms compartment, browsing
  context, and labeled browsing context interchangeably.

When one browsing context sends sensitive information to
  another, {\em labeled communication} allows the sending context to
  confine the potentially untrusted code within the receiving
  context. Explicitly carrying labels in this fashion allows symmetric
  confinement, whose importance in building applications that compose
  mutually distrusting scripts we articulated in
  Section~\ref{sec:motivating-examples}. In Figure~\ref{fig:checker},
  the arrows between compartments indicate labeled communication,
  where a subscript on the communicated data denotes the data's label.

  A labeled browsing context may be granted one or more {\em
    privileges.} A privilege authorizes scripts within a context to
  execute certain operations whose abuse would permit the release of
  sensitive information to unauthorized parties. For example, a script
  can use its privileges to {\em declassify} messages it receives from
  another context, and thus retain the ability to do with the data
  received in those messages as it pleases. In COWL we express
  privilege in terms of origins. The crown icon in the left
  compartment in Figure~\ref{fig:checker} denotes that this
  compartment holds the privilege to execute these {\em privileged}
  operations on data labeled with the origin {\tt fb.com}. In
  Figure~\ref{fig:checker}, the {\tt fb.com} compartment uses its
  privilege to remain unconfined by declassifying the checker response
  labeled {\tt fb.com}.)

We now describe these three constructs in greater detail.

% need to state that MAC system and all primitives related to it are
% opt-in (and somewhere, how the developer opts in--what is the
% incantation?). Point is that we coexist alongside status quo
% browser, so we don't break any existing pages. It may be that
% incremental deployability is important enough to articulate as a
% goal in section 2. (we can potentially footnote that in our prior
% workshop paper, we explored how to implement all of today's browser
% security primitives in COWL-like primitives---a clean-slate
% approach that subsumed and improved on the status quo. here we take
% the complementary approach of prioritizing backward compatibility
% with existing mechanisms.)


\subsection{Labeled Browsing Contexts}
\label{sec:system:contexts}
A COWL application consists of multiple labeled contexts.
%
Labeled contexts naturally extend today's browser contexts, used to
isolate iframes, pages, etc., with MAC \emph{labels}.
%
A context's label specifies the security policy for all data within
the context, which COWL enforces by restricting the flow of
information to and from other contexts and servers.
%% in addition to the restrictions imposed by existing DAC policies such
%% as the SOP.

Following~\cite{yang:2013:towards, stefan:2011:dclabels}, a label is a
pair of boolean formulas: a \emph{secrecy} formula specifying which
origins may read a context's data, and an \emph{integrity} formula
specifying which origins may write it.
%
For example, only Amazon or Chase may read data labeled
\dcLabel{\https{amazon.com} $\lor$
  \https{chase.com}}{\https{amazon.com}}, and only Amazon may
modify it.
%
Amazon could assign this label to its order history page to allow a
Chase-hosted mashup to read the user's purchases.
%
On the other hand, after a third-party mashup hosted by
\https{mint.com} (as described in
Section~\ref{sec:motivating-examples}) reads {\em both} the user's
Chase bank statement data {\em and} Amazon purchase data, the label on
data produced by the third-party mashup will be
\dcLabel{\https{amazon.com} $\land$
  \https{chase.com}}{\https{mint.com}}.
%
This secrecy label component specifies that the data may be sensitive
to both parties, and without both their consent (see
Section~\ref{sec:system:privileges}), should only be read by the user;
the integrity label component, on the other hand, permits only code
hosted by Mint to modify the resulting data.
 
COWL enforces label policies in MAC fashion by only allowing a context
to communicate with other contexts or servers whose labels are at
least as restricting.
%
Intuitively, when a context wishes to send a message, the target must
not allow additional origins to read the data (preserving secrecy);
dually, the source context must not be writable by origins not
otherwise trusted by the target. That is, the source must be at least
as trustworthy as the target.
%
We say that such a target label ``subsumes'' the source
label.\footnote{ If communication is bidirectional, e.g., when a
  script accesses the DOM in a different context (but of the same
  origin), then both the target and source must subsume each other.}
%
For example, a context labeled
\dcLabel{\https{amazon.com}}{\https{mint.com}} can send messages to
one labeled \dcLabel{\https{amazon.com} $\land$
\https{chase.com}}{\https{mint.com}}, since the latter is guaranteed
to preserves the privacy of \https{amazon.com} (and
\https{chase.com}).
%
However, communication in the reverse direction is not possible since
it may violate the privacy of \https{chase.com}.
%
In the rest of this paper, we limit our discussion to secrecy and only
comment on integrity where relevant; the interested reader is referred
to~\cite{stefan:2011:dclabels} for a complete description of the label
model.

A context can freely \emph{raise} its label, i.e., change its label to
any label that is more restricting, in order to receive a message
from an otherwise prohibited context.
%
Of course, in raising its label to read more sensitive data from
another context, the context also becomes more restricted in where it
can write.
%
For example, a Mint context labeled
\dcLabelS{\https{amazon.com}}{\https{mint.com}} can raise its label to
\dcLabelS{\https{amazon.com} $\land$
  \https{chase.com}}{\https{mint.com}} to read bank statements, but
only at the cost of giving up its ability to communicate with Amazon
(or, for that matter, any other) servers.
%
When creating a new context, code can impose an upper bound on the
context's label to ensure tha untrusted code cannot raise its label
and read data above this \emph{clearance}.
%
This notion of clearance is well
established~\cite{efstathopoulos:asbestos, Zeldovich:2006,
  stefan:2011:flexible, Breeze13}; we limit our treatment of it to
Section~\ref{sec:discussion}, where we discuss covert channels.

As noted, COWL allows a labeled context to create additional labeled contexts,
much like existing browsing contexts can create sub-compartments
in the form of iframes, workers, etc.
%
This functionality is crucial for compartmentalizing a system
hierarchically, where the developer places code of different degrees
of trustworthiness in separate contexts.
%
For example, in the password checker example in
Section~\ref{sec:motivating-examples}, we create a child context in
which we execute the untrusted checker script.
%
Importantly, however, code should not be able to leak information by
laundering data through a newly created context.
%
Hence, newly created contexts implicitly inherit the current label of
their parent.
%
When creating a child, however, a parent may specify an initial
current label for the child that is {\em more} restrictive than the
parent's, to confine the child further.
%
To ensure compatibility with pages written for the legacy SOP, a
COWL-enabled browser assigns a default label of public to top-level
contexts (i.e., to pages).
%
Finally, a web server can restrict browsing contexts by setting a
\js|COWL-label| HTTP response header, which dictates the minimal
document label the browser must enforce on the associated content.

COWL applications can create two types of context.
%
First, an application can create standard (but labeled) contexts in
the form of pages, iframes, workers, etc.
%
Indeed, it may do so because a COWL application is merely a regular
web application that additionally uses the COWL API. It thus is
confined by MAC, in addition to today's web security policies.
%
Note that to enforce MAC, COWL must mediate all pre-existing
communication channels---even subtle and implicit channels, such as
content loading---according to contexts' labels.
%
We describe how COWL does so in Section~\ref{sec:implementation}.

Second, a COWL application can create lightweight labeled contexts in
the form of \emph{labeled workers (LWorkers)}.
%
Like normal workers~\cite{workers}, the API exposed to LWorkers is
minimal; its global only contains constructs for communicating
with the parent, the XHR constructor, and the COWL API.
%
Unlike normal workers, which execute in separate threads, an LWorker
executes in the same thread as its parent, sharing its event loop.
%
This sharing has the added benefit of allowing the parent to give the
child (labeled) access to its DOM, any access to which is treated as
both a read and a write, i.e., bidirectional communication.
%
Our third-party library example uses such a \emph{DOM worker} to
isolate the trusted application code, which requires access to the DOM
through the untrusted jQuery library.
%
In general, LWorkers---especially when given DOM access---simplify the
isolation and confinement of scripts (e.g., the password strength
checker) that would otherwise run in a shared context, as when loaded
with \js|<script>| tags.

\subsection{Labeled Communication}
\label{sec:system:communication}
Since COWL always enforces a label check when a context sends
messages, the design described thus far is already symmetric: a source
context can impose restrictions on a target context by raising its
label (or the label of a child context) and only then send the desired
messages; to read the messages, the target context must confine itself
by raising the context label.
%
Unfortunately, this approach of (ab)using the context label to impose
restrictions on a target context is cumbersome.
%
(Consider the case where a context wishes to impose different
restrictions according to the message or target context.)

To address this issue, COWL allows code to heterogeneously label
messages using labeled Blobs.
%
A labeled Blob encapsulates a serialized immutable object, of type
Blob~\cite{html5}, and the label protecting it.
%
Since messages between contexts must be serializable objects, labeled
Blobs can be used to associate explicit labels with messages.
%
Unsurprisingly, these ``labeled messages'' can be sent from one
context to another.
%
When doing so, COWL does not impose any more restrictions than those of
Section~\ref{sec:system:contexts}.
%
Importantly, however, a receiving context cannot arbitrarily inspect
such labeled messages;
%
until the message is ``unlabeled'' and the context label is raised to
subsume the blob label, the received labeled message is mostly opaque:
the receiving context can only inspect its label.

While simple, labeled Blobs are very useful in building applications
with (mutual) distrust.
%
For example, a sender can impose confinement restrictions on a
receiver by simply labeling a message.
%
Since the label of the message can be above the sender's context label
this alleviates the need for the sender to raise its label only to
impose restrictions on the receiver.
%
(Indeed, when creating a labeled Blob, the specified label \emph{must}
be at least as restricting as the current context label.)
%
Equally important, the receiver can delay inspecting a sensitive
message until it is ready to raise its label and be more restricted in
where it can write.
%
(Or alternatively, it can serve as an intermediary and pass the
labeled Blob to yet another context, a pattern we found useful when
considering ``high'' integrity message.)
%
For example, in the password checker example of
Section~\ref{sec:motivating-examples} we label the password
\https{fb.com} before sending it to the untrusted checker.
%
The latter has the flexibility of communicating arbitrarily until it
unlabels the password, at which point it will be constrained to
sending messages to its parent.

\subsubsection{Labeled XHR}
\label{sec:system:labeled-xhr}
The ability of a context to impose confinement restrictions on
another naturally extends to servers, when using the XHR constructor.
% 
Transitionally, an XHR request is composed of two parts: a write to an
external origin (sending the request), and then a read from the external
origin (reading the response, which is restricted according to the
SOP).
%
Before initiating a request, COWL, however, also checks to see
if the label of the origin subsumes the label of context. 
%
Similarly, when reading the response, we check to see if the label of
the context subsumes the label of the response, which may be
explicitly set with the \js|COWL-label| header.
%

While the server can set the response label (with the \js|COWL-label|)
to ensure that the context can only inspect the response if it is
appropriately confined, the client can decide to delay this decision by
setting the response type---when opening the connection---to
\js|labeled-blob|.
%
As with inter-context labeled communication, the returned response
of this ``labeled XHR'' is a labeled Blob (whose label is specified by
the \js|COWL-label| header).
%
This flexibly allows the application to delay the inspection of a
sensitive response, which would confine it.
%
For example, in our mashup example, Mint only confines itself once it
receives all the necessary (labeled) responses from both Amazon and
Chase; at this point it can perform its task and display the result to
the user, but can no longer send requests since doing so may leak
information.
%
(Of course, a separate context can always be used to continuously poll
the servers and send the labeled responses to the more tainted
context.)


\subsection{Privileges}
\label{sec:system:privileges}
Relate to declassification and delegation.


%% %%XXX(ds): MOVE to implementation:
%% For example, our implementation modifies existing browsing contexts to
%% mediate:
%% %
%% \js|postMessage|,
%% same-origin cross-compartment DOM object access,
%% content loading (via {\tt img} tags, CSS, etc.),
%% form submission,
%% use of the \js|XMLHttpRequest| object,
%% navigation, and
%% browser storage (cookies and local storage).



% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-default: "Make"
% End:

