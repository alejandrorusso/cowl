\section{The \sys{} system}
\label{sec:system}

In \sys, every browsing context has an associated security \emph{label},
\emph{privilege}, and \emph{clearance}.
%
The label of the browsing context serves as a ``taint,'' indicating
the sensitivity of data the code executing within the context has
read.
%
Labels are specified in terms of \emph{principals}, which
correspond to origins, whose privacy is at stake.\footnote{
  We note that our system also handles integrity, or trust, which
  serves as the dual of privacy.
  %
  For simplicity of exposition we omit integrity from our discussion.
}
%
For example, the label
\js|Label("https://bank.ch").and("https://amazon.com")| specifies that
the context potentially contains data sensitive to \https{bank.ch}
\emph{and} \https{amazon.com}.
%
In turn, \sys{} uses the context label to confine code by restricting
writes---code in the context is restricted to communicating with other
browsing contexts (e.g., using \js|postMessage|) if their labels are at
least as restricting; without privileges, network communication and
local storage is not allowed since the effective labels of these
end-points are less restricting (end-point labels protect the privacy
of a single origin).

Privileges are objects with which code can assert the authority of
principals. 
%
In \sys, scripts are granted the privilege corresponding to the
page origin.
%
For example, a script running in an \https{amazon.com} page has the
privilege of the origin, allowing it to declassify data sensitive to
\https{amazon.com}.
%
Specifically if the context label is
\js|Label("https://bank.ch").and("https://amazon.com")|, this privilege
can be used to downgrade the label to \js|Label("https://bank.ch")|
and, as a result, allow code to communicate with additional browsing
contexts and even perform network requests (to \https{bank.ch}).
%
Importantly, code cannot synthesize arbitrary privileges.
%
For example a  script from \https{amazon.com} cannot create a
privilege for \https{bank.ch}---this would trivially violate any
confinement guarantees;
%
in our system, code can only create the empty privilege
(\js|new Privilege()|) 
and privileges corresponding to fresh, unique principals/origins
(\js|new FreshPrivilege()|).

In ideal confinement systems, code can read arbitrary data at the cost
of raising the context label and thus giving up write privileges.
%
Unfortunately, practical systems typically have covert channels which
may be exploited to leak sensitive data.
%
Hence, as in HiStar~\tocite{histar} and Hails~\tocite{hails}, we use
clearance to impose a limit on the kind of data a piece of code can
access.
%
In \sys, clearance is a label that is used to restrit code from
reading and writing to entities labeled ``above'' this label.

In the rest of this section, we describe the \sys{} design through
three concrete examples: 
a password-strength checker (Section~\ref{sec:system:worker}),
a password manager (Section~\ref{sec:system:iframe}), 
a third-party mashup (Section~\ref{sec:system:mashup}), and
an extension that converts phone numbers to links
(Section~\ref{sec:system:script}).  %
%
For completeness, we summarize the different system components and
security mechanisms in Table~\toref{table:components}.



\subsection{Confining third-party DOM-less code}
\label{sec:system:worker}
%Password-strength checker: 

Password-strength checkers are common to many websites;
%
given a password input, a checker computes the strength of the
password according to some metric (e.g., length, number of special
characters, etc.).
%
Naturally, when using a third-party password-strength checker
(e.g.,~\tocite{checker1, checker2}) we would like to ensure that the
code does not leak the user's password.
%
A malicious checker should at worst lie about the strength of a
password.

\subsubsection{Current approach}
%
A page (e.g., \https{instagra.me}) can incorporate and partially
``confine'' a simple third-party strength checker (e.g.,
\https{checker.ru/checker.js}) that does not require DOM access using
existing browser mechanisms.
%
To accomplish this, \https{instagra.me} executes the checker code in a
Worker~\tocite{worker};
%
since every Worker has a separate, fresh browsing context with no access
to the page DOM, this ensures that the password cannot be leaked by
inserting images, loading scripts, etc.
%
However, since Workers have access to the \xhr{} constructor,
\https{instagra.me} must additionally host the checker source and set
a CSP policy that restricts its network communication (e.g.,
\texttt{connect-src 'self'}).
\footnote{
  Workers inherit the CSP policy of the containing page~\tocite{csp},
  hence we create the Worker in a ``dummy'' iframe which has the
  policy set.
  %
  We assume that the messaging layers between the Worker, the iframe
  incorporating it, and main page are trivial.
}
%

Unfortunately, this approach is unsatisfactory due to four main reasons.
%
First, to avoid trusting the checker website, the checker source code
must be hosted by \https{instagra.me}, wherein a CSP policy, in the
form of a header, can be used to restrict the checker's communication
capabilities. 
%
This need for server-side support is problematic for developers that
do not have server-side access to set such headers.
%
Second, since this approach requires server-side support to set
security policies this means that the password-strength checker cannot
incorporate code it itself does not trust---the SOP would require
\https{instagra.me} to host all the code and express such security
concerns.
%
Third, the CSP policy of the checker cannot be more restricting than
that of the containing document---hence, the checker can potentially
carry out a self-exfiltration attack~\tocite{self-exfiltration} and
leak the password to a public page on \https{instagra.me}.
%
Finally, this approach cannot be used to confine a password
strength-checker that, for example, fetches a list of commonly used
passwords before checking the strength of the password---a completely
safe operation.
%

\subsubsection{\sys{} approach}
%
In part, the above limitations arise because existing browser
techniques do not allow developers to express confinement, event for
code that does not require DOM access.
%
(Rather today's mechanisms give developers a limited form of access
control.)
%
Addressing these limitations, \sys{} allows developers to treat a
piece of code as untrusted and confine it, in turn.
%
Below we consider confining ``DOM-less'' code; in
Sections~\ref{sec:system:iframe}-\ref{sec:system:script} we address
confinement of third-party code with access to the DOM.

We extend the Worker DOM API~\tocite{workers} with a labeled Worker
(LWorker).
%
Like a standard Worker, an LWorker executes a piece of code in a fresh
browsing context that exposes a limited set of objects and properties.
%
Specifically, we expose the \sys{} API (including the \js|LWorker|
constructor used to construct additional labeled Workers), the \xhr{}
constructor used to perform network requests, and
\js|onmessage|/\js|postMessage| used for communicating with the
parent.
%
Different from the \js|Worker| constructor, the \js|LWorker|
constructor takes an additional argument: a label that specifies the
clearance on the code running in the worker browsing context.

For example, we can create a new LWorker that executes the
password-strength checker code as follows:
\begin{lstlisting}
var url = "https://checker.ru/checker.js";
var l = new Label(window.location.origin);
// 1. Execute checker in new context
var checker = new LWorker(url, l);
\end{lstlisting}
%
Assuming the browsing context (main page) creating the worker has not
enabled ``confinement-mode,'' \sys{} first enables confinement-mode an
sets the page label to the public label (\js|Label()|).
%
Subsequently, we ensure that the current page is allowed to make a
request to \js|url| to fetch the source code.\footnote{
  Since we allow LWorkers to execute inline scripts (via
  data-URLs~\tocite{data-url}) that can be fetched with \xhr{},
  workers scripts are fetched without sending sending
  user-credentials.  This ensures that fetching the script effectively
  only constitutes a write: reading the source will not leak any
  user-sensitive from the provided URL.
}
%
Since the context label corresponds to the public label, performing
the request will not leak any data and thus \sys{} fetches the script
and executes it in the new browsing context, as shown in
Figure~\toref{fig:strength-1}.

The LWorker starts executing the checker code with an initial label
equal to that of the parent (in this case, the public label
\js|Label()|).
%
As shown in Figure~\toref{fig:strength-2}, at this point, the strength
checker may fetch data, such as a list of weak passwords, from the
same origin as the page, or any origins, CORS-permitting.
%
It is important to note that since the checker has not yet read any
sensitive data, as reflected by the context label, this is a
completely safe operation!

To check the strength of the password, the page sends the LWorker the
password with \js|postMessage|, and registers a message handler to
receive the strength score:
\begin{lstlisting}
var password = 
 document.getElementById("password").value;
// 3. Send checker password 
checker.postMessage(password, l);
// 5. Get score
checker.onmessage = function(event) {
  var score = event.data; 
  // ...
}
\end{lstlisting}
Here, the \js|postMessage| takes a second argument: the label of the
message \js|l|.
%
This ensures that the message is dispatched to the checker only if its
context label is at least as sensitive as \js|l|---thus ensuring
that the privacy of \https{instagra.me} is preserved by the checker.

Similarly, \sys{} must ensure that the privacy of data sent by an
LWorker (with \js|postMessage|) is preserved by its parent.
%
Hence, when registering an \js|onmessage| handler on an LWorker,
\sys{} ensures that the context label is at least as restricting as
the worker label.
%
To this end, the context label is ``raised'' to the least restricting
label that allows information to flow from the worker, taking
privileges and clearance into consideration.

In the \https{instagra.me} code above, the context label remains
unchanged when registering the handler since the code ``owns'' the
principal corresponding to the page origin used to label the worker.
%
If the page did not own the \https{instagra.me} privilege it would
have to raise the context label to the label of the worker \js|l|;
%
otherwise data from the worker (which is at least as sensitive as
\js|l|) would be leaked into the less-sensitive context.

To retrieve the password, the password-strength checker in the LWorker
registers a message handler, which is invoked when the parent
sends it a message (step 3 above):
\begin{lstlisting}
// checker.js ...
function checkPassword(pass) { /* ... */ }

// Browbound.label == Label()

// 2. Raise context label & register handler
Browbound.label = Brobound.clearance;
// ...label == Label("https://instagra.me")
onmessage = function(event) {
  var password = event.data;
  // 4. Check score & send it to parent:
  postMessage(checkPassword(password));
};
\end{lstlisting}
%
Here, the LWorker first raises the context label to the clearance by
setting \js|Browbound.label|.
%
In doing so, the code is effectively stating that it is ready to
receive data at sensitivity level \https{instagra.me}, at the cost of
giving up arbitrary network communication privileges.
%
As shown in Figure~\toref{fig:strength-3}, it can now receive the
sensitive password, but it can only use \xhr{} to communicate with
\https{instagra.me};
%
performing arbitrary network requests is no longer permitted.

%
The event handler, which takes the parent-supplied password, invokes
the underlying password-strength checking function \js|checkPassword|.
%
The result of this function is then returned to the parent with
\js|postMessage|.
%
Here, we do not supply \js|postMessage| with a label: the context
label is implicitly used as the label on this message.
%
The full life-cycle of this application is shown in
Figure~\toref{fig:system:strength}.

%
In this example we relied on the page having ownership of the
privilege corresponding to \https{instagra.me} to avoid tainting the
context when reading the score from the checker, labeled with this
principal.
%
Unfortunately, this also means that our confinement of the checker is
limited: we cannot label the context with this label and restrict the
code from using \xhr{} to self-exfiltrate data to \https{instagra.me}.
%
Instead, the page must label the worker with a principal that it owns
and, moreover, does not correspond to an actual origin.

This is precisely the role of fresh privileges.
%
A fresh privilege corresponds to a unique principal/origin whose
scheme is prefixed by \texttt{x-}; this ensures that the \xhr{}
constructor cannot be used to make requests to a corresponding host.
%
Hence, to fully confine the password-strength checker we modify the
\https{instagra.me} page to first create a fresh privilege and use the
corresponding label when creating the LWorker.
%
Th modified code is shown below.
\begin{lstlisting}
// Create fresh unique privilege
var p = new FreshPrivilege();
// Take ownership of this privilege
Browbound.own(p);
// Use it to confine the worker completely:
var checker = new LWorker(url, p.asLabel);
checker.postMessage(password, p.asLabel);
// ...
\end{lstlisting}
%

%
We remarks that, different from current approaches, our system
provides a client-side approach for flexibly and fully confining
untrusted code:
%
the strength checker can perform arbitrary XHR until it raises its
label to register the \js|onmessage| handler that will inspect the
password; from this point on it can only communicate with the parent.
%
This is in contrast to either giving the checker irrevocable network
access or none at all.
%
Moreover, our first-class workers and privileges makes security a
first class citizen: not only can the page consider the checker
untrusted, but if the checker could itself create fresh privileges and
an LWorker in which it can execute code it itself does not consider
trustworthy!

\subsection{Cross-iframes confinement}
\label{sec:system:iframe}
%Password manager 

In the previous section, the \https{instagra.me} page imposed the
requirement that the password-strength checker, executing in an
LWorker, have a sufficiently high context label (such that it cannot
exfiltrate the password) before receiving the password.
%
More generally, our confinement mechanism allows developers to control
where their data flows, even once said data is made available to an
untrusted browsing context.
%
Below, we illustrate the notion of first-class confinement used
in building a mostly untrusted password manager.

\subsubsection{Current approach}
%
Today's browser security mechanisms are not amendable for building a
password manager as a website.
%
Using existing mechanisms users are forced to either trust a password
manager website with their website-specific (e.g., \https{fb.com})
credentials or trust arbitrary websites (e.g., \https{fb.com}) with a
master password they use to protect other site-specific
credentials.\footnote{
  Without loss of generality, we assume client-side encryption where
  the credentials are decrypted by either the password manager or
  \https{fb.com}.
}
%
This issue of handling sensitive data is grave; insomuch, that all
major browsers ship with build-in password managers.
%
A built-in password manager simply requires the user to place more
trust on the browser, which they already trust to handle sensitive
data.
%
Unfortunately, such built-in apps also increases the TCB of the
browser.
%
Moreover, the approach does not scale; do we keep integrating apps
into the browser TCB simply because there exists no mechanism that
allows developers to express security policy on code that handles
sensitive data?

\subsubsection{\sys{} approach}
%
With \sys{}, we can leverage confinement to build a password manager
as a website.
%
Our password manager is
divided into two mutually distrusting components: a
management layer (provided by e.g., \https{pwd.eff.org}) and a storage
layer (provided by e.g., \https{dropcu.be}).
%
This mutual distrust is instrumental to ensuring that neither party
individually can compromise the user's privacy (and thus be wholly
trusted).
%

%
Though a user can use such a password manager to store and fetch
secrets directly, for simplicity, we assume that a website (e.g.,
\https{fb.com}) integrates with the manager to save and load login
credentials,\footnote{
  \Red{TODO: mention the extension stuff}
} as shown in Figure~\toref{fig:manager-s-1}.
%
In this scenario, the security guarantees and trust concerns are as follows.
\begin{itemize}
\item The management layer never learns the site-specific
  (\https{fb.com}) credentials. The user need only trust this
  component with their master password (which without the collusion
  of the storage layer is not useful).
\item The storage layer never learns the site-specific credentials
  or master password. The user need only trust this component to
  not collude with the management layer.
\item Finally, the integrator never learns the master password or
  credentials private to other websites (e.g., \https{goo.gl}).
\end{itemize}
%
Importantly, these guarantees must be preserved when both, the
password manager is used to save and retrieve the credentials.
%
Below we respectively describe the interaction of all the components
in saving and retrieving credentials.

\paragraph{Saving credentials}
%
To save credentials, the integrator, \https{fb.com}, simply opens a
new window (or frame) to the \https{pwd.eff.org} management layer,
sending it a \js|postMessage| with the credentials. 
%
The label of the message is \js|Label("https://dropcu.be")|; this ensures
that the management layer must raise its context label from the public
label to \js|Label("https://dropcu.be")|---thus giving up arbitrary
communication abilities---in order to read the credentials.
%
As shown in Figure~\toref{fig:manager-s-2}, upon receiving the
credentials (\js|credentials|), the management layer requests the
master password (\js|mpass|) from the user, generates a salt
(\js|salt|) and encrypts the credentials using the following key:
$k = H(\texttt{mpass}\|\https{fb.com}\|\texttt{salt})$.
%
(Here, $H$ is a hash function such as SHA-256.)
%
The encrypted credentials and salt are subsequently sent to the
\https{dropcu.be}, who simply stores them.
%

\paragraph{Retrieving credentials}
%
As in the case of saving credentials the integrator, \https{fb.com},
opens a new window to the management layer when wishing to retrieve
user credentials.
%
The management layer in turn creates a frame containing the storage
layer, the request to which encodes that \https{fb.com} credentials
should be fetched.
%
When loaded, the storage layer, containing the encrypted credentials
and salt (\js|E|$_k$\js|(credentials), salt|) immediately taints its
browsing context by setting the context label to
\js|Label("https://fb.com")| (see in Figure~\toref{fig:manager-r-1}).
%
In doing so, the storage layer is effectively stating that the data it
loaded is private to \https{fb.com} and the management layer must be
tainted with a label at least as restricting before it can receive
(via \js|postMessage|) the encrypted credentials.
%
Hence, as shown in Figure~\toref{fig:manager-r-2}, the management
layer taints itself as such, then registers a message handler to
receive the encrypted credentials, and requests the master password
(\js|mpass|) from the user. 
%
The master password and salt are then used to create key $k$, which
used to decrypt the encrypted credentials.
%
Finally, the credentials are subequently sent (via \js|postMessage|)
to the \https{fb.com} browsing context.
%
The latter, as shown in Figure~\toref{fig:manager-r-3}, can then lower
its context label to the public label and use the supplied credentials
to carry out the login procedure.

\paragraph{Discussion}
\Red{TODO} Discuss the protocol and how different parts play an
important role.

%%
Attack scenarios (saving):
\\
What happens if the management layer does not encrypt the data?
Well when we read we can guarantee that only fb sees the data and
nobody else! 
\\
Why can't the management layer send the credentials directly to the
storage layer


\subsection{Relaxing SOP for confined code}
\label{sec:system:mashup}
%Third-party Mashup

\subsection{Privilege separation within iframes}
\label{sec:system:script}
%Phone2Links extension
