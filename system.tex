\section{The \sys{} confinement system}
\label{sec:system}

In \sys, every browsing context has an associated security
\emph{label}, \emph{privilege}, and \emph{clearance}.
%
The label of the browsing context serves as a ``taint,'' indicating
the sensitivity of data the code executing within the context has
read.
%
Labels are specified in terms of \emph{principals}, which
correspond to origins, whose privacy is at stake.\footnote{
  We note that our system also handles integrity, or trust, which
  serves as the dual of privacy.
  %
  For simplicity of exposition we omit integrity from our discussion.
}
%
For example, the label
\js|Label("https://bank.ch").and("https://amazon.com")| specifies that
the context potentially contains data sensitive to \https{bank.ch}
\emph{and} \https{amazon.com}.
%
In turn, \sys{} uses the context label to confine code by restricting
writes---code in the context is restricted to communicating with other
browsing contexts (e.g., using \js|postMessage|) if their labels are at
least as restricting; without privileges, network communication and
local storage is not allowed since the effective labels of these
end-points are less restricting (end-point labels protect the privacy
of a single origin).

Privileges are objects with which code can assert the authority of
principals. 
%
In \sys, scripts are granted the privilege corresponding to the
page origin.
%
For example, a script running in an \https{amazon.com} page has the
privilege of the origin, allowing it to declassify data sensitive to
\https{amazon.com}.
%
Specifically if the context label is
\js|Label("https://bank.ch").and("https://amazon.com")|, this privilege
can be used to downgrade the label to \js|Label("https://bank.ch")|
and, as a result, allow code to communicate with additional browsing
contexts and even perform network requests (to \https{bank.ch}).
%
Importantly, code cannot synthesize arbitrary privileges.
%
For example a  script from \https{amazon.com} cannot create a
privilege for \https{bank.ch}---this would trivially violate any
confinement guarantees;
%
in our system, code can only create the empty privilege
(\js|new Privilege()|) 
and privileges corresponding to fresh, unique principals/origins
(\js|new FreshPrivilege()|).

In ideal confinement systems, code can read arbitrary data at the cost
of raising the context label and thus giving up write privileges.
%
Unfortunately, practical systems typically have covert channels which
may be exploited to leak sensitive data.
%
Hence, as in HiStar~\tocite{histar} and Hails~\tocite{hails}, we use
clearance to impose a limit on the kind of data a piece of code can
access.
%
In \sys, clearance is a label that is used to restrit code from
reading and writing to entities labeled ``above'' this label, i.e.,
more sensitive entities.

In the rest of this section, we describe the \sys{} design through
three concrete examples: 
a password-strength checker (Section~\ref{sec:system:worker}),
a password manager (Section~\ref{sec:system:iframe}), 
a third-party mashup (Section~\ref{sec:system:mashup}), and
an extension that converts phone numbers to links
(Section~\ref{sec:system:script}).  %
%
For completeness, we summarize the different system components and
security mechanisms in Table~\toref{table:components}.

\begin{table*}[t]
\centering
\begin{tabular}{l | m{2.35in} | m{3.5in}}
\hline
\textbf{Component} & \textbf{API} & \textbf{Description} 
\\\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Labels &  
\begin{webidl}
Label {
  Label Label([String])
  Label and(String or Label)
  Label or(String or Label)
  bool subsumes(Label [,Privilege])
}
\end{webidl}
&
\\\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Privileges &  
\begin{webidl}
Privilege {
  Privilege Privilege()
  Privilege FreshPrivilege()
  Privilege and(Privilege)
  Label asLabel(Privilege)
}
\end{webidl}
&
\\\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Context label &  
\begin{webidl}
Browbound {
  prop Label privacyLabel
}
\end{webidl}
&
The context label is used to restrict reads and writes from the
current browsing context.
%
Code can only write to entities above the current label.
%
Code can read from entities whose label is at most as restricting as
the context label---when wishing to read more sensitive data, the
context label can be raised (set) to the more restricting label,
clearance permitting (see below).
%
This comparison between labels (using the current context's
privileges) is the single mechanism used to restrict reads and writes.
\\\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Context clearance  &  
\begin{webidl}
Browbound {
  prop Label privacyClearance
}
\end{webidl}
&
Clearance is a label that is used to restrict access to data.
%
Code cannot read form or write to entities more sensitive than the
clearance.
%
In the case of reads, this simply implies that the clearance is an
upper bound on the context label.
%
The clearance can be set by code running in the context, but only to a
label that is more restricting than the context label and less
restricting than the current clearance.
\\\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Context privileges  &  
\begin{webidl}
Browbound {
  prop Privilege privileges
}
\end{webidl}
&
Privileges are used to relax label comparisons when performing reads
and writes.
%
Code running in the context can get and set the current privileges.
\\\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Labeled Workers  &  
\begin{webidl}
LWorker {
  LWorker LWorker(String, Label)
  LWorker SOLWorker(String, Label)
  postMessage(Object [,Label])
  prop EventHandler onmessage
  void grant(Privilege)
}
\end{webidl}
&
\\\hline %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{tabular}
\caption{\sys{} design components and API}
\end{table*}


\subsection{Confining third-party DOM-less code}
\label{sec:system:worker}
%Password-strength checker: 

Password-strength checkers are common to many websites;
%
given a password input, a checker computes the strength of the
password according to some metric (e.g., length, number of special
characters, etc.).
%
Naturally, when using a third-party password-strength checker
(e.g.,~\tocite{checker1, checker2}) we would like to ensure that the
code does not leak the user's password.
%
A malicious checker should at worst lie about the strength of a
password.

\subsubsection{Current approach}
%
Using existing mechanisms, a page hosted, for instance, on
\https{instagra.me}, can incorporate and partially ``confine'' a
simple third-party strength checker (e.g.,
\https{checker.ru/checker.js}).
%
For simplicity we consider a password strength checker that does not
require access to the DOM.
%
As such, to ``confine'' the strength checker, \https{instagra.me}
can execute the code in a Worker~\tocite{worker};
%
since every worker has a separate, fresh browsing context with no
access to the page DOM, this ensures that the password cannot be
leaked by inserting images, loading scripts, etc.
%
However, workers do have access to the \xhr{} constructor, and, thus,
\https{instagra.me} must additionally host the checker source and set
a CSP policy that restricts its network communication (e.g.,
\texttt{connect-src: 'self'}).
\footnote{
  Workers inherit the CSP policy of the containing page~\tocite{csp},
  hence \https{instagra.me} can create the worker in a ``dummy''
  iframe which has the set policy.
  %
  We assume that the messaging layers between the worker, its parent
  iframe, and main page are straight forward to implement.
}
%

Though this approach (mostly) accomplishes the desired goal of
protecting the password, the approach is widely unsatisfactory.
%
First, to avoid trusting the checker's origin, the checker source code
must be hosted by \https{instagra.me}, wherein a CSP policy, in the
form of a HTTP  header, can be used to restrict the checker's
communication capabilities. 
%
This need for server-side support is problematic for developers that
do not have server-side access to set such headers.
\todo{dherman}{you had a much better argument for why client-side-only
a la developers is so important.}
%
Moreover, the need for server-side support also means that the
password-strength checker cannot incorporate code it itself does not
trust---the SOP would require \https{instagra.me} to host all the code
and express the security concerns of the strength checker as well.
%
Second, the CSP policy of the checker cannot be more restricting than
that of the containing document---hence, the checker can potentially
carry out a self-exfiltration attack~\tocite{self-exfiltration} and
leak the password to a public page on \https{instagra.me}.
%
Finally, this approach cannot be used to confine a password
strength-checker that, for example, fetches a list of commonly used
passwords before checking the strength of the password---a completely
safe operation.
%

\subsubsection{New approach}
%
In part, the above limitations arise because existing browser
techniques do not allow developers to express confinement, even for
code that does not require DOM access.
%
(Rather today's mechanisms give developers a limited form of access
control.)
%
Addressing these limitations, \sys{} allows developers to treat a
piece of code as untrusted and confine it in turn.
%
Below we consider the confinement of ``DOM-less'' code; in
Sections~\ref{sec:system:iframe} and \ref{sec:system:extension} we
address confinement of third-party code with access to the DOM.

As described above, workers are a good first step towards reasoning
about the security implications of untrusted code that does not need
to access the DOM.
%
Hence, we extend the Worker DOM API~\tocite{workers} with a
Labeled-Worker (LWorker).
%
Like a standard worker, an LWorker executes a piece of code in a fresh
browsing context that exposes a limited set of objects and properties.
%
Specifically, we expose the \sys{} API (including the \js|LWorker|
constructor used to construct additional labeled Workers), the \xhr{}
constructor used to perform network requests, and
\js|onmessage|/\js|postMessage| used for communicating with the
parent.
%
Different from the \js|Worker| constructor, the \js|LWorker|
constructor takes an additional argument: a label that specifies the
clearance on the code running in the worker browsing context.

An LWorker is created using the \js|LWorker| constructor, which takes
two arguments: the URL of the code to execute in the worker, and the
worker label.
%
For example, we create a new LWorker that executes the
password-strength checker code as follows:
\begin{jscode}
var url = "https://checker.ru/checker.js";
var label = new Label(window.location.origin);
// 1. Execute checker in new context
var checker = new LWorker(url, label);
\end{jscode}
%
Assuming the browsing context (main page) creating the worker has not
enabled \emph{confinement-mode}, \sys{} first enables confinement-mode
and sets the page label to the public label \js|Label()|.
%
In general, a context can explicitly enable confinement-mode and set
the context label to a label more restricting than the current label;
when enabling confinement-mode implicitly, \sys{} takes a permissive
approach and sets the current label to the public label.
 
Subsequently, we ensure that the current page is allowed to make a
request to \js|url| to fetch the source code.
%
As with loading content (e.g., images, styles and scripts), writing to
storage (e.g., cookies), or performing explicit network requests with
\xhr{}, \sys{} asserts that, given the current context privileges, the
label of the resource---which is implicitly \js|Label(|\emph{resource
origin}\js|)|---subsumes the context label.
%
In this case, \js|Label("https://checker.ru")| subsumes the context
label \js|Label()| and thus fetching the script is permitted.

Before executing the fetched script in a new browsing context, \sys{}
ensures that the label of the worker is at least as restricting as the
current label.
%
Just as the context label protects all data in the context, the label
of a worker protects the data within the worker (as observed by
reading from the worker).
%
This check ensures that the page cannot ``declassify'' data by
laundering it through a worker whose label is less sensitive than the
context label.

As shown in Figure~\toref{fig:strength-1}, \sys{} starts executing the
checker code in the LWorker; the initial, worker context label is set
to that of the parent (in this case, the public label \js|Label()|).
%
At this point, the code can fetch data, such as a list of weak
passwords, from the same origin as the page, or any origins,
CORS-permitting.
%
It is important to note that since the password-strength checker has
not yet read any sensitive data, which is reflected in the context
label, this is a completely safe operation.
%
Only once the code has decided to inspect the password should it not
be able to perform such arbitrary network requests.

To check the strength of the password, the page sends the LWorker the
password via \js|postMessage|, and registers a message handler to
receive the strength score:
\begin{jscode}
var password = 
 document.getElementById("password").value;
// 3. Send checker password 
checker.postMessage(password, l);
// 5. Get score
checker.onmessage = function(event) {
  var score = event.data; 
  // ...
}
\end{jscode}
Here, \js|postMessage| additionally takes the label of the message
\js|l|, which must be at most as restricive as the worker label.
%
(If an explicit label is not supplied to \js|postMessage|, \sys{}
uses the context label of the sender as the message label.)
%
We use this label to ensure that the message is dispatched to the
checker only if its context label is at least as sensitive as
\js|l|---thereby preserving the privacy of the password (which is
protected by \js|l == Label("https://instagra.me")|.

To retrieve the password, the password-strength checker registers a
message-event handler, which is invoked when the parent sends it a
message (step 3 above):
\begin{jscode}
// checker.js ...
// Browbound.label == Label()
function computeStrength(pass) { /* ... */ }

// 2. Raise context label & register handler
Browbound.label = Browbound.clearance;
// Browbound.label == Label("https://instagra.me")
onmessage = function(event) {
  var password = event.data;
  // 4. Check score & send it to parent:
  postMessage(computeStrength(password));
};
\end{jscode}
%
Importantly, the worker first raises the context label to the
clearance, which is the worker label, by setting \js|Browbound.label|.
%
In doing so, the code is effectively stating that it is ready to
receive data at sensitivity level \https{instagra.me}, at the cost of
giving up arbitrary communication privileges.
%
As shown in Figure~\toref{fig:strength-3}, the checker can now receive
the sensitive password, but, for example, can only use \xhr{} to
communicate with \https{instagra.me};
%
performing arbitrary network requests or creating arbitrarily labeled
workers is no longer permitted.

Finally, the event handler, which is supplied with the parent-supplied
password, invokes the underlying password-strength checking function
\js|computeStrength|.
%
The result of this function is returned to the page via
\js|postMessage|.
%
Since the page registered an event handler (step 5), as shown in
Figure~\toref{fig:system:strength-4}, \sys{} ensures that the label of
the parent context is at least as restrcting as the message label
(which is the worker context label) and then dispatches the handler.
 
The full life-cycle of this application is shown in
Figure~\toref{fig:system:strength}.
%
In this example we relied on the page having ownership of the
\https{instagra.me} privilege as to avoid tainting the context when
reading the score from the checker worker, which was labeld with this
principal.
%
Unfortunately, this also means that our confinement of the checker is
limited: we cannot label the context with this label and restrict the
code from using \xhr{} to self-exfiltrate data to \https{instagra.me}.
%
Instead, the page must label the worker with a principal that it owns
and, moreover, does not correspond to an actual origin.

This is precisely the role of fresh privileges.
%
A fresh privilege corresponds to a unique principal/origin whose
scheme is prefixed by \texttt{x-}; this ensures that the \xhr{}
constructor cannot be used to make requests to a real host.
%
Hence, to fully confine the password-strength checker we modify the
\https{instagra.me} page to first create a fresh privilege and use the
corresponding label when creating the LWorker.
%
Th modified code is shown below.
\begin{jscode}
// Create fresh unique privilege
var p = new FreshPrivilege();
// Take ownership of this privilege
Browbound.own(p);
// Use it to confine the worker completely:
var checker = new LWorker(url, p.asLabel);
// As before ..
var password = 
 document.getElementById("password").value;
// 3. Send checker password 
checker.postMessage(password, p.asLabel);
// ...
\end{jscode}

\paragraph{Discussion}
Different from current approaches, our system provides a client-side
approach for flexibly and fully confining untrusted code:
%
the strength checker can perform arbitrary XHR until it raises its
label to register the \js|onmessage| handler that will inspect the
password; from this point on it can only communicate with the parent.
%
This is in contrast to either giving the checker irrevocable network
access or none at all.
%
Moreover, our first-class workers and privileges makes security a
first class citizen: not only can the page consider the checker
untrusted, but the checker can itself create fresh privileges and a
LWorkers in which it can execute code it itself does not consider
trustworthy!

\subsection{Cross-iframes confinement}
\label{sec:system:iframe}
%Password manager 

In the previous section, the \https{instagra.me} page imposed the
requirement that the password-strength checker, executing in an
LWorker, have a sufficiently high context label such that it cannot
exfiltrate the password; otherwise \sys{} would not dispatch the
password message.
%
In general, our confinement mechanism allows developers to control
where their data can flow, even after said data is made available to
an untrusted browsing context.
%
Below, we extend our notion of first-class confinement to iframes by
describing the design of a mostly untrusted password manager--- an
application that allows users to use a single master password to
manage multiple site-specific passwords.

\subsubsection{Current approach}
%
Today's browser security mechanisms are not useful when building a
password manager as a website.
%
Specifically, the lack of confinement forces users to either trust the
password manager website with their website-specific (e.g.,
\https{fb.com}) credentials or trust arbitrary websites (e.g.,
\https{fb.com}) with the master password that is used to to protect
other credentials.
%
This issue of handling sensitive data is grave; insomuch, that all
major browsers ship with build-in password managers.
%
A built-in password manager simply requires the user to place more
trust on the already-trusted browser.
%
Unfortunately, such built-in apps increase the TCB of the browser and
don't always behave as desired (e.g., some password managers fill in
forms with credentials before the form is submitted---making the
password available to potentially untrustworthy JavaScript code).
%
Moreover, the approach does not scale: are we to integrate apps into
the browser TCB simply because there exists no mechanism that allows
developers to express security policy on code that handles sensitive
data?

\subsubsection{\sys{} approach}
%
With \sys{}, we can leverage confinement to build a password manager
as a website.
%
Our password manager is divided into two mutually distrusting
components: a management layer (provided by e.g., \https{pwd.eff.org})
that interacts with the user to store and fetch credentials, and a
storage layer (provided by e.g., \https{dropcu.be}) that provides a
simple (effectively labeled) server-side storage API for the
management layer.
%
The mutual distrust between the layers is instrumental to ensuring
that neither party can individually compromise the user's privacy (and
would thus have to be wholly trusted).
%

%
Though a user can use such a password manager to store and fetch
secrets directly, for simplicity, we assume that a website (e.g.,
\https{fb.com}) integrates with the manager to save and load login
credentials,\footnote{
  In Section~\ref{sec:system:extension} we describe an untrusted
  extenion system that can be used to inject the password-manager
  specific code into the integrator page.
} as shown in Figure~\toref{fig:manager-s-1}.
%
Without loss of generality we also assume that encryption and
decryption is carried out on the client-side by the management layer.
%
The security guarantees and trust concerns of this app are as follows:
\begin{enumerate}
\item The management layer never learns the site-specific
  (\https{fb.com}) credentials. The user need only trust this
  component with their master password (which without the collusion of
  the storage layer is not useful); to remove this trust, users can
  inspect the label of a browsing context using standard developer
  tools or by right-clicking on the page (a functionality implemented
  by the \sys{} supporting extension, describe in
  Section~\toref{XXX}).
\item The storage layer never learns the site-specific credentials
  or master password. The user need only trust the management layer to
  not collude with this layer.
\item Finally, the integrator never learns the master password or
  credentials private to other websites (e.g., \https{goo.gl}).
\end{enumerate}
%
Importantly, these guarantees must be preserved when both, the
password manager is used to save and retrieve the credentials.
%
Below we respectively describe the interaction of all the components
in saving and retrieving credentials.

\paragraph{Saving credentials}
%
To save credentials, the integrator, \https{fb.com}, simply opens a
new window (or frame) to the \https{pwd.eff.org} management layer,
sending it a \js|postMessage| with the credentials. 
%
The label of the message is \js|Label("https://fb.com")|; this ensures
that the management layer must raise its context label from the public
label to \js|Label("https://fb.com")|---thus giving up arbitrary
communication abilities---in order to read the credentials.
%
As shown in Figure~\toref{fig:manager-s-2}, upon receiving the
credentials (\js|credentials|), the management layer requests the
master password (\js|mpass|) from the user, generates a salt
(\js|salt|) and encrypts the credentials using the following key:
$k = H(\texttt{mpass}\|\https{fb.com}\|\texttt{salt})$.
%
(Here, $H$ is a hash function such as SHA-256.)
%
The encrypted credentials and salt are subsequently sent back to the
\https{fb.com}, who simply forwards them to \https{dropcu.be} (using
\js|postMessage| labeled with the public label). 
%
The \js|dropcu.be|'s sole role is to store the data on the
server-side.
%

%

\paragraph{Retrieving credentials}
%
As in the case of saving credentials the integrator, \https{fb.com},
opens a new window to the management layer when wishing to retrieve
user credentials.
%
The management layer in turn creates a frame containing the storage
layer, the request to which encodes that \https{fb.com} credentials
should be fetched.
%
When loaded, the storage layer, containing the encrypted credentials
and salt (\js|E|$_k$\js|(credentials), salt|) immediately taints its
browsing context by setting the context label to
\js|Label("https://fb.com")| (see in Figure~\toref{fig:manager-r-1}).
%
In doing so, the storage layer is effectively stating that the data it
loaded is private to \https{fb.com} and the management layer must be
tainted with a label at least as restricting before it can receive
(via \js|postMessage|) the encrypted credentials.
%
(This ensures that even if the management layer did not encrypt the
credentials during the storage procedure, it cannot learn the
credentials through the retrieval process.)
%
Hence, as shown in Figure~\toref{fig:manager-r-2}, the management
layer taints itself as such, then registers a message handler to
receive the encrypted credentials, and requests the master password
(\js|mpass|) from the user. 
%
The master password and salt are then used to create key $k$, which
used to decrypt the encrypted credentials.
%
Finally, the credentials are subsequently sent (via \js|postMessage|)
to the \https{fb.com} browsing context.
%
The latter, as shown in Figure~\toref{fig:manager-r-3}, can then lower
its context label to the public label and use the supplied credentials
to carry out the login procedure.


\paragraph{Design trade-off}

Our password manager relies on mutual distrust between the different
layers to guarantee that the user's credentials are preserved.
%
This novel scenario, however, has influenced much of the design
choices that make our system different from existing password
managers.
%
We highlight two trade offs:
\begin{itemize}
\item
We use the integrator origin in addition to the master
password and salt in the key used to encrypt credentials.
%
In doing so, the management layer ensures that a malicious storage
layer will not be able to confuse it, during the retrieval process,
into decrypt \https{fb.com}'s when serving \https{goo.gl} (and
thereby preserving guarantee 2 and 3).
%
This is different from most password managers that use a single key
to encrypt all entries.
%
\item 
When saving credentials , \https{fb.com} is expected to send the
encrypted credentials to the storage layer.
%
This ensures that the management layer cannot (effectively) deceive
the storage layer into storing \https{fb.com}'s encrypted data with a
different origin, e.g., \https{goo.gl}, and thus violate our first two
guarantees.
%
Unfortunately, and unlike retrieving credentials, when this implies
that when saving credentials the storage layer is not transparent to
the integrator, which is usually the sole password-management
interface.
%
\end{itemize}

\subsection{Privilege separation within iframes}
\label{sec:system:extension}
%Phone2Links extension
\Red{TODO: change section title; this should talk about stashing
privileges and extending LWorkers with DOM objects}


\subsection{Relaxing SOP for confined code}
\label{sec:system:mashup}
%Third-party Mashup
%
\sys{} restricts the communication capabilities of a
browsing context once it has read sensitive data, i.e., cross-origin
data from another browsing context.
%
As envisioned in~\tocite{hotos}, by equipping the browser with such
confinement mechanism we can safely relax the SOP.
%
This, in turn, allows developers to build applications that access
cross-origin data---in a safe manner---to build applications that are
not otherwise possible today.
%
As an example, we consider third-party mashups.

In a third-party mashup, a party, such as \https{mint.ru},
incorporates user-sensitive data from unaffiliated parties, such as
\https{bank.ch} and \https{amazon.com}, to present users with new
interfaces or functionality.
%
The third party, \https{mint.ru}, may wish to present the user with a
visualization of their spending habits, or identify fraudulent
\https{amazon.com} purchases using their \https{bank.ch} account, etc.
%
Of course, SOP does not allow \https{mint.ru} to access the user's
\https{amazon.com} and\https{bank.ch} data, e.g., using \xhr{}, unless
the parties explicitly trust \https{mint.ru} by setting correct CORS
headers~\tocite{CORS}.

However, with \sys{} we can allow \https{mint.ru} to access such data,
provided that future writes respect the privacy of the retrieved data.
%
To this end, we can allow code executing in certain labeled workers to
inspect the response of an \xhr{} request at the cost of raising the
context label (and thereby giving up write-privileges).
%
These cross-origin labeled workers (COLWorkers), are identical, in
both their API and semantics to the LWorkers detailed in
Section~\ref{sec:system:worker}, and only differ in two ways.
%
First, the privacy label supplied to the \js|COLWorker| constructor
must correspond to a single origin (e.g.,
\js|Label("https://bank.ch")|); conversely, the \js|LWorker|
constructor does not impose any restrictions on the label.
%
Second, \xhr{} responses from this origin can be inspected by the
COLWorker code, regardless of the page (that created the COLWorker)
origin or explicit CORS headers set on the response.
%
This is different from LWorkers, who can only inspect \xhr{} responses
according to 1) SOP: the worker can inspect responses from the origin
of the document containing the LWorker, and 2) CORS: the worker can
inspect a response from any origin if flexible CORS headers accompany
the response.

\Red{Put somewhere:

Communication between different browsing contexts is dictated by the
context label.
%
A \js|postMessage| from browsing context \js|A| will be
sent to browsing context \js|B| if
\js|B.privacyLabel.subsumes(A.privacyLabel, A.privileges)|,
i.e., the label of the label on the message payload on the receiving
end is at lest as restricting.
%
\Red{Our labeled \js|postMessage| API is given below.}

Similarly, loading content, writing to local storage (including
cookies), and performing explicit HTTP requests with \xhr{} requires
that the current label be at most as restricting as the label of the
resource.
The implicit label of such entities corresponds to the origin named in
the resource URL. For example, when loading a script (with the
\js|<script>| tag) from \https{jquery.com} the label of the resource
is implicitly \js|Label("https://jquery.com")|.

%

}
