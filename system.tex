\section{The \sys{} confinement system}
\label{sec:system}

In this section, we describe the \sys{} system.
%
As mentioned previously, the basic unit of confinement in \sys{}---a
compartment---corresponds to a JavaScript execution context, e.g.\@ a
browser tab, an iframe on a page, or even a Web Worker~\cite{workers}.
\footnote{We also introduce a new type
of Web Worker called a DOM Worker which shares a DOM with its parent.
These workers run synchronously with the parent (rather than in parallel)
and are solely used for confinement: think of them as iframes
without DOMs of their own.  See Section~\ref{sec:apps-third-party} for
one useful use-case for this feature.}
%
\sys{} associates each compartment and web site with a security policy,
which specifies the kind of messages and requests which are permitted to
flow to other compartments and web sites.
%
In order to maintain backwards-compatibility, this security policy is
applied on top of the old same-origin policy for existing browser APIs,
merely allowing developers to apply more restrictive policies than
SOP\@.
%
To relax the same-origin policy, \sys{} also introduces variants of
these APIs (most notably labeled XHR, see Section~\Red{ref}) which don't
respect same-origin policy and consequently allow more
use-cases.\footnote{Relaxing the same-origin policy in a way that's
secure and maintains backwards-compatibility is subtle, and we directly
address this issue in Section~\ref{sec:labeled-xhr}}

The security policy of a container consists of two components:

\begin{itemize}
    \item A current label (Section~\ref{sec:labels}), which indicates the
        sensitivity of the data in the container, and
    \item A set of privileges (Section~\ref{sec:privileges}), which
        dicates what authority the compartment's code has to
        \emph{relax} policy requirements.
%   \item A clearance (Section~\ref{sec:clearance}), which imposes a
%       limit on the sensitivity of the data in the container.
\end{itemize}

We describe each of these components in turn in the following sections,
and then we describe how these policies apply to XMLHttpRequest in more detail (Section~\ref{sec:labeled-xhr}).

\subsection{Labels}
\label{sec:labels}

The \emph{current label} protects all data associated with a compartment or
web site, specifying what origins can read the data.
%
Individual pieces of data can also be labeled: \sys{}
introduces opaque \emph{labeled blobs} for this purpose.
%
The particular labels that are used in \sys{} are \emph{DC labels},
presented in~\cite{stefan:2011:dclabels}.
%
We chose DC labels, much like Hails~\cite{giffin:2012:hails} and
Breeze~\cite{Breeze13}, because they have a simple
semantics while being as expressive as the labels used by other practical
confinement systems~\cite{GenLabels}.
%
In this section, we briefly describe DC labels; an interested
reader should see~\cite{stefan:2011:dclabels} for more details.

A privacy label (henceforth just label) is a boolean formula over
origins.%
%
\footnote{
  Our system also handles \emph{integrity}, but it is omitted from
  the discussion for simplicity, as most web applications operate at the
  public level of integrity.
}
%
When a compartment wishes to send a message to another compartment or
web site, we check if the target label $l'$ logically implies the source
label $l$.
%
Intuitively, this requires that the security of the destination be as strong as original security policy, i.e.\ that the target label \emph{subsumes} the source label.\footnote{If the communication is bidirectional, e.g.\ mutation of a shared DOM, then both the target and source must imply each other.}
%
For example, to read the contents of a labeled blob, we must check that
the label of the compartment subsumes the label of the blob.
%
In the password checker, the labeled blob containing the password (2)
cannot be read by a publically labeled worker (corresponding to the
logical formula ``true''), because ``true'' does not imply
``\https{fb.us}''.
%
However, once the worker raises its label to ``\https{fb.us}'', the
logical implication holds trivially.

%Reworded version: Intuitively, an entity is allowed to receive data that is at most as
%sensitive as its label, i.e., the entity's label always \js|subsumes|
%the label of the data it can receive, preserving the latter's privacy.
%   \Red{maybe something about how this makes it first
%   class: the fact that policies are preserved means that if a library has
%   sub-libraries, they will get the appropriate policy enforced}
%
Why is a label represented as a boolean formula rather than simply
as a set of origins?
%
As it turns out, both conjunctions (``and'')
and disjunctions (``or'') are useful for specifying security policies.
%
Informally, a conjunction describes what origins contributed sensitive data
to the compartment, while a disjunction describes what origins are allowed
to read the data.
%
% EZY: Unfortunately, I can't use the password checker here because
% the labels are too simple
A compartment with the label ``\https{bank.ch} and \https{amazon.com}''
may contain sensitive data from both sites, so it cannot send data to
\https{bank.ch}, as doing so might leak private information from
\https{amazon.com} (and vice versa).
%
Conversely, a compartment labeled ``\https{bank.ch} or \https{amazon.com}''
could send data to either website; however, it could not receive any
messages from either origin---it might have originally been public data
whose sensitivity was raised so that no other site could read it.

How is the current label initially determined?
%
\sys{} extends the API of iframes and workers so that when they are
created, a particular current label can be assigned to it (which
must subsume the parent's label).  Otherwise, new containers implicitly
inherit the label of its parent.\footnote{Perceptive readers may now be wondering how
the password checker arranged to create a publically labeled worker
when its label was \https{fb.us}.  In fact, doing so is not possible
to do so without privileges (Section~\ref{sec:privileges}).}
%
For web pages proper, we look for a {\tt Document-label} header which
specifies the initial label, defaulting to public (i.e.\ no extra
restrictions) when this header is not present.
%
After creation, a compartment can freely \emph{raise} its label, i.e.\
change its label to any label which subsumes it, but not vice versa.
%
This leads to a common interpretation of labels as ``taint;'' as
a compartment receives data from more sources, it accumulates more
conjuncts on account of raising its label to read the received data.

\subsection{Privileges}
\label{sec:privileges}

% Description of privileges
A \emph{privilege} is an object, representing an origin, which confers
the authority to relax policy requirements with respect to this origin.
%
While privileges can be used in a variety of ways, their basic mechanism
is quite simple:  whenever a compartment with a privilege $p$ performs a
label check, instead of checking that $l'$ implies $l$, we check that
$l'$ and $p$ implies $l$.

There are two primary use-cases for privileges:

\begin{itemize}
    \item A privilege can be used to \emph{declassify} private
        information without raising the current label.  For example, we
        could downgrade ``\https{amazon.com}'' labeled data to
        ``public''; we could even downgrade it to ``\https{amazon.com}
        or \https{bank.ch}'' (recall that this data can be read only
        either origin, but no others).

    \item A privilege can be used to lower the current label of
        a compartment (or a compartment that is being created).
        This is how privileges are used
        in the password checker: the untrusted worker was created
        with a current label of ``public'' by exercising the
        \https{fb.us} privilege in the main web site.  Conceptually, we
        are declassifying \emph{all} of the data associated with the
        compartment.
\end{itemize}

In \sys{}, privileges are \emph{implicitly} exercised: if a compartment
has a privilege, it will always attempt to use it.  To force a label
check without the privilege, a privileged compartment can wrap the
data in question as a labeled blob.  In the password checker, the main
page must do precisely this, as it has the \https{fb.us} privilege.
Without labeling the password, it could accidentally leak the password
to a publically labeled worker.

% Initial privileges and privilege creation
By default, a browsing context has the privilege corresponding to the
page origin; this context can drop the privilege if it is not
needed or spawn other containers sans privilege to run untrusted code.
%
While privileges for existing origins cannot be created, a privilege can
be created for a fresh origin, i.e.\ an origin which does not correspond
any actual web site, but which is guaranteed to be unique.
%
A fresh origin is often used to run code under full isolation, since any
compartment labeled with the fresh origin cannot communicate with any
other compartment without exercising the corresponding privilege.
%
Importantly, any code can allocate a origin-privilege pair: this
makes isolation an egalitarian security mechanism: an untrusted library
can use this mechanism to isolate a sub-library that it itself
may not trust~\cite{Zeldovich:2006}.

\subsection{Labeled XMLHttpRequest}
\label{sec:labeled-xhr}

In the previous sections, we described the general design principles
behind the security policies on compartments.
%
In this section, we concretely describe the implication of these
policies on one particular API function: XMLHttpRequest (XHR).
%
XHR is an interesting because: (1) the added \sys{} policy checks are
representative of those of other web browser APIs, (2) the API
interacts with servers, so it is important to explain how HTTP headers are
handled, and (3) the variant of this API called \emph{labeled XHR} is
the only component of \sys{} which relaxes the same-origin policy.

A traditional XHR request is composed of two parts: a write to an
external origin (sending the request), and then a read from the external
origin (reading the response, which may be restricted under the
same-origin policy).
%
\sys{} adds two new checks: before initiating a
request, we check to see if the label of the origin subsumes the label
of compartment, and if the reader attempts to read the request, we check
to see if the label of the compartment subsumes the label of the response
(which may be explicitly labeled with the {\tt Document-label} header).

If the server is IFC enabled, it may be interested in the current label
of the compartment which initiated the request, to determine the
sensitivity (and integrity) of the request.
%
Thus, the XHR request is also labeled with a {\tt Document-label} header.
%
We extended the send function of XHR to also accept labeled blobs,
which explicitly specify the transmitted label header (and disallow
JavaScript from manually setting this header).

Since normal XHR always checks the same-origin policy, it would be
useful to provide \emph{labeled XHR} which relaxes this requirement.\footnote{As a small note, we still enforce other browser security policies such as CSP.}
%
Intuitively, a safe way to relax the same-origin policy is to allow
cross-origin code to read the result of a response, as long as it
commits to performing no further communication.
%
This must include communication to the \emph{same} origin, since these requests
carry the risk of self-exfiltration~\Red{cite} and cross-site request
forgery.
%
To fulfill this requirement, labeled XHR returns its result as a labeled
blob, protected with a server-specified label that defaults to a \emph{fresh}
origin (Section~\ref{sec:privileges}).
%
A server that is protected against self-exfiltration and cross-site
request forgery using end-to-end labels can relax this requirement by
only labeling a result with its own origin.

In an ideal confinement system, it would always be safe to let untrusted
code compute on sensitive data.
%
Unfortunately, practical systems typically have covert channels which
may be exploited to leak sensitive data.
%
Hence, keeping with HiStar~\cite{Zeldovich:2006},
Hails~\cite{giffin:2012:hails}, and Breeze~\cite{Breeze13}, we associate
a \emph{clearance} with every compartment: the compartment is not
allowed to raise its label higher than the clearance or raise its
clearance without an appropriate privilege.
%
The default clearance is \emph{user-controlled}; a user can thus disable
labeled XHR by configuring the clearance of a page to be just
its origin.
%
A user can also selectively enable labeled XHR on specific sites; a
mash-up would ask the user to raise its clearance accordingly.
%
Importantly, raising the clearance does \emph{not} give a mash-up free reign:
the code is still confined.
%
It can only exfiltrate data via a covert channel while the user
is on the web site---a strict improvement over existing mash-ups which
\emph{ask for your password}.

%\subsection{Backwards compatibility}
%\label{sec:bc}
%
%With any new browser feature like \sys{}, one must be prepared for the
%vast majority of clients and servers to have the feature unimplemented.
%Thus, a critical question for \sys{} is whether or not it securely
%interoperates with browsers and servers which are not \sys{}-aware.
%We consider each of these cases in turn.
%
%\paragraph{Unsupported clients}  Like most new web features, if
%a browser does not support the feature, the web site will not
%work.  While this is fine for applications like the encrypted
%document editor or third-party mashup, which are simply unimplementable
%in the current web architecture, this is less than ideal for applications
%like the password checker or users of jQuery, which may only be interested
%in using \sys{} for defense-in-depth.
%
%For cases like this, we implemented a simple wrapper library for \sys{}
%which can fall back to the basic APIs without any extra policy checks
%when a browser does not support \sys{}.  Without \sys{}, the confinement
%of the application is no worse than if the user had developed it the usual
%way.
%
%%   As a side note, a \sys{}-enabled server can easily check if a client
%%   is \sys{}-enabled by looking for a {\tt Document-label} in requests.\footnote{In particular, it should reject pre-flight requests for {\tt Document-label}, which indicated some code on a non-\sys{}-enabled client attempted to forge a request label.}
%
%\paragraph{Unsupported servers}  \sys{}'s features which impose further
%restrictions on the same-origin policy can be used without any
%cooperation from the server.  The most important case are features
%of \sys{} which relax the same-origin policy.  Previous systems which
%allowed this relaxation, such as Cross-Origin Resource Sharing (CORS)
%require opt-in from the server in question.  However, an important
%application of \sys{} is to be able to use web sites in ways that were
%not originally anticipated by the site owner.  We apply a very stringent
%restriction to labeled XHR\@; labeling these responses with a fresh origin
%is critical as it prevents arbitrary JavaScript from trivially bypassing
%cross-site request forgery protection of web sites.

%   \subsection{Clearance}
%   \label{sec:clearance}

%   \emph{Clearance} is a label which imposes a limit on the kind of data a compartment can have,
%   i.e., it is an upper-bound on compartment label, and thus the kind of
%   data a piece of code executing in the compartment can access.
%   %
%   In an ideal confinement system, code can read arbitrary data at the
%   cost of raising the context label (and thus giving up write
%   capabilities).
%   %
%   Unfortunately, practical systems typically have covert channels which
%   may be exploited to leak sensitive data.
%   %
%   Hence, as in HiStar~\cite{Zeldovich:2006}, Hails~\cite{giffin:2012:hails}, and
%   Breeze~\cite{Breeze13} we associate a \emph{clearance} with every
%   compartment: the compartment is not allowed to raise its label higher
%   than the clearance.

%   \Red{Clearance choice by user? We need to know what the default
%       clearance is.  The attack model is kind of funny: we want to argue
%       that covert channels are obvious (e.g. crashing your browser) or low
%       bit-rate; i.e. set in such a way that opting in to run the untrusted
%   code on the sensitive data is materially less harmful than if the
%   untrusted code ran automatically}

%   In \sys{}, the clearance assigned to browsing contexts is primarily a
%   choice made by the user.
%   %
%   ``Do I want to give this mash-up website (confined) access to my
%   bank statement?''  In absence of covert channels, the user's choice
%   makes no difference
%   \Red{Similarity to content scripts}

%   For completeness, we summarize  \sys{}'s API for compartments
%   in Figure~\ref{systemAPI}. In the next subsection, 
%   we explain the purpose of the different primitives through examples. 
%   We remark that \sys{}'s API is designed to be minimalistic, and as such, it only
%   consists on the primitives shown in Figures~\ref{fig:APIspec} and
%   \ref{systemAPI}.

%   In the rest of this section, we expand on the \sys{} design by
%   introducing mechanisms that meet the requirements of the four
%   example applications described in Section~\ref{sec:goals}.
%% through
%% three concrete examples: 
%% a password-strength checker (Section~\ref{sec:system:worker}),
%% a password manager (Section~\ref{sec:system:iframe}), 
%% a third-party mashup (Section~\ref{sec:system:mashup}), and
%% a library that converts phone numbers to links
%% (Section~\ref{sec:system:script}--Section~\ref{sec:system:extension}).
%
%For completeness, we summarize the different system components,
%security mechanisms, and DOM API (using WebIDL-like syntax), in
%Table~\toref{table:components}.


% Implementation notes:
% postMessage: receiver subsumes sender
% DOM: receiver =_p sender plus DOM access label =_p sender

% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-default: "Make"
% End:

