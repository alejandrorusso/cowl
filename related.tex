\section{Related Work}
\label{sec:related}


% JSFlow 
Tracking IFC at the granularity level of JavaScript instructions is indeed
challenging. The main reason for that being the need for tracking hysterical
amounts of side-effects, e.g., implicit coercions, live collections updates, and
others. Hedin and Sabelfeld~\cite{Hedin:2012} formally describe a sound IFC for
a subset of JavaScript and their ideas are being currently applied to
JSFlow~\Red{think how to cite this since it is unpublished}, a IFC-aware
JavaScript interpreter.  JSFlow is designed to apply IFC in legacy code, and
because of that, it does an impressive effort to obtain fine-grain IFC. This is
achieved at the price of proposing detailed models for capturing big parts of
the browser semantics (e.g. interaction with the DOM). We provide a more
coarse-grain approach: \emph{we do not care for most of the JavaScript and DOM
  API internals}. Instead, \sys~ uses IFC-aware compartments (LWorkers and
iframes) and simply mediates among them to preserve security. With our approach,
webpage developers can obtain fine-grain IFC by restructuring their code
for security reasons.

% BFlow
BFlow is a IFC system for web browsers. It tracks flows of information at the
granularity of \emph{secure zones}, i.e., compartments composed of one or
several iframes.  {\sys} does not require such abstraction, it relies on the
compartment notions already provided by browsers, i.e., iframes and
workers. Similar to our approach, BFlow uses \js|postMessage| for communication
across secure zones. BFlow does not allow JavaScript code in different secure
zones to write to shared DOM variables and cookies regardless their 
security labels.  While \sys~ supports more expressive labels, potentially
including different domains, BFlow can propagates labeled data to the server
side. It is stated as future work to achieve a similar feature.

% Javascript Sandboxing: JSand and TreeHouse
Focusing on different security policies, several language-based approaches has
been divised to sandbox Javascript.  These approaches usually work in a similar
manner: they mediate security critical operations and some of the browser API
(e.g. the DOM).
% JSand
JSand~\cite{Agten:2012:JCC} wraps setters (\js|set|) and getters (\js|get|) of Javascript
objects. Additionally, it propagates policies to newly created objects via a
membrane pattern~\cite{RobustComposition}. Application-specific DOM-nodes are freely accessed
withtin the sandbox. For global properties (e.g. \js|window.document|), JSand
simply wraps the \js|window| object in order to enforce a given policy.
% TreeHouse
Similar to our work, TreeHouse~\cite{Ingram:2012} uses workers to provide a
fresh and isolated execution context for Javascript code. Workers communicate by
\js|postMessage|, which guarantees that no references to outside objects can be
passed into the sandbox. TreeHouse provides virtualized DOM-nodes with the
restriction that workers cannot share them.
% Limitations
Aiming to target legacy code, JSand and TreeHouse present some limitations
related to performance and completeness.
% Performance
While exposing significant performance degradation in micro benchmarking (in
some cases more than 400\%!), authors claim that the impact on the user
experience is acceptable.
% Completeness
On the completeness side, JSand parses dynamically loaded scripts either
asynchronously, potentially changing the semantics of the application, or
through a library, which might interpret them differently from the
browser. Similarly, TreeHouse changes a synchronous call semantics to the DOM
API by an asynchronous one.


%


% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-master: "make"
% tex-dvi-view-command: "gmake preview;:"
% End:
