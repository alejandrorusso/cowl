\section{Related Work}
\label{sec:related}


% JSFlow 
Tracking IFC at the granularity level of JavaScript instructions is indeed
challenging. The main reason for that being the need for tracking hysterical
amounts of side-effects, e.g., implicit coercions, live collections updates, and
others. Hedin and Sabelfeld~\cite{Hedin:2012} formally describe a sound IFC for
a subset of JavaScript and their ideas are being currently applied to
JSFlow~\Red{think how to cite this since it is unpublished}, a IFC-aware
JavaScript interpreter.  JSFlow is designed to apply IFC in legacy code, and
because of that, it does an impressive effort to obtain fine-grain IFC. This is
achieved at the price of proposing detailed models for capturing big parts of
the browser semantics (e.g. interaction with the DOM). We provide a more
coarse-grain approach: \emph{we do not care for most of the JavaScript and DOM
  API internals}. Instead, \sys~ uses IFC-aware compartments (LWorkers and
iframes) and simply mediates among them to preserve security. With our approach,
webpage developers can obtain fine-grain IFC by restructuring their code
for security reasons.

% BFlow
BFlow~\cite{Yip:2009:PBS} is a IFC system for web browsers. It tracks flows of
information at the granularity of \emph{secure zones}, i.e., compartments
composed of one or several iframes.  {\sys} does not require such abstraction,
it relies on the compartment notions already provided by browsers, i.e., iframes
and workers. Similar to our approach, BFlow uses \js|postMessage| for
communication across secure zones. BFlow does not allow JavaScript code in
different secure zones to write to shared DOM variables and cookies regardless
their security labels.  While \sys~ supports more expressive labels, potentially
including different domains, BFlow can propagates labeled data to the server
side. It is stated as future work to achieve a similar feature.



% Javascript Sandboxing: JSand and TreeHouse
Focusing on different security policies, several language-based approaches has
been divised to sandbox Javascript.  These approaches usually work in a similar
manner: they mediate security critical operations and some of the browser API
(e.g. the DOM).
% JSand
JSand~\cite{Agten:2012:JCC} wraps setters (\js|set|) and getters (\js|get|) of Javascript
objects. Additionally, it propagates policies to newly created objects via a
membrane pattern~\cite{RobustComposition}. Application-specific DOM-nodes are freely accessed
withtin the sandbox. For global properties (e.g. \js|window.document|), JSand
simply wraps the \js|window| object in order to enforce a given policy.
% TreeHouse
Similar to our work, TreeHouse~\cite{Ingram:2012} uses workers to provide a
fresh and isolated execution context for Javascript code. Workers communicate by
\js|postMessage|, which guarantees that no references to outside objects can be
passed into the sandbox. TreeHouse provides virtualized DOM-nodes with the
restriction that workers cannot share them.
% Limitations
Aiming to target legacy code, JSand and TreeHouse present some limitations
related to performance and completeness.
% Performance
While exposing significant performance degradation in micro benchmarking (in
some cases more than 400\%!), authors claim that the impact on the user
experience is acceptable.
% Completeness
On the completeness side, JSand parses dynamically loaded scripts either
asynchronously, potentially changing the semantics of the application, or
through a library, which might interpret them differently from the
browser. Similarly, TreeHouse changes a synchronous call semantics to the DOM
API by an asynchronous one.


% DCS 
Recently, and different from other sandboxes approaches, the data-confined
sandbox system~\cite{Akhawe2013} (DCS) restricts propagation of information by using
\js|iframes| and mediating cross-domain operations (e.g. access to local
storage, fragment-IDs, network communication, etc.).  Every sandbox communicates
by \js!postMessage! only with its designated parent. The parent defines the
confinement policy and plays the role of man-in-the-middle when a sandbox wish
to communicate with another one. While having similar goals, DCS is more
restrictive than \sys. DCS disallows dynamic code evaluation inside sandboxes
and presents a not egalitarian design, i.e., a sandbox (\js|iframe|) cannot host
another sandbox. Clearly, the DCS client-side TCB is smaller than ours.

% ConDOM 
Using WebKit, ConDOM~\cite{ConDOM} implements fine-grain label tracking at the
JavaScript engine and DOM elements. To handle implicit flows, authors use a
control flow stack (neglecting exceptions), and inject labels at the HTML parser
for dynamically generated code. Instead, \sys{} allows to handle any type of
branches or dynamic code by just using browsing contexts.

% Google extensions security analysis 
Carlini et al.~\cite{Carlini:2012} evaluate the security of the Google Chrome
extension platform. The authors describe several extensions' vulnerabilities, among them,
how content scripts can inject arbitrary code (in a form of strings) into the
page DOM. Extensions can then run within the page context in order
to exfiltrate data. \sys{} is capable to securely mimicking content scripts, but
with weaker isolation guarantees.  Specifically, content scripts operate on a
copy of DOM wrapper objects, which makes changes not visible for the
page. Instead, \sys{} versions of content scripts work directly on the page DOM.
It is stated as future work to evaluate how to express other 
security mechanisms from the extension platform into \sys{}. 

 

% Local Variables:
% TeX-master: "main.ltx"
% TeX-command-master: "make"
% tex-dvi-view-command: "gmake preview;:"
% End:
